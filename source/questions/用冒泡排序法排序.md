---
title: 用冒泡排序法排序
tags: [HTML]
type: CODE
template: "const bubbleSort = (arr) => {\n\n};\nbubbleSort([13,4,9,25, 10, 8, 11])"
result: "[4,8,9,10,11,13,25]"
date: 2018-1-15 18:10:20
---

写出冒泡排序法的基本思想，时间空间复杂度，并对数组[13, 4, 9, 25, 10, 8, 11]进行排序。

---

- 冒泡排序法

  基本思想: 两个数比较，较小的数冒泡起来，较大的数下沉

  过程:

  - 比较相邻的两个数，如果第二个数小，就交换位置
  - 从后往前两两比较，直到最前面两个数，此时最小的数被排到了前面
  - 重复上述过程，依次将第 2，3...n 个最小的数排好位置

  ```
  var bubbleSort = arr => {
    let tmp;
    let flag = false;
    for (let i = 0; i < arr.length - 1; i++) { //表示排序次数
      for (let j = arr.length - 1; j > i; j--) {
        if (a[j] < a[j - 1]) {
          tmp = a[j];
          a[j] = a[j - 1];
          a[j - 1] = tmp;
          flag = true;
        }
      }
      if (!flag) break; //flag为false表明没有位置交换，也就是说数组已经是有序的了
    }
  };
  ```

  **时间复杂度计算:**

  如下: 冒泡排序的时间复杂度为 O(n^2)

  ```
  假设数组长度为n，算法执行次数为T(n)，时间复杂度为O(T(n))
  T(n) = (n - 1) + (n - 2) + (n - 3) + ... + n - (n - 1)
       = ((n - 1) + 1) * (n - 2) / 2
       = 0.5 * n^2 - n
  O(T(n)) = O(n^2)
  ```

  **空间复杂度计算:**

  可以看到，冒泡排序并没有循环分配空间，只有变量 tmp、flag、i、j 分配了空间且与数组长度无关，因此冒泡排序的空间复杂度为 O(1)。
