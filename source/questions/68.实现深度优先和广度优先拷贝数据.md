---
title: 实现深度优先和广度优先拷贝数据
tags: [JavaScript]
type: CODE
template: ""
result: ""
date: 2018-1-15 18:10:20
---

实现对下例 data 对象的深度和广度拷贝。

```
const data = {
  data: 1,
  children: [
    {
      data: 2,
      children: [
        {
          data: 4,
          children: [{ data: 7 }, { data: 8 }, { data: 9 }]
        }
      ]
    },
    {
      data: 3,
      children: [
        {
          data: 5,
          children: [
            {
              data: 10
            }
          ]
        },
        {
          data: 6
        }
      ]
    }
  ]
};
```

---问题

- 深度优先遍历

  ```
  //递归版
  var deepCopyDFS = (origin, visitedItem = new Map()) => {
    const type = getType(origin);
    const isObject = isType(type, TYPE.OBJECT);
    const isArray = isType(type, TYPE.ARRAY);
    let target;
    if (isObject || isArray) {
      if (visitedItem.get(origin)) {
        //对环状数据进行处理
        target = origin;//为浅拷贝
      } else {
        target = isObject ? {} : [];
        for (let key in origin) {
          visitedItem.set(origin[key], true);
          target[key] = deepCopyDFS(origin[key], visitedItem);
        }
      }
    } else if (isType(type, TYPE.FUNCTION)) {
      target = eval(`(${origin.toString()})`);
    } else {
      target = origin;
    }
    return target;
  };

  //非递归版，利用栈的特性
  var getInitInfo = origin => {
    const type = getType(origin);
    const isObject = isType(type, TYPE.OBJECT);
    if (isObject) return { isObject, value: {} };

    const isArray = isType(type, TYPE.ARRAY);
    if (isArray) return { isArray, value: [] };

    return { value: origin };
  };

  var deepCopyDFS = (origin, visitedItem = new Map()) => {
    let { value, isObject, isArray } = getInitInfo(origin);
    if (!isObject && !isArray) return origin;

    let target = value;
    const stack = [[origin, target]];
    while (stack.length > 0) {
      const [ori, tar] = stack.pop();
      console.log("tar", tar);
      for (let key in ori) {
        const obj = getInitInfo(ori[key]);
        tar[key] = obj.value;
        if (obj.isObject || obj.isArray) {
          if (visitedItem.get(ori[key])) {
            tar[key] = ori[key];
          } else {
            visitedItem.set(ori[key], true);
            stack.push([ori[key], tar[key]]);
          }
        }
      }
    }
    return target;
  };

  ```

- 广度优先拷贝
  利用 queue 进行拷贝。

  ```
  function Queue() {
    const nodes = [];
    const add = node => {
      nodes.push(node);
    };
    const pop = () => {
      return nodes.shift();
    };

    return { add, pop };
  }
    var deepCopyBFS = (origin, visitedItem = new Map()) => {
    let { value, isObject, isArray } = getInitInfo(origin);
    if (!isObject && !isArray) return origin;

    const queue = Queue();
    let target = value;
    queue.add([origin, value]);
    let current = queue.pop();
    while (current) {
      console.log(JSON.stringify(target));
      const [ori, tar] = current;
      for (let key in ori) {
        const obj = getInitInfo(ori[key]);
        tar[key] = obj.value;
        if (obj.isObject || obj.isArray) {
          if (visitedItem.get(ori[key])) {
            tar[key] = ori[key];
          } else {
            visitedItem.set(ori[key], true);
            queue.add([ori[key], tar[key]]);
          }
        }
      }
      current = queue.pop();
    }
    return target;
  };
  ```
