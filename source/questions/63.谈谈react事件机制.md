---
title: 谈谈react事件机制
tags: [HTML]
type: SHORT_ANSWER
date: 2019-1-15 18:10:20
---

想要了解 react 的事件机制，我们需要一步步了解我们添加的事件是如何起作用的，如下：
react 是如何让下面这个 div 上监听的单击事件生效的呢？

```
//app.jsx
const App = () => <div title="click me" onClick={()=> alert('click')}>app</div>
ReactDOM.render(<App />, document.getElementById('root'));

```

我们知道每个 JSX 元素都是调用 React.createElement() 的语法糖，如下：

```
React.createElement(
  type,
  [props],
  [...children]
)
```

要知道 onClick 如何起作用就需要知道这个 props 是如何起作用的，于是查看 createElement 方法的源码，就是返回了一个带有 type、props 等信息的对象。

```
//react项目根目录下packages/react/src/ReactElement.js，省略不相关的源码
const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: ref,
    props: props,
    _owner: owner,
  };
  ...
  return element;
};

export function createElement(type, config, children) {
  // Reserved names are extracted
  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;
   ...省略生成这些变量值的源码

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}
```

再查看 react-dom 中的 render 方法，如下：

```
// packages/react-dom/src/client/ReactDOMLegacy.js
export function render(
  element: React$Element<any>,
  container: DOMContainer,
  callback: ?Function,
) {
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    false,
    callback,
  );
}

```

legacyRenderSubtreeIntoContainer 函数中涉及到一些异步调用，直接调试并不好弄清除 onClick 上的函数是如何绑定到 div 节点的，查看源码，发现有一个 setAttribute.js 的文件，断点到 setAttribute 函数，查看函数调用栈，最终在 setInitialDOMProperties 这个函数里发现了相关信息：

如其名，这个函数就是用来设置 dom 的属性，包括 css、style 等。

```
// packages/react-dom/src/client/ReactDOMComponent.js
function setInitialDOMProperties(
  tag: string,
  domElement: Element,
  rootContainerElement: Element | Document,
  nextProps: Object,
  isCustomComponentTag: boolean,
): void {
  for (const propKey in nextProps) {
      ...省略部分代码
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp != null) {
            if (__DEV__ && typeof nextProp !== 'function') {
            warnForInvalidEventListener(propKey, nextProp);
            }
            ensureListeningTo(rootContainerElement, propKey);
        }
      }
  }
}

```

ensureListeningTo 看着就比较像事件监听的样子，而 registrationNameModules 为预先注册的各种事件的名称。如下图：

 <center><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/react%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/registrationNameModules.png" /></center>
<center>registrationNameModules变量</center>
 propKey 为 onClick，似乎找对了地方。来看ensureListeningTo函数做了什么：

```
// packages/react-dom/src/client/ReactDOMComponent.js
function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}
```

这里的 registrationName 为我们要注册的事件名称(onClick)，rootContainerElement 为我们挂载的根节点(div#root)，如果这个根接点是 document 或 fragment(内存中的文档片段，可以认为是轻量版的 Document)就将 doc 赋值为 rootContainerElement，否则为 rootContainerElement.ownerDocument，即 document 对象。也就是说 document 或 fragment 会被传入到 listenTo 里，事件的委托就是在这里作的。继续看 listenTo：

```
// packages/react-dom/src/events/ReactBrowserEventEmitter.js
export function listenTo(
  registrationName: string,
  mountAt: Document | Element | Node,
): void {
  const listeningSet = getListenerMapForElement(mountAt);//事件集合，Set(0) {}
  const dependencies = registrationNameDependencies[registrationName];// registrationName:onClick, dependencies: ["click"]

  for (let i = 0; i < dependencies.length; i++) {
    const dependency = dependencies[i];
    listenToTopLevel(dependency, mountAt, listeningSet);
  }
}
```

registrationNameDependencies 为 React 事件名为 key，原生事件名为 value 的 map:

```
registrationNameDependencies
{onBlur: Array(1), onBlurCapture: Array(1), onCancel: Array(1), onCancelCapture: Array(1), onClick: Array(1), …}
onAbort: ["abort"]
onAbortCapture: ["abort"]
onAnimationEnd: ["animationend"]
onAnimationEndCapture: ["animationend"]
onAnimationIteration: ["animationiteration"]
onClick: ["click"]
onBeforeInput: (4) ["compositionend", "keypress", "textInput", "paste"]
onChange: (8) ["blur", "change", "click", "focus", "input", "keydown", "keyup", "selectionchange"]
...
```

看到这里可以知道 React 统一事件名可以兼容不同浏览器的事件，比如 onChange 可以对应上不同的原生事件"blur", "change", "click"等。通过这个 map 我们注册的 onClick 事件就能找到对应的原生事件 click，然后通过 listenToTopLevel 注册到 mountAt(document)上。继续看 listenToTopLevel：

```
// packages/react-dom/src/events/ReactBrowserEventEmitter.js
export function listenToTopLevel(
  topLevelType: DOMTopLevelEventType,
  mountAt: Document | Element | Node,
  listenerMap: Map<DOMTopLevelEventType | string, null | (any => void)>,
): void {
  if (!listenerMap.has(topLevelType)) {
    switch (topLevelType) {
      case TOP_SCROLL:
        trapCapturedEvent(TOP_SCROLL, mountAt);
        break;
      ...
      default:
        // By default, listen on the top level to all non-media events.
        // Media events don't bubble so adding the listener wouldn't do anything.
        const isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;
        if (!isMediaEvent) {
          trapBubbledEvent(topLevelType, mountAt);
        }
        break;
    }
    listenerMap.set(topLevelType, null);
  }
}
```

除了 scroll、focus、blur、cancel、close 走 trapCapturedEvent(捕获阶段注册事件)和一些无效的事件不处理外，其余都走 default，在 default 里只要不是媒体事件(play、pause 等，不会冒泡)都通过 trapBubbledEvent(冒泡阶段)来注册事件，由此可以知道，在 react 中大部分合成事件都是委托到 document 上注册的是冒泡阶段的事件监听器，也就是是说合成事件要等到事件冒泡到最外层的 document 才会被执行，因此所有原生事件的响应(无论是冒泡事件还是捕获事件)，都将早于 React 合成事件，想在 react 组件中通过 e.stopPropagation()来阻止外层的原生事件是办不到的。继续看 trapBubbledEvent：

```
// packages/react-dom/src/events/ReactDOMEventListener.js
function trapBubbledEvent(topLevelType, element) {
  trapEventForPluginEventSystem(element, topLevelType, false);
}

function trapEventForPluginEventSystem(
  element: Document | Element | Node,
  topLevelType: DOMTopLevelEventType,
  capture: boolean,
): void {
  let listener;
  switch (getEventPriority(topLevelType)) {
    case DiscreteEvent:
      listener = dispatchDiscreteEvent.bind(
        null,
        topLevelType,
        PLUGIN_EVENT_SYSTEM,
      );
      break;
    case UserBlockingEvent:
      listener = dispatchUserBlockingUpdate.bind(
        null,
        topLevelType,
        PLUGIN_EVENT_SYSTEM,
      );
      break;
    case ContinuousEvent:
    default:
      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);
      break;
  }

  const rawEventName = getRawEventName(topLevelType);
  if (capture) {
    addEventCaptureListener(element, rawEventName, listener);
  } else {
    addEventBubbleListener(element, rawEventName, listener);
  }
}
```

trapBubbledEvent 调用 trapEventForPluginEventSystem 生成了对应事件的回调函数 listener，在 addEventBubbleListener 中我们看到了熟悉的添加事件的方法，至此，我们注册的事件被添加到了目标元素上。

```
// packages/react-dom/src/events/EventListener.js
function addEventBubbleListener(element, eventType, listener) {
  element.addEventListener(eventType, listener, false);
}
```

事件注册的整个流程大致如下：

```

```

同时，可以看到我们注册的回调函数已经被包装过了，来看看 default 中的 dispatchEvent 是如何包装的。
