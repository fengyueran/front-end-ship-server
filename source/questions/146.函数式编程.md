---
title: 函数式编程
type: SHORT_ANSWER
date: 2020-5-06 18:10:20
---

函数式编程是一种 编程范式，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 更简洁、可预测、高复用、易测试。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。

- 常见的编程范式:

  - 命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；
  - 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；
  - 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；
  - 函数式编程
    - 换成一种更高端的说法，面向数学编程。怕不怕~🥴

- 函数式编程的理念:

  - 纯函数(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；

    - 优势:

      - 完全独立，与外部解耦；
      - 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；
      - 可测试性极强；

    - 条件:

      - 不修改参数；
      - 不依赖、不修改任何函数外部的数据；
      - 完全可控，参数一样，返回值一定一样: 例如函数不能包含 new Date()或者 Math.rando()等这种不可控因素；
      - 引用透明；

    - 我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如 split / join / map；

  - 函数复合: 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；

    - 扁平化嵌套: 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:

      - f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
      - 理想的做法: xxx(f, g, k)(x)

    - 结果传递: 如果想实现上面的方式，那也就是 xxx 函数要实现的便是: 执行结果在各个函数之间的执行传递；

      - 这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺序依次执行，传递执行结果；
      - 所以我们就能够实现一个方法 pipe，用于函数组合:

      ```js
      // ...fs: 将函数组合成数组；
      // Array.prototype.reduce 进行组合；
      // p: 初始参数；
      const pipe =
        (...fs) =>
        (p) =>
          fs.reduce((v, f) => f(v), p);
      ```

  - 使用: 实现一个 驼峰命名 转 中划线命名 的功能:

    ```js
    // 'Guo DongDong' --> 'guo-dongdong'
    // 函数组合式写法
    const toLowerCase = (str) => str.toLowerCase();
    const join = curry((str, arr) => arr.join(str));
    const split = curry((splitOn, str) => str.split(splitOn));

    const toSlug = pipe(toLowerCase, split(' '), join('_'), encodeURIComponent);
    console.log(toSlug('Guo DongDong'));
    ```

- 好处:

  - 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；
  - 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；
  - 可复用性强，任何一个函数单元都可被任意复用和组合；
  - 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

  ```js
  const log = curry((label, x) => {
    console.log(`${label}: ${x}`);
    return x;
  });

  const toSlug = pipe(
    toLowerCase,
    log('toLowerCase output'),
    split(' '),
    log('split output'),
    join('_'),
    log('join output'),
    encodeURIComponent
  );
  ```

> Tips:
> 一些工具纯函数可直接引用 lodash/fp，例如 curry/map/split 等，并不需要像我们上面这样自己实现；

- 数据不可变性(immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:

  - 倡导: 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；
  - 目的: 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；
  - 并不等同于 const。使用 const 创建一个对象后，它的属性仍然可以被修改；
  - 更类似于 Object.freeze: 冻结对象，但 freeze 仍无法保证深层的属性不被串改；
  - immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；

    - trie 数据结构:

      - 一种数据结构，能有效地深度冻结对象，保证其不可变；
      - 结构共享: 可以共用不可变对象的内存引用地址，减少内存占用，提高数据操作性能；

- 避免不同函数之间的 状态共享，数据的传递使用复制或全新对象，遵守数据不可变原则；

- 避免从函数内部 改变外部状态，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；

- 避免在单元函数内部执行一些 副作用，应该将这些操作抽离成更独立的工具单元；

  - 日志输出
  - 读写文件
  - 网络请求
  - 调用外部进程
  - 调用有副作用的函数

- 高阶函数: 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

  - 将逻辑行为进行 隔离抽象，便于快速复用，如处理数据，兼容性等；
  - 函数组合，将一系列单元函数列表组合成功能更强大的函数；
  - 函数增强，快速地拓展函数功能，

- 函数式编程的好处:

  - 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；
  - 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；
  - 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；
  - 更易于做单元测试。

- 总结:

  - 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；
  - 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；

> Tips:
> 其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些个人理解而已。博主也是初级小菜鸟，停留在表面而已，只求对大家能有所帮助，轻喷 🤣；
> 我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势。
> 理解和学习它们的理念与优势，合理地 设计融合，将优秀的软件编程思想用于提升我们应用；
> 所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复用，开发更为高效和安全；
> 有一些库能让大家很快地接触和运用函数思想: Underscore.js / Lodash/fp / Rxjs 等。

链接：https://juejin.cn/post/6844903801153945608
