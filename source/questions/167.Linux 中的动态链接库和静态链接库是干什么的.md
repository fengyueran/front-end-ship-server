---
title: Linux 中的动态链接库和静态链接库是干什么的
date: 2020-5-06 18:10:20
---

### 什么是库？

库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。 windows 上对应的是.lib .dll linux 上对应的是.a .so。
在这里先介绍下 Linux 下的 gcc 编译的几个选项

```
g++ -c hellospeak.cpp会将hellospeak.cpp
```

选项 -c 用来告诉编译器编译源代码但不要执行链接，输出结果为对象文件。文件默认名与源码文件名相同，只是将其后缀变为 .o。例如，上面的命令将编译源码文件 hellospeak.cpp 并生成对象文件 hellospeak.o；

下面这条命令将上述两个源码文件编译链接成一个单一的可执行程序：

```
$ g++ hellospeak.cpp speak.cpp -o hellospeak
```

如果没有-o 和后面的参数，编译器采用默认的 a.out

本例中就会生成 hellospeak 这样的可执行程序所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：
图：编译过程

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/167.Linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/compile.png)

### 静态库

之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o 与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o 文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj 文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：

- 静态库对函数库的链接是放在编译时期完成的。
- 程序在运行时与函数库再无瓜葛，移植方便。
- 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

Linux 下创建与使用静态库 Linux
静态库命名规则 Linux
静态库命名规范，必须是"lib[your_library_name].a"：lib 为前缀，中间是静态库名，扩展名为.a。
创建静态库（.a）
通过上面的流程可以知道，Linux 创建静态库过程如下：

- 首先，将代码文件编译成目标文件.o（StaticMath.o）
  g++ -c StaticMath.cpp
  注意带参数-c，否则直接编译为可执行文件
- 然后，通过 ar 工具将目标文件打包成.a 静态库文件

`ar -crv libstaticmath.a StaticMath.o`
生成静态库 libstaticmath.a。
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/167.Linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/lib-compile.jpeg)

> -------------------------------分割线------------------------

### 动态库

通过上面的介绍发现静态库，容易使用和理解，也达到了代码复用的目的，那为什么还需要动态库呢？
为什么还需要动态库？
为什么需要动态库，其实也是静态库的特点导致。

- 空间浪费是静态库的一个问题。
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/167.Linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/lib.jpeg)

- 另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库 liba.lib 更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/167.Linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/dll.jpeg)

动态库特点总结：

- 动态库把对一些库函数的链接载入推迟到程序运行的时期。
- 可以实现进程之间的资源共享。（因此动态库也称为共享库）
- 将一些程序升级变得简单。
- 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。Window 与 Linux 执行文件格式不同，在创建动态库的时候有一些差异。
- 在 Windows 系统下的执行文件格式是 PE 格式，动态库需要一个 DllMain 函数做出初始化的入口，通常在导出函数的声明时需要有\_declspec(dllexport)关键字。
- Linux 下 gcc 编译的执行文件默认是 ELF 格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便。与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。

参考于：

> http://www.cnblogs.com/skynet/p/3372855.html

> http://www.cnblogs.com/iloveyoucc/archive/2012/08/29/2661851.html

链接：https://www.zhihu.com/question/20484931/answer/69553616
