---
title: 插入排序算法排序
tags: [HTML]
type: CODE
template: "const insertionSort = (arr) => {\n\n};\ninsertionSort([13,4,9,25, 10, 8, 11])"
result: "[4,8,9,10,11,13,25]"
date: 2018-1-15 18:10:20
---

写出用插入排序算法排序的基本思想，时间空间复杂度，并对数组[13, 4, 9, 25, 10, 8, 11]进行排序。

---问题

- 插入排序算法
  一般来说，插入排序都采用 in-place 在数组上实现。
  基本思想:

  - 从第一个元素开始，该元素可以认为已经排好序
  - 从下一个元素开始，在已经排序的元素序列中，从后向前开始扫描
  - 如果该元素(已排序的元素)大于新元素，则将该元素向后移动
  - 重复步骤 3，直到找到已排序元素小于等于新元素的位置
  - 将新元素插入到该位置
  - 重复步骤 2-5

  ```
  var insertionSort = arr => {
  let preIndex;
  let current;
  const n = arr.length;
  for (let i = 1; i < n ; i++) {
    preIndex = i - 1;
    current = arr[i];
    while (preIndex >= 0 && arr[preIndex] > current) {
      arr[preIndex + 1] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex+1] = current;
  }
  return arr;
  };

  ```

  数组`[8,5,3,7,1]`用插入排序法过程如下：

  ```
  8 5 3 7 1
  5 8 3 7 1
  3 5 8 7 1
  3 5 7 8 1
  1 3 5 7 8
  ```

  **时间复杂度计算**
  如果目标是升序排列一个数组，那么存在最好和最坏的情况。最好的情况：如果数组已经是按升序排列，则只需要进行 n-1 次比较操作；最坏的情况：数组是按降序排列

  ```
  如果数组是降序排列：
  当i=1时，运行次数T(1)= 1;
  当i=2时，运行次数T(2)= 2;
  当i=3时，运行次数T(3)= 3;
  ...
  当i=n-1时，运行次数T(n-1)= n - 1;
  因此总的运行次数T(n) = 1 + 2 + 3 + ... + (n-2) + (n-1)
                    =  0.5 * (n^2 - n)
                    = O(n^2)

  ```

  平均来说插入排序算法复杂度为 O(n^2)，为**稳定算法**。
  **空间复杂度**
  由于该算法额外开辟的空间只有几个变量，因此其**空间复杂度为 O(1)**。
