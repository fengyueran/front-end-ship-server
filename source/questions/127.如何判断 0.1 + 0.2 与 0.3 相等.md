---
title: 如何判断 0.1 + 0.2 与 0.3 相等
type: SHORT_ANSWER
date: 2020-5-06 18:10:20
---

先看两个简单但诡异的代码：

```
0.1 + 0.2 > 0.3 // true
0.1 * 0.1 = 0.010000000000000002
```

0.1 加 0.2 为什么就不等于 0.3 昵？要回答这个问题，得先了解计算机内部是如何表示数的。

### 计算机内部如何表示数

我们都知道，计算机用位来储存及处理数据。每一个二进制数（二进制串）都一一对应一个十进制数。

- 计算机内部如何表示整数
  这里以十进制数 13 来展示“按位计数法”如何表示整数：

  | 十进制值 | 进制 | 按位格式 | 描述                                          |
  | -------- | ---- | -------- | --------------------------------------------- |
  | 13       | 10   | 13       | 1x10^1 + 3x10^0 = 10 + 3                      |
  | 13       | 2    | 1101     | 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1 |

- 计算机内部如何表示小数
  再看小数怎么用按位计数法表示，以十进制数 0.625 为例：

  | 十进制值 | 进制 | 按位格式 | 描述                                             |
  | -------- | ---- | -------- | ------------------------------------------------ |
  | 0.625    | 10   | 0.625    | 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005 |
  | 0.625    | 2    | 0.101    | 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8        |

- 如何用二进制表示 0.1

  关于十进制与二进制间如何转换，这里不细说，直接给出结论：

  十进制整数转二进制方法：除 2 取余；十进制小数转二进制方法：乘 2 除整

  十进制 0.1 转换成二进制，乘 2 取整过程：

  ```
    0.1 _ 2 = 0.2 # 0
    0.2 _ 2 = 0.4 # 0
    0.4 _ 2 = 0.8 # 0
    0.8 _ 2 = 1.6 # 1
    0.6 _ 2 = 1.2 # 1
    0.2 _ 2 = 0.4 # 0
    .....
  ```

  从上面可以看出，0.1 的二进制格式是：0.0001100011....。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？

  答案是：在某个精度点直接舍弃。当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1。当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于 0.3 的原因。

  有误差的两个数，其计算的结果，当然就很可能与我们期望的不一样了。注意前面的这句话中的“很可能”这三个字？为啥是很可能昵？

### 0.1 + 0.1 为什么等于 0.2

答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。

又如，对于 0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为 0.4 了，而不展示一个浮点数的真实结果了。

另外要注意，**二进制能精确地表示位数有限且分母是 2 的倍数的小数**，比如 0.5，0.5 在计算机内部就没有舍入误差。所以 0.5 + 0.5 === 1

### 计算机这样胡乱舍入，能满足所有的计算需求吗

我们看两个现实的场景：

- 对于一个修建铁路的工程师而言，10 米宽，还是 10.0001 米宽并没有什么不同。铁路工程师就不需要这么高 0.x 这样的精度
- 对于芯片设计师，0.0001 米就会是一个巨大不同，他也永远不用处理超过 0.1 米距离

**不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在**。10.0001 与 10.001 在铁路工程师看来都是合格的。

虽然允许误差存在，但程序员在使用浮点数进行计算或逻辑处理时，不注意，就可能出问题。记住，**永远不要直接比较两个浮点的大小：**

```js
var a = 0.1;
var b = 0.2;

if (a + b === 0.3) {
  // doSomething
}
```

### JS 中如何进入浮点数运算

#### 将浮点运算转换成整数计算

整数是完全精度的，不存在舍入误差。例如，一些关于人民币的运算，都会以分为基本单位，计算采用分，展示再转换成元。当然，这样也有一些问题，会带来额外的工作量，如果那天人民币新增了一个货币单位，对系统的扩展性也会有考验。

#### 使用 bignumber 进行运算

bignumber.js 会在一定精度内，让浮点数计算结果符合我们的期望。

```js
{
  let x = new BigNumber(0.1);
  let y = new BigNumber(0.2);
  let z = new BigNumber(0.3);

  console.log(z.equals(x.add(y))); // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y)); // true
  console.log(z.minus(y).equals(x)); // true
}
```

```js
{
  let x = 0.2;
  console.log(x * x === 0.04); // false
  let y = new BigNumber(0.2);
  let r = y.mul(y); // 0.04
  console.log(r.equals(new BigNumber(0.04))); // true
}
```

更多例子，可以看 bignumber.js 官方示例。

### 小结

本文主要介绍了浮点数计算问题，简单回答了为什么以及怎么办两个问题：

- 为什么 0.1 + 0.2 不等于 0.3。因为计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数
- 并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差
- 具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正”
- 怎么办？1 个办法是使用整型代替浮点数计算；2 是不要直接比较两个浮点数，而应该使用 bignumber.js 这样的浮点数运算库

## 解决办法

- 设置一个误差范围值

通常称为“机器精度”，对 js 的数字来说，这个值通常是 2^-52(2.220446049250313e-16
ES6 中，该值定义在 Number.EPSILON 中。可以直接使用。ES6 之前版本可以写 polyfill:

```js
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, -52);
}
```

```js
function DeviationValue(num1, num2) {
  return Math.abs(num1 - num2) < Number.EPSILON;
}
```

因为 JavaScript 使用 IEEE 浮点类型双精度。转换为二进制在计算但是小数无限延伸，二进制截取 53 位导致精度丢失。
这就是 0.1+0.2 不为 0.3 的原因
Number.EPSILON 的精度是 2^-52，所以只要丢失精度小于 Number.EPSILON 基本可以确认相等。

- 将数字转成整数

例：判断 0.1+0.2 和 0.3 是否相等，可将值扩大为 1+2 和 3 是否相等

```js
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

### 其他参考

- https://github.com/mqyqingfeng/Blog/issues/155
- https://juejin.cn/post/6844903680362151950
- https://0.30000000000000004.com/#ada
- https://zhuanlan.zhihu.com/p/225490777
