---
layout: post
title: 富文本编辑器的技术演进
category: js
tagline: "Supporting tagline"
tags: [Other]
description:
date: 2019-9-25 18:10:20
---

# 富文本编辑器的技术演进


通常大家把编辑器技术的发展分为三个阶段。

### Level 0 阶段

**编辑器的起始阶段，代表完全基于浏览器原生技术实现。**

L0的实现依赖于浏览器提供的两个原生特性：
- [contenteditable](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Editable_content)
  contenteditable 特性，可以指定某一容器变成可编辑器区域，即用户可以在容器内直接输入内容，或者删减内容。

- [document.execCommand()](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand)(当前已经被废弃)

  execCommand API，可以对选中的某一段结构体，执行一个命令，譬如赋予黑体格式。

基于这两个特性我们来实现一个支[持redo、undo以及字体加粗的编辑器](https://codepen.io/fengyueran/pen/GRvJjax)：

- 支持编辑
  非常简单只需要一句代码：
  ```html
  <div contenteditable="true">这是一个可编辑区域</div>
  ```
- 支持redo、undo以及字体加粗
  也非常简单，只需要通过execCommand执行相应命令:
  ```js
  function bold(){
    document.execCommand('bold', false, null);
  }
  function redo(){
    document.execCommand('redo', false, null);
  }
  function undo(){
    document.execCommand('undo', false, null);
  }
  ```
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/62.%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/l0-editor.gif)

看上去非常简单，L0的优点在于：
- 底层完全使用浏览器原生能力，不用考虑数据模型、排版，输入等问题。
- 直接使用 HTML 文件作为存储模型，不需要任何 UI 框架。

同样，L0的缺点也很突出：
- 兼容性问题
  完全依赖execCommand去操作dom，各家浏览器可能有不同的实现，导致相同的数据呈现出不同的效果。
- 能力有限
  只接受有限的 [commands](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Commands)。

L0阶段的编辑器(CKEditor(1-4)、TinyMCE、UEditor等)针对上述缺点采取的主要思路是：对不同浏览器作兼容性处理，并规避一些bug；对有限的命令集进行补充。但仍存在很多问题：
- 兼容不同浏览器成本巨大且不够稳定
- 对命令集只是进行补充，自行封装实现效果并不提供通用的可扩展的接口
- 不可预测的交互容易出现数据混乱(拖拽、复制粘贴、删除）
- 特定结构的富文本内容(图片+Caption)实现复杂
- 协同编辑困难(CKEditor 5重头开始做的根本原因)




### Level 1 阶段
**这个阶段，弃用浏览器自带的 execCommand，完全自己实现富文本样式操作。**
根据数据模型的不同又可以分为：
- 传统模式
  dom树就是数据模型，各种操作都是调用dom api来实现。典型的产品有：CKEditor4、TinyMCE、UEditor...
- MVC模式
  这里的MVC模式强调的是自建数据模型，通过更新数据来触发渲染并提供通用扩展接口。典型的产品有：CKEditor 5、Slate.js、Quill.js、Draft.js、ProseMirror...

如果我们要自己实现一个L1的编辑该怎么办呢？首先，我们要对选中的节点进行操作(比如加粗)，就需要知道哪些节点当前被选中了，这里需要知道两个非常重要的概念[Selection和Range](https://zh.javascript.info/selection-range)，知道这两个概念，我们来实现一个具有加粗功能的编辑器：

```html
<!DOCTYPE html>
<html lang="en">
  <script>
    function bold(){
      const selection = getSelection();
      const range = selection.getRangeAt(0);
      const boldNode = document.createElement('b');
      //为简单起见直接用range的api在选中的范围外用tag b包裹
      range.surroundContents(boldNode);
    }
    </script>
  <body>
    <button onclick="bold()">B</button>
    <div contenteditable="true">这是一个可编辑区域</div>
  </body>
</html>
```
通过调用bold函数就能够加粗选中的区域，但实现加粗的方式就是直接去操纵dom。如果要以MVC的方式去实现，首先需要定义数据模型：
```ts
interface Block {
  id: string;
  type: string;
  data: any
}
interface Model {
  version: string;
  time: number;
  blocks: Block[]
}
```
给定一个简单的模型：
```json
{
  "version": "0.0.1",
  "time": 1634199202533,
  "blocks": [
    {
      "id": "1",
      "type": "paragraph",
      "data": {
        "text": "这是一个可编辑区域"
      }
    }
  ]
}
```
通过MVC的方式实现加粗的功能：
```html
<!DOCTYPE html>
<html lang="en">
  <script>
    var model = {
      version: "0.0.1",
      time: 1634199202533,
      blocks: [
        {
          id: "1",
          type: "paragraph",
          data: {
            text: "这是一个可编辑区域",
          },
        },
      ],
    };

    function renderBlock(block) {
      switch (block.type) {
        case "paragraph":
          return `<p id=${block.id}>${block.data.text}</p>`;
        default:
          break;
      }
    }

    function render(data) {
      let html = "";
      data.blocks.forEach((block) => {
        html += renderBlock(block);
      });
      const root = document.getElementById("editor");
      root.innerHTML = html;
    }

    function getSelectedNodeInfo() {
      const selection = getSelection();
      const range = selection.getRangeAt(0);

      const id = range.commonAncestorContainer.parentNode.getAttribute("id");
      const fragment = range.cloneContents();
      const serializer = new XMLSerializer();
      const docFragmentStr = serializer.serializeToString(fragment);

      return { id, text: docFragmentStr };
    }

    function updateModel(selectedNodeInfo) {
      const foundIndex = model.blocks.findIndex(
        ({ id }) => selectedNodeInfo.id === id
      );
      if (foundIndex >= 0) {
        const newBlocks = [...model.blocks];
        const originBlock = newBlocks[foundIndex];
        const textNeedBold = selectedNodeInfo.text;
        const newText = originBlock.data.text.replace(
          textNeedBold,
          `<b>${textNeedBold}</b>`
        );
        newBlocks[foundIndex] = {
          ...originBlock,
          data: {
            text: newText,
          },
        };
        const newModel = {
          ...model,
          time: Date.now(),
          blocks: newBlocks,
        };
        return newModel;
      }
      return model;
    }

    function bold() {
      const selectedNodeInfo = getSelectedNodeInfo();
      const newModel = updateModel(selectedNodeInfo);
      render(newModel);
    }

    window.onload = () => {
      render(model);
    };
  </script>
  <body>
    <button onclick="bold()">B</button>
    <div id="editor" contenteditable="true"></div>
  </body>
</html>

```
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/62.%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/l1-editor.gif)
以上，粗陋的实现了一个L1的编辑器，其主要的思路就是定义数据模型，通过数据驱动来修改文档。现代L1的编辑器总体也是这个思路，他们对数据模型的设计、虚拟dom、协同编辑、扩展性有更深更广的考虑。

我们来看一下主流的L1开源编辑器的实现方式：
- [Quill.js(2012)](https://github.com/quilljs/quill)

quilljs 是一款非常优秀的编辑器，github数量已达31.1k，足见其受欢迎程度。
quilljs底层虽然依赖浏览器dom contentEditable特性，但对dom tree以及数据模型的修改进行了抽象，实现编辑功能不再是直接修改dom而是通过操作模型操作api。这里需要知道几个重要的概念：Delta、Parchment & Blots。

**[Delta](https://quilljs.com/docs/delta/)**
  
   >Deltas are a simple, yet expressive format that can be used to describe Quill’s contents and changes. The format is a strict subset of JSON, is human readable, and easily parsible by machines. Deltas can describe any Quill document, includes all text and formatting information, without the ambiguity and complexity of HTML.

   Delta为JSON的一个子集，用来描述编辑器的**内容**及**变化**，只包含一个 ops 属性，它的值是一个对象数组，每个数组项代表对编辑器的一个操作。
   下面是一段富文本内容描述：
   hello **Quill**
   用Delta进行描述：
   ```json
   {
    "ops": [
        { "insert": "Hello" },
        { 
        "insert": "Quill",
        "attributes": { "bold": true } 
        },
        { "insert": "！" }
      ]
   }
   ```
   Delta只有3种动作和1种属性，却足以描述任何富文本内容和变化。

   3种动作：

   - insert：插入
   - retain：保留
   - delete：删除

   1种属性：
   - attributes：格式属性
    
   Delta的描述方式其实[OT(Operation Transformation)](http://www.alloyteam.com/2019/07/13659/)模型的一种实现，而协同编辑通常都是基于OT操作之上实现的，因此Quill天然就支持协同编辑。
   
   **[Parchment & Blots](https://github.com/quilljs/parchment)**
   >Parchment is Quill's document model. It is a parallel tree structure to the DOM tree, and provides functionality useful for content editors, like Quill. A Parchment tree is made up of Blots, which mirror a DOM node counterpart. Blots can provide structure, formatting, and/or content. Attributors can also provide lightweight formatting information.


   Parchment是Quill.js中对于DOM的抽象，Parchment其实是与DOM树对应的结构，Parchment由Blots组成，Blot即与DOM的Node对应，Quill.js文档怎么渲染完全由Blot决定，那么这层模型其实就是Delta数据与最终UI之间的一个中间层。这与我最初的想象是不一样的，我最初认为dom树直接由数据模型来映射，并不存在像Parchment这样的中间层。这个中间层带来的好处是能够更容易的控制dom的修改。

   quiijs的架构图([引自](https://mp.weixin.qq.com/s/Ui0qaMup-KWXiz3RBM14Kw))如下，
   ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/62.%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/quilljs-structure.png)
   Delta模型的改变有两种方式：
   - 文本输入
     通过[MutationObserver](https://zh.javascript.info/mutation-observer)来监听dom的变化，然后同步变化到Delta。
   - 复杂的样式或者格式操作等非浏览器默认行为
     交互行为改变Delta，Delta驱动Parchment的改变进而改变dom。


### Level 2 第三阶段，完全不依赖浏览器的编辑能力，独立的实现光标和排版

下面我在介绍的编辑器的时候也会对它们所处的阶段进行简单的归纳，方便大家理解。

### 参考文档


- [钉钉文档编辑器的前世今生](https://www.yuque.com/zaotalk/posts/ftpxn7)
- [有道云笔记跨平台富文本编辑器的技术演进](https://mp.weixin.qq.com/s/9gDI1r9aAu6dHJhXg34eIg?)
- [我做编辑器这些年：钉钉文档编辑器的前世今生](https://zhuanlan.zhihu.com/p/157215963)
- [2021年富文本编辑器架构之道](https://zhuanlan.zhihu.com/p/356707603)
- [开源富文本编辑器技术的演进（2020 1024）](https://zhuanlan.zhihu.com/p/268366406)
- [富文本编辑器 L1 能力调研记录](https://juejin.cn/post/6954896971370856485)
- [深入浅出contenteditable富文本编辑器](https://juejin.cn/post/6844903608035573774)
- [开源富文本编辑器技术的演进](https://juejin.cn/post/6974609015602937870)
- [富文本编辑器初探](https://juejin.cn/post/6844903555900375048)

- [富文本原理了解一下？](https://juejin.cn/post/6844903871110709256)
- [富文本编辑器初探](https://juejin.cn/post/6955335319566680077)
- [富文本编辑器之游戏角色升级ing](https://juejin.cn/post/6981249485267533854)
- [从流行的编辑器架构聊聊富文本编辑器的困境](http://yoyoyohamapi.me/2020/03/01/%E4%BB%8E%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%9E%B6%E6%9E%84%E8%81%8A%E8%81%8A%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%9B%B0%E5%A2%83/)
- [富文本编辑器的技术演进](https://time.geekbang.org/dailylesson/detail/100040826)
- [富文本编辑器的技术演进之路](https://developer.aliyun.com/article/712971)
- [现代编辑器技术原理](https://www.wenxi.tech/principles-of-modern-editor-technology)
- [开源富文本编辑器技术的演进](https://mp.weixin.qq.com/s/Ui0qaMup-KWXiz3RBM14Kw)

- [从零写一个富文本编辑器（二）——文档模型](https://juejin.cn/post/6934368266382999565)
- [Why ContentEditable is Terrible](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480)

- [揭开在线协作的神秘面纱 – OT 算法](http://www.alloyteam.com/2019/07/13659/)

- [现代 Web 富文本编辑器 Quill.js](https://juejin.cn/post/6918893948412887053)
- [深入浅出Quill-现代富文本编辑器Quill的模块化机制](https://juejin.cn/post/6844904073620094990)
- [quill-better-table：赋予quill富文本编辑器强大的表格编辑功能！](https://juejin.cn/post/6844903830962831373)
- [quilljs](https://quilljs.com/docs/quickstart/)
- [Getting to know QuillJS - Part 1 ](https://dev.to/charrondev/getting-to-know-quilljs---part-1-parchment-blots-and-lifecycle--3e76)
- [The State of Quill and 2.0](https://medium.com/@jhchen/the-state-of-quill-and-2-0-fb38db7a59b9)
- [mutation-observer](https://zh.javascript.info/mutation-observer)