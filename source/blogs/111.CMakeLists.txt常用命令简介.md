# CMakeLists.txt 常用命令简介

## 基础配置

### cmake_minimum_required(VERSION x.y)

- 指定要求的最低 CMake 版本。
- 例：cmake_minimum_required(VERSION 3.20)

VERSION x.y 要填多少版本，可以根据下面这些因素来确定：

- 你项目里用到了哪些 CMake 特性？

  - 每个 CMake 特性都是从某个版本开始支持的。
  - 比如：
    - target_link_options 是 CMake 3.13 才加的。
    - CMAKE_CXX_STANDARD_REQUIRED 和 CMAKE_CXX_STANDARD 是 3.1 加的。
    - qt_add_executable 是 Qt6 新的 CMake API（要求 CMake 3.16 以上）。

- 依赖的第三方库要求的最低版本？
  - 比如：
    - 你用的 Qt 6，官方要求 CMake 3.16 起步。
    - OpenCV 4.5+ 推荐 CMake 3.10+。
  - 第三方库 CMake 配置比较新，也会推高你项目的 CMake 要求。

### project(ProjectName VERSION major.minor.patch [LANGUAGES ...])

- 定义工程名称、项目版本号以及使用的语言。
- 例：project(MyAwesomeApp VERSION 1.2.3 LANGUAGES CXX)

- ProjectName

  - 就是给你的项目起个名字。
  - 后面生成的工程文件（比如 Visual Studio 的 Solution 名字）会用到这个名字。
  - 也会生成一些自动变量，比如 PROJECT_NAME。

- VERSION major.minor.patch

  - 这里指定项目的版本号，格式是 主版本.次版本.补丁版本。
  - 这样写之后，CMake 会自动生成这些变量（很有用）：
    - PROJECT_VERSION
    - PROJECT_VERSION_MAJOR
    - PROJECT_VERSION_MINOR
    - PROJECT_VERSION_PATCH
    - 特别注意：如果你以后要用 install()、package()、或者控制依赖版本时，这些变量非常方便。

- LANGUAGES
  - 指定项目支持的编程语言。
  - 常见的语言关键字有：
    - C
    - CXX（C++）
    - Fortran
    - ASM（汇编）
  - 如果不写 LANGUAGES，默认是 C 和 CXX 都启用。
  - 如果你只想用 C++，最好明确写一下，避免 C 相关的检测浪费时间。

## 添加源文件

### add_executable(TargetName [WIN32] [MACOSX_BUNDLE] source1 source2 ...)

add_executable 作用就是告诉 CMake：我要生成一个可执行程序（.exe、可运行文件）！

比如你有几个 .cpp 文件，想编译成一个程序，
就用 add_executable 把它们组合在一起，变成最终的可执行文件。

- TargetName：你生成的可执行程序的名字。
- source1 source2 ...：列出所有要编译的源代码（.cpp）文件。
- [WIN32]：如果是 Windows 平台，用来生成无控制台的 GUI 程序。
- [MACOSX_BUNDLE]：如果是 macOS 平台，用来生成 .app 程序包。

简单示例

比如你的项目是：

```code
src/
   main.cpp
   app.cpp
   app.h
```

你可以这么写：

```code
//如果你的程序是 Windows GUI 程序（比如 Qt 程序，不想弹出黑色控制台窗口），可以加上 WIN32：
add_executable(MyApp WIN32
   src/main.cpp
   src/app.cpp
)
```

这样 CMake 就会生成一个叫 MyApp 的可执行程序。
跨平台写法

```code
# 自动获取所有源文件
file(GLOB SOURCES
    main.cpp
    other.cpp
    # 可以用通配符自动找其他源文件
    src/*.cpp
)

# 根据平台添加不同的选项
if (WIN32)
    add_executable(MyApp WIN32 ${SOURCES})
elseif(APPLE)
    add_executable(MyApp MACOSX_BUNDLE ${SOURCES})
else()
    add_executable(MyApp ${SOURCES})
endif()
```

注意事项

- .h（头文件）不需要加到 add_executable，编译器会根据 .cpp 里的 #include 自动找到。
- .cpp 只要是想参与编译的，都应该列上。
- 如果漏了 .cpp，编译会报错，比如 “undefined reference”。
- Qt 项目推荐用 qt_add_executable，因为它可以自动处理 .ui、.qrc、moc 等文件。

### add_library(targetName [STATIC|SHARED|MODULE] [sources…])

在 CMake 中，add_library 是用来生成**库（Library）**的指令。

- 不是可执行程序（不像 add_executable）
- 是一组可以被其他程序复用的代码模块
- 可以生成 静态库（.a / .lib） 或 动态库（.so / .dll）

参数说明

- targetName 你定义的库的名字
- STATIC 生成静态库（.a，.lib）
- SHARED 生成动态库（.so，.dll）
- MODULE 生成模块库（插件，不会自动链接）
- INTERFACE 头文件库（纯接口，没有实际源代码）
- OBJECT 生成对象文件库（.o 文件集合）
- [sources…] 源文件列表

最常见的例子

生成静态库：

```code
add_library(mylib STATIC
   foo.cpp
   bar.cpp
)
```

最终生成：

- libmylib.a（Linux）
- mylib.lib（Windows）

- 生成动态库：

```code
add_library(mylib SHARED
   foo.cpp
   bar.cpp
)
```

最终生成：
• libmylib.so（Linux）
• mylib.dll（Windows）

常搭配的命令

通常加完 add_library 后，还要配：

- target_include_directories() ➔ 头文件路径
- target_link_libraries() ➔ 链接依赖
- target_compile_options() ➔ 编译选项
- target_sources() ➔ 管理源文件

### target_sources(targetName [PRIVATE | PUBLIC | INTERFACE] sources…)

target_sources 是往已有的 target（比如 executable 或 library）追加源文件的命令。

而不是在 add_executable 或 add_library 里一次性写完所有源文件，可以后面慢慢加，更灵活、可读性更好。

参数说明

- targetName 目标名字，比如你的库或者程序
- PRIVATE 这些源文件只属于自己
- PUBLIC 自己用、别人链接时也能看到（很少用于源文件，更多用于头文件）
- INTERFACE 自己不用，别人链接时才能用（一般也是头文件用）

大多数情况下，源文件都是 PRIVATE。

举个最常见的例子

比如你先定义了一个库：

```code
add_library(mylib STATIC)
```

然后把文件分开添加：

```code
target_sources(mylib
   PRIVATE
   foo.cpp
   bar.cpp
)
```

这样，foo.cpp 和 bar.cpp 就属于 mylib 了！

## 包含目录和链接库

### target_include_directories(targetName [PUBLIC|PRIVATE|INTERFACE] dirs…)

target_include_directories 是给一个目标（target，dd_executable 或 add_library 创建出来的那个东西）设置头文件搜索路径，告诉编译器在哪些地方找 .h 或 .hpp 文件。

- targetName：你的库或可执行程序，比如 myapp、mylib
- PRIVATE：路径只用于自己编译
- PUBLIC：自己和别人（依赖者）都用这个路径
- INTERFACE：自己不用，依赖者需要这个路径
- dirs…：路径列表，可以是相对路径、绝对路径或者变量

简单例子

1. 可执行程序添加头文件路径

```code
add_executable(myapp main.cpp)

target_include_directories(myapp
   PRIVATE
   ${CMAKE_CURRENT_SOURCE_DIR}/include
)
```

意思是：

- myapp 编译时，去 ${CMAKE_CURRENT_SOURCE_DIR}/include 里面找头文件
- 别的 target 如果链接 myapp，不会继承这个路径

2. 给库添加公共头文件路径

```code
add_library(mylib src/foo.cpp)

target_include_directories(mylib
   PUBLIC
   ${CMAKE_CURRENT_SOURCE_DIR}/include
)
```

意思是：

- mylib 编译时要去 include/文件夹查找头文件
- 依赖 mylib 的项目也自动知道 include/ 要加到头文件搜索路径

比如你在另一个项目：

```code
target_link_libraries(myapp mylib)
```

自动就能找到 include/foo.h，不用自己再 include_directories！

举个具体例子

比如你的工程目录是：

```code
project_root/
├── include/
│   ├── foo.h
│   └── deeper/
│       └── bar.h
├── src/
│   └── main.cpp
├── CMakeLists.txt
```

然后在 main.cpp 里你写：

```code
#include "foo.h" // 直接在 include/下面的头文件
#include "deeper/bar.h" // include/下的 deeper/bar.h
```

都可以找到！

因为：

- 编译器会把 ${CMAKE_CURRENT_SOURCE_DIR}/include 当作起点
- 之后你的 #include 路径要从 include/ 这一层写起。

小总结一句话
• 不会自动去子目录递归查找！
• 只把 include/ 作为根目录，你自己在代码里要正确写路径。

比如：

```c++
#include "foo.h" ✅
#include "deeper/bar.h" ✅
#include "bar.h" ❌ （因为没有直接在 include/下）
```

### target_link_libraries(targetName [PUBLIC|PRIVATE|INTERFACE] libraries…)

target_link_libraries 是给一个目标（target）链接上其他的库或者目标，
告诉编译器/链接器：“编译我的时候，需要把这些库也一起链接进来！”

- targetName：你的可执行程序或者库，比如 my_app
- RIVATE、PUBLIC、INTERFACE：控制链接关系传播（跟 target_include_directories 的传播规则一样）
  • PRIVATE：自己用就行（正常情况）
  • PUBLIC：别人用我时，也得顺便链接（比如你封装了别人的库）
  • INTERFACE：我不用，别人用的时候要！（头文件库）
- libraries…：要链接的库，可以是
  - 另一个 target（比如 mylib）
  - 系统库（比如 pthread）
  - 预编译好的第三方库（比如 Qt6::Quick）

举个简单例子

可执行程序链接自己写的库

```code
add_library(mylib STATIC foo.cpp)
add_executable(myapp main.cpp)

target_link_libraries(myapp PRIVATE mylib)
```

myapp 在编译的时候会自动把 mylib 静态库链接进来！

再来个实际点的例子:

比如你要用 Qt6 写程序：

```code
find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets)

add_executable(myapp main.cpp)

target_link_libraries(myapp
   PRIVATE
   Qt6::Core
   Qt6::Gui
   Qt6::Widgets
)
```

myapp 会链接 Qt 的 Core、Gui、Widgets 模块。

## 查找库和包

### find_package(PackageName [REQUIRED] [VERSION x.y])

find_package 是 CMake 用来“查找外部库”的命令。比如 Qt、OpenCV、Boost 这种大型第三方库，都不是你自己写的，得用 find_package 把它们找出来，才能在你的项目里用。

基本语法：

find_package(PackageName [Version] [REQUIRED] [COMPONENTS components...])

参数说明

- PackageName
  要查找的库（package）名称，比如 Qt6、OpenCV、Boost。
- Version（可选）
  要求的最低版本号，比如 6.6.0。如果不写，表示接受任何版本。
- REQUIRED（可选）
  表示必须找到。找不到的话，CMake 会停止并报错。
- COMPONENTS（可选）
  指定需要的子模块（组件）。如果不写，通常默认加载整个包。

示例

```code
find_package(Qt6 6.6 REQUIRED COMPONENTS Core Widgets Gui)
```

意思是：

- 找名叫 Qt6 的包
- 需要版本 ≥ 6.6
- 必须找到（找不到就报错）
- 只需要 Core、Widgets、Gui 这三个模块，不需要其他模块

find_package 到底查什么？怎么查？

CMake 有一套搜索规则，大概是这样：

查找顺序说明

- 查找 CMake 自带的 模块（/usr/share/cmake/Modules）
- 查找库自带的 Config 文件（比如 Qt6Config.cmake）
- 用 CMAKE_PREFIX_PATH 指定额外搜索路径

如果找到了，比如 Qt6Config.cmake，CMake 就会加载它。
而这个文件里面就会告诉 CMake 怎么设置 target，比如：

- 创建 Qt6::Core
- 创建 Qt6::Widgets
- 指明头文件在哪
- 指明链接库在哪
- 指明编译器宏怎么设置

举个例子（找 Qt6）

当你写：

```code
find_package(Qt6 6.6 REQUIRED COMPONENTS Core Widgets Gui)
```

CMake 会按这个顺序尝试找 Qt6：

- CMAKE_PREFIX_PATH
  最主要的变量！你可以手动告诉 CMake 去哪里找。
- CMAKE_FIND_ROOT_PATH
  交叉编译时常用。一般情况下用不到。
- 系统默认搜索路径
  比如 /usr/lib/cmake/, /usr/local/lib/cmake/，Windows 上是 C:/Program Files/。
- 系统环境变量
  比如 CMAKE_MODULE_PATH、PATH、CMAKE_PREFIX_PATH 中的值。

假设你在 Linux 装了 Qt6，安装路径是 /opt/Qt/6.6.0/gcc_64 在这个目录下，有：

```code
/opt/Qt/6.6.0/gcc_64/lib/cmake/Qt6/Qt6Config.cmake
```

所以如果你写：

find_package(Qt6 REQUIRED COMPONENTS Core Widgets)

CMake 内部就会找：
`/opt/Qt/6.6.0/gcc_64/lib/cmake/Qt6/Qt6Config.cmake`

找到以后，加载，创建好 target，就可以用了！

### find_library(varName name PATHS paths…)

find_library 语法

find_library(variable_name library_name [PATHS path_list] [REQUIRED] [NO_DEFAULT_PATH])

参数说明

- variable_name
  变量名，保存找到的库路径到这个变量里。
- library_name
  要找的库的名字，比如 mylib（CMake 会自动加 .so、.a、.dll、.lib 这些后缀去找）。
- PATHS（可选）
  指定额外的搜索路径。
- REQUIRED（可选）
  必须找到，否则 CMake 直接报错。
- NO_DEFAULT_PATH（可选）
  不用系统默认路径，只在你指定的路径里找。

举个简单例子

find_library(MYLIB_PATH mylib PATHS /usr/local/mylib/lib REQUIRED)

含义是：

- 去 /usr/local/mylib/lib 里找叫 mylib 的库
- 如果找到了，保存完整路径到变量 MYLIB_PATH
- 如果找不到，直接停止 cmake（因为加了 REQUIRED）

找到之后你可以在后面使用这个变量：

target_link_libraries(myapp PRIVATE ${MYLIB_PATH})

### find_path(varName name PATHS paths…)

find_path 是 CMake 中用于查找包含特定文件（通常是头文件）的目录的命令。它的作用是帮助你找到某个文件所在的目录，通常用于查找库的头文件路径。

语法：

find_path(variable_name file_name [PATHS path_list] [REQUIRED] [NO_DEFAULT_PATH] [DOC "documentation string"])

参数说明：

- variable_name

  存储找到的目录路径的变量名。

- file_name

  需要查找的文件名，通常是头文件的文件名（例如 mylib.h）。

- PATHS（可选）
  指定额外的查找路径，可以是多个路径。
- REQUIRED（可选）
  如果指定此选项，找不到文件时 CMake 会报错。
- NO_DEFAULT_PATH（可选）
  如果指定此选项，CMake 只会在你提供的路径列表中查找，而不会在系统默认路径中查找。
- DOC（可选）
  提供一个文档字符串，描述该查找的目的，通常用于生成 CMake 文档时显示。

示例：

find_path(MYLIB_INCLUDE_DIR mylib.h PATHS /usr/local/include REQUIRED)

- 这条命令会查找名为 mylib.h 的头文件，优先在 /usr/local/include 目录下查找。
- 如果找到文件，它会将包含该文件的目录路径存储在 MYLIB_INCLUDE_DIR 变量中。
- 如果找不到文件，REQUIRED 会导致 CMake 停止并报错。

典型使用场景：
• 查找库的头文件目录（例如 find_path 查找 mylib.h）。
• 如果头文件目录在默认路径外，你可以通过 PATHS 指定额外的查找路径。

## 设置编译选项

### set(VAR value)

在 CMake 中，set(VAR value) 是用来定义并赋值给变量 VAR 的命令。它可以用来创建、修改、删除变量，并为其赋一个值。

语法：

set(VAR value)

参数说明：

- VAR：变量名，可以是任意有效的变量名称。
- value：要赋给变量的值。可以是一个字符串、数字、列表、路径等。

功能：
• 通过 set(VAR value)，你可以创建一个新的变量 VAR，并为其赋值为 value。
• 如果变量 VAR 已经存在，使用 set 会修改该变量的值。

示例：

```code
set(MY_VARIABLE "Hello, CMake!")
```

这行命令会创建一个名为 MY_VARIABLE 的变量，并将其值设置为 "Hello, CMake!"。

设置预定义变量
在 CMake 中，设置预定义变量的方式和设置普通变量相同。预定义变量是 CMake 本身定义的，用来控制项目构建的各种行为，通常不需要开发者手动设置。然而，如果你想修改或设置某些预定义变量，可以像普通变量一样使用 set() 命令。

```code
#设置 CMake 使用 C++17 标准来编译项目。
set(CMAKE_CXX_STANDARD 17)
#设置如果编译器不支持所指定的 C++ 标准时，CMake 会报错。
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

### target_compile_definitions(targetName [PUBLIC|PRIVATE] definitions…)

• 设置编译器宏定义。
• 例：target_compile_definitions(MyApp PRIVATE USE_MY_FEATURE)

### target_compile_options(targetName [PUBLIC|PRIVATE] options…)

在 CMake 中，target_compile_definitions 命令用于为特定目标（target）添加预处理器宏定义（编译时的定义）。这些宏定义通常用于在代码中控制条件编译。

语法：

target_compile_definitions(target_name
[PUBLIC|PRIVATE|INTERFACE]
<definition>...
)

参数说明：

- target_name：目标的名称（例如可执行文件、库等）。
- PUBLIC、PRIVATE、INTERFACE：这些是作用域修饰符，控制宏定义对依赖目标的传播方式：
- PRIVATE：宏定义仅对目标本身有效。
- PUBLIC：宏定义对目标本身和依赖此目标的其他目标有效。
- INTERFACE：宏定义仅对依赖此目标的其他目标有效，而对目标本身无效。
- <definition>：要定义的预处理宏（例如 MY_MACRO=1）。可以定义多个宏，多个宏之间用空格分隔。

功能：

target_compile_definitions 命令主要用于将特定的宏定义传递给编译器。这些宏通常用来在源代码中控制条件编译。例如，你可以根据宏定义启用或禁用某些功能。

示例： 为目标添加宏定义：
假设你想为目标 myapp 添加一个宏定义 DEBUG_MODE：

target_compile_definitions(myapp PRIVATE DEBUG_MODE)

这会在编译 myapp 时定义 DEBUG_MODE，你可以在代码中使用 #ifdef DEBUG_MODE 来进行条件编译。

### target_compile_options(targetName [PUBLIC|PRIVATE] options…)

• 添加编译选项。
• 例：target_compile_options(MyApp PRIVATE -Wall -Wextra)

## 安装和导出

### install(TARGETS targetName DESTINATION path)

在 CMake 中，install(TARGETS ...) 命令用于指定将目标（如可执行文件或库）安装到特定位置。此命令帮助你在构建完成后将目标安装到指定的目录，通常是在项目的安装步骤中使用。

语法：

install(TARGETS target1 target2 ...
[EXPORT <export-name>]
[RUNTIME DESTINATION <dir>]
[BUNDLE DESTINATION <dir>]
[LIBRARY DESTINATION <dir>]
[ARCHIVE DESTINATION <dir>]
[INCLUDES DESTINATION <dir>]
[PERMISSIONS permissions]
[COMPONENT <component>]
[OPTIONAL]
[NAMELINK_ONLY]
[NAMELINK_COMPONENT <component>]
)

参数说明：

- TARGETS targetName：指定一个或多个目标，可以是可执行文件、库等。
- DESTINATION path：目标文件将要安装的目录路径。
- BUNDLE DESTINATION .：
  这个选项用于指定 macOS 或 iOS 应用程序的包（bundle）文件安装的位置。通过 DESTINATION .，目标包将被安装到当前目录。
- EXPORT <export-name>：将目标的安装信息导出为一个 CMake 配置文件，以便其他项目使用 find_package 查找和使用此目标。
- RUNTIME DESTINATION：指定可执行文件（如 .exe）安装的位置，默认为 bin/ 目录。
- LIBRARY DESTINATION：指定动态库（.so 或 .dylib 等）安装的位置，默认为 lib/ 目录。
- ARCHIVE DESTINATION：指定静态库（.a 或 .lib 等）安装的位置，默认为 lib/ 目录。
- INCLUDES DESTINATION：指定头文件的安装位置，默认为 include/ 目录。
- PERMISSIONS：设置安装文件的权限。
- COMPONENT：将文件分配到一个特定的组件，通常用于多个组件的安装过程。
- OPTIONAL：如果目标没有被构建，安装会跳过，而不会报错。
- NAMELINK_ONLY：只安装符号链接，而不是实际的库文件。
- NAMELINK_COMPONENT：指定符号链接的组件。

示例： 1. 将可执行文件安装到 bin/ 目录：

install(TARGETS myapp DESTINATION bin)

这会将 myapp 可执行文件安装到 bin/ 目录。

### install(FILES filePath DESTINATION path)

install(FILES filePath DESTINATION path) 是 CMake 中用于安装单个文件的命令。它的作用是将指定的文件从构建目录复制到指定的目标安装路径。

参数说明：
• FILES filePath：
• filePath 是你希望安装的文件路径。可以是一个或多个文件的路径。如果有多个文件，可以用空格分隔文件路径。
• 该路径是相对于构建目录的，或者你也可以提供绝对路径。
• DESTINATION path：
• path 是你希望将文件安装到的目标目录路径。可以是一个相对路径或绝对路径。
• 这个路径通常是安装目录的一部分，CMake 会将文件复制到该目录中。

例子： 1. 安装一个文件：

install(FILES ${CMAKE_SOURCE_DIR}/config/config.txt DESTINATION ${CMAKE_INSTALL_PREFIX}/config)

这会将 config.txt 文件从源代码目录的 config 子目录中安装到指定的安装目录下的 config 子目录中。CMAKE_INSTALL_PREFIX 是 CMake 默认的安装前缀，通常是 /usr/local/ 或自定义的路径。

总结：

install(FILES ...) 用于安装单个或多个文件，它将文件从构建目录复制到安装目录。这个命令非常适合用于安装配置文件、资源文件、许可证文件等。

## 条件判断

### if (condition) … elseif (…) … else () … endif()

• 条件语句。
• 例：

```code
if (WIN32)
message("Building on Windows")
elseif (UNIX)
message("Building on Linux")
endif()
```

### option(OptionName “description” [ON|OFF])

• 创建可配置的开关。
• 例：option(USE_FEATURE "Use special feature" ON)

## 子项目和模块

### add_subdirectory(path)

• 添加子目录并编译子项目。
• 例：add_subdirectory(src)（src 里面有自己的 CMakeLists.txt）

### include(path/to/file.cmake)

• 包含其他 CMake 脚本。

## 打印信息

• message([STATUS|WARNING|FATAL_ERROR] “text”)
• 打印信息到 CMake 输出。
• 例：message(STATUS "Compiling project...")

## Qt 相关

### set

```code
set ( CMAKE_AUTOMOC ON )
set ( CMAKE_AUTORCC ON )
set ( CMAKE_AUTOUIC ON )
```

指令作用

- CMAKE_AUTOMOC
  自动处理 .cpp 文件里 Q_OBJECT 宏，生成 moc 文件
- CMAKE_AUTORCC
  自动处理 .qrc 文件（资源文件），生成资源代码
- CMAKE_AUTOUIC
  自动处理 .ui 文件（界面文件），生成对应的头文件

具体来说：

- CMAKE_AUTOMOC = Auto Meta-Object Compiler
  - 如果一个 .cpp 里面有 Q_OBJECT 宏（比如信号槽），Qt 需要生成一个对应的 moc_XXX.cpp 文件。
  - 开启这个选项后，CMake 自动识别并生成，你不用自己手动添加 moc 文件。
- CMAKE_AUTORCC = Auto Resource Compiler
  - 你的 .qrc 文件（比如资源图片、图标）需要转换成 C++ 代码。
  - 开了这个后，CMake 自动找 .qrc 并编译进去。
- CMAKE_AUTOUIC = Auto User Interface Compiler
  - 传统 Qt Designer 画 .ui 文件（比如窗口界面），也需要生成 .h 文件。
  - 开启后，CMake 自动处理 .ui 文件，不用你手动调用 uic。

开这三行，就可以让 CMake 自动识别并处理 Qt 特有的文件（moc、qrc、ui），省去你手动命令行生成的麻烦。

那 qt_standard_project_setup() 还需要这三行吗？

理论上不需要了。
因为 qt_standard_project_setup() 已经内部帮你默认打开了这三个功能。
但是有时也会遇到 CMAKE_AUTORCC 开启不成功。

## 例子

### 生成 pyd 文件 CMakeLists.txt

```code

cmake_minimum_required(VERSION 3.16)

project(QComposer VERSION 0.1 LANGUAGES CXX)

# 设置C++标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 定义项目根目录
set(PROJECT_ROOT_DIR ${CMAKE_CURRENT_LIST_DIR}/..)

# 配置Conda环境的CMAKE_PREFIX_PATH
if(DEFINED ENV{CONDA_PREFIX})
    list(PREPEND CMAKE_PREFIX_PATH "$ENV{CONDA_PREFIX}")
endif()

# 查找依赖
find_package(Python3 REQUIRED COMPONENTS Interpreter Development.Module)
find_package(Qt6 REQUIRED COMPONENTS Quick QuickControls2)
find_package(pybind11 REQUIRED)

# 设置Qt标准项目设置
qt_standard_project_setup(REQUIRES 6.5)

# 收集源码和资源
file(GLOB_RECURSE SOURCES
    ${PROJECT_ROOT_DIR}/src/*.cpp
)

qt_add_resources(RESOURCES
    ${PROJECT_ROOT_DIR}/src/resources.qrc
)

# 定义pybind11模块
pybind11_add_module(QComposer
    ${PROJECT_ROOT_DIR}/python-module/binding.cpp
    ${SOURCES}
    ${RESOURCES}
)

# 包含目录
target_include_directories(QComposer PRIVATE
    ${PROJECT_ROOT_DIR}
)

# 链接Qt库
target_link_libraries(QComposer
    PRIVATE
        Qt6::Quick
        Qt6::Gui
        Qt6::QuickControls2
)

# 设置生成的pyd文件属性
set_target_properties(QComposer PROPERTIES
    OUTPUT_NAME "QComposer"  # 输出文件名
    PREFIX ""                # 去掉lib前缀
    SUFFIX ".pyd"            # Windows上的Python模块后缀
    LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}  # 输出到项目根目录
)
```

### 生成可执行文件 CMakeLists.txt

```code
# 设置最低CMake版本
cmake_minimum_required(VERSION 3.16)

# 定义项目名称和版本
project(QComposer VERSION 0.1 LANGUAGES CXX)

# 设置C++标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找Qt6所需模块
find_package(Qt6 REQUIRED COMPONENTS Quick QuickControls2)

# 设置Qt标准项目配置（启用一些默认配置，如自动MOC、UIC、RCC等）
qt_standard_project_setup(REQUIRES 6.5)

# 开启自动处理.qrc资源文件
set(CMAKE_AUTORCC ON)

# 收集源码和头文件
file(GLOB_RECURSE SOURCES
    src/*.cpp
    src/*.h
)

# 添加可执行程序
qt_add_executable(QComposer
    src/app/main.cpp                     # 主入口文件
    ${CMAKE_SOURCE_DIR}/Resources/icon.png  # 应用图标
)

# 添加QML模块
qt_add_qml_module(QComposer
    URI QComposer
    VERSION 1.0
    SOURCES ${SOURCES}                    # 所有源码
    RESOURCES
        src/resources.qrc                 # QML资源文件
)

# 设置可执行文件的属性
set_target_properties(QComposer PROPERTIES
    MACOSX_BUNDLE TRUE                                # Mac上打包为.app格式
    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}   # 设置bundle版本
    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
    MACOSX_BUNDLE_ICON_FILE icon.png                  # 设置Mac应用图标
    WIN32_EXECUTABLE TRUE                             # Windows上隐藏命令行窗口
)

# 设置图标文件在Mac包中的位置
set_source_files_properties(${CMAKE_SOURCE_DIR}/Resources/icon.png PROPERTIES
    MACOSX_PACKAGE_LOCATION "Resources"
)

# 链接Qt库
target_link_libraries(QComposer
    PRIVATE Qt6::Quick Qt6::Gui Qt6::QuickControls2
)

# 安装规则（打包时放到当前目录）
install(TARGETS QComposer
    BUNDLE DESTINATION .
)

```
