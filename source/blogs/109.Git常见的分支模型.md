# Git 常见的分支模型

## Trunk-Based Development

Trunk-Based Development 是一种极简的分支模型，其核心理念是**所有开发者**在**同一个主干分支**（通常称为 trunk、main 或 master）上进行开发，尽量**避免使用长期存在的**分支。
![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/Trunk-Based-Development.webp)

### 核心原则

- 直接提交到主干（master）

  所有开发者直接在主干分支上开发新功能或修复问题，而非长期保留特性分支。主干始终保持在一个可以**随时发布**的状态。
  目的：避免分支与主干偏离过久，减少合并冲突和集成风险。

- 小批量、高频次提交

  通过小粒度的代码变更（如单次提交仅实现一个功能点），确保每次变更易于审查和回滚。
  目的：降低代码冲突概率，提升持续集成的效率。

- 持续集成（CI）

  每次提交到主干后，立即触发自动化构建和测试流程（单元测试、集成测试等）。持续集成是主干开发成功的**关键实践之一**。

  为什么主干开发需要持续集成？

  - 主干始终可发布

    主干开发的核心原则是主干分支始终保持可发布状态。为了实现这一点，每次代码变更都必须经过严格的测试和验证，而这正是持续集成的核心功能。

  - 频繁集成

    主干开发鼓励开发者频繁地将代码合并到主干（通常每天至少一次）。如果没有持续集成，频繁的代码变更可能会导致主干不稳定，甚至引入严重的缺陷。

  - 快速反馈

    持续集成系统会在每次代码提交后自动运行测试（单元测试、集成测试等），并快速反馈结果。这有助于开发者尽早发现和修复问题，避免问题累积。

  - 减少合并冲突

    主干开发强调短生命周期分支和频繁合并，持续集成可以帮助检测合并冲突和集成问题，确保代码的一致性。

  - 自动化部署

    持续集成通常与持续交付（Continuous Delivery, CD）结合，实现自动化部署。这使得主干上的代码可以随时部署到生产环境，符合主干开发的目标。

- 特性开关（Feature Toggles）

  通过配置开关控制未完成功能的显隐，允许开发者将部分完成的代码提交到主干，但保持功能对用户不可见。
  目的：避免因长期分支导致的集成延迟，同时支持渐进式功能发布。

- 避免长期分支

  严格限制特性分支的生命周期（如不超过 1 天），或仅用于短期实验。

### 工作流程

- 日常开发

  - 所有开发者直接向主干分支提交代码。
  - 如果开发某个较复杂的功能，可基于主干创建一个**短生命周期**的临时分支，开发完成后**立即**合并回主干。
    虽然 Trunk-Based Development 强调所有开发都在主干上进行，但在实际使用中，仍然可以有一些辅助分支来支持开发流程。这些分支通常是短生命周期的，并且会尽快合并回主干，以避免长期分支带来的复杂性。

  - 功能标记（Feature Flags）

    对于那些尚未完全开发好的功能，可以使用功能开关来控制其在生产环境中的可见性，保证主干代码始终保持高质量和稳定性。
    假设我们正在开发一个新的 Dark Mode（暗黑模式），但这个功能尚未完全准备好，不希望影响所有用户，我们可以使用功能标记来控制它。
    代码示例：

    ```js
    const featureFlags = {
      darkMode: false, // 当前关闭暗黑模式
    };

    function App() {
      return (
        <div
          style={{
            background: featureFlags.darkMode ? "#333" : "#fff",
            color: featureFlags.darkMode ? "#fff" : "#000",
          }}
        >
          <h1>Hello, World!</h1>
          {featureFlags.darkMode && <p>暗黑模式已启用</p>}
        </div>
      );
    }

    export default App;
    ```

- 自动化测试与持续集成

  每次提交都会**触发自动化构建和测试**，确保主干的稳定性，并能迅速发现并修复问题。

- 发布和部署

  由于主干始终处于可发布状态，所以可以实现持续交付（CD）或持续部署，随时将最新的、经过测试的代码部署到生产环境中。

### 优势

- 减少集成冲突：频繁的提交和合并能大大降低长期分支合并时遇到的大量冲突问题。
- 保持主干稳定：持续集成和自动化测试保证了主干的高质量和稳定性，降低了发布风险。
- 加快反馈周期：即时的自动化测试反馈帮助开发者迅速发现和解决问题，提升开发效率。
- 简化分支管理：相比 Gitflow 或 Feature Branch 工作流，分支策略更简单，降低了分支管理的复杂性。

### 挑战与注意事项

- 开发文化和纪律要求高：所有开发者必须确保每次提交都足够小、稳定，并遵循严格的代码审核和测试流程，否则可能破坏主干的稳定性。
- 依赖完善的自动化测试和 CI/CD 系统：为了快速发现并修复问题，团队需要建立健全的自动化测试体系和持续集成流程。
- 功能切换管理：使用功能标记（Feature Flags）需要额外的管理和技术支持，防止因切换问题影响代码质量。

### 适用场景

- 持续交付和部署：适合那些需要频繁发布、对发布流程有高要求的项目。
- 小型或中型团队：团队规模较小，沟通协作顺畅，能迅速响应问题。
- 快速迭代的项目：需要快速整合新功能并迅速部署到生产环境的项目。

## Git Flow

GitFlow 由 Vincent Driessen 在 2010 年提出。强调严格的分支结构和阶段化的开发流程，适合需要长期维护多个版本的传统软件项目（如客户端软件或固定版本发布的系统）。

GitFlow 的核心思想是通过明确的分支模型来管理开发、发布和修复流程。

![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/git-flow.webp)

### 核心分支

- 主分支 (master)

  - 存储生产环境中的稳定版本。每次发布时，都会将待发布的代码合并到 master 分支。
  - 始终包含可部署到生产环境的代码版本，通常会打上 Git 标签标识每次发布的版本。

- 开发分支 (develop)

  - 该分支用于存放最新的开发代码，是团队开发的主要工作分支。
  - 所有的功能开发和 bug 修复最终都应合并到 develop。

- 功能分支 (feature/)

  - 功能分支用于开发新的功能，每个功能应该有一个独立的分支。
  - 功能分支从 develop 分支创建，开发完成后合并回 develop。
  - 命名约定： feature/<功能名>，例如 feature/user-authentication。

- 发布分支 (release/)

  - 当 develop 分支上的功能开发完成且准备发布时，会创建一个发布分支。
  - 在 release 分支上进行最后的调试和修复，确保代码可以部署到生产环境。
  - 命名约定： release/x.y.z，例如 release/1.0.0

- 修复分支 (hotfix/)

  - 用于快速修复生产环境中的紧急问题。
  - 修复完成后，hotfix 分支合并回 master 和 develop，确保两者都保持最新。
  - 命名约定：hotfix/<修复描述>，例如 hotfix/fix-login-bug。

### 工作流程

- 开发新功能

  从 develop 分支创建一个新的 feature 分支：

  ```sh
  git checkout develop
  git checkout -b feature/my-feature
  ```

  开发完成后，合并回 develop 分支:

  ```sh
  git merge feature/my-feature --no-f

  git branch -d feature/my-feature
  ```

- 创建 release 分支

  当开发到一定阶段后，准备发布时，创建一个 release 分支:

  ```sh
  git checkout develop
  git checkout -b release/1.0.0
  ```

  在 release 分支上进行必要的 bug 修复、版本号更新、文档修改等准备工作（这里严格禁止增加大的新 feature）。

- 测试 release 分支

  - 运行自动化测试（单元测试、集成测试等）。
  - 进行手动测试，确保功能符合需求。
  - 如果发现 bug 或问题，直接在 release 分支上进行修复。
  - 重复测试，直到满足需求。

- 发布版本

  当 release 分支经过充分测试并准备好发布时，将其合并到 master 分支，并打上版本标签。

  ```sh
  #合并到 Master：
  git checkout master
  git merge release/v1.0.0 --no-f

  #打标签：
  git tag -a v1.0.0 -m "Release v1.0.0"
  git push origin v1.0.0
  ```

  为了确保 develop 分支包含 release 分支中的所有修复，需要将 release 分支合并回 develop 分支，合并后可以删除 release 分支：

  ```sh
  git checkout develop
  git merge release/v1.0.0 --no-f

  git branch -d release/1.0.0
  ```

- 热修复

  当生产环境出现紧急问题时，需要从 master 分支创建一个 hotfix 分支，通常 hotfix 分支应该从需要修复的 tag（如 1.0.0）创建：

  ```sh
  #从标签v1.0.0创建分支hotfix/1.0.1， 1.0.1 表示是修复后的版本号
  git checkout -b hotfix/1.0.1 v1.0.0
  ```

  在 hotfix 分支上修复问题，修复完成后，合并到 master 和 develop，合并完成后可以删除对应的 hotfix 分支：

  ```sh
  git checkout master
  git merge hotfix/1.0.1 --no-f
  git tag -a 1.0.1 -m "Fix login bug"

  git checkout develop
  git merge hotfix/1.0.1 --no-f

  git branch -d hotfix/1.0.1
  ```

## GitHub Flow 工作流

GitHub Flow 是一种简单、高效的工作流，广泛用于团队协作开发，特别是在需要快速迭代和频繁部署的环境中。它的核心思想是通过简化分支管理和代码合并流程，使得团队能够快速、平稳地发布新功能、修复 bug，并保持代码的高质量。

![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/GitHub-Flow.webp)

### 核心观点

- 主分支（master）是始终可部署的

  - master 分支始终保持稳定，经过测试，且可以随时部署到生产环境。
  - 所有的代码更改最终都会合并到 master 分支中。

- 每个功能或修复都应该通过一个分支来实现

  - 开发人员从 master 分支创建一个新的分支来进行特性开发、bug 修复等。
  - 每个分支都应专注于一个任务或特性，避免混乱。

- 频繁提交

  开发人员应该频繁地将更改推送到自己的远程分支，以便进行协作和持续集成。

- 使用 Pull Request（PR）进行代码审查

  完成功能或修复后，开发人员提交一个 Pull Request，邀请团队成员进行代码审查。

- 自动化测试

  在 PR 被创建后，自动化测试应在 CI/CD 系统中运行，确保提交的代码不会破坏现有功能。

### 工作流程

- 创建分支

  从 master 分支创建一个短生命周期的 feature 分支。

- 开发与提交

  在 feature 分支上进行开发，提交改动，完成后将代码推送到远程仓库。

- 发起 Pull Request

  feature 代码推送到远程仓库后，可以通过 GitHub 查看 feature 分支并通过 [Pull Request](https://juejin.cn/post/6844903821521469448) 请求代码合并。

- 代码审核与自动化测试

  - 一旦 PR 被创建，通常会触发 自动化测试
  - 测试结果会反馈回 PR 页面，通常会显示为绿色的 “Passed” 或红色的 “Failed”。
  - 测试结果出来后，团队成员会进行 代码评审，检查代码的质量、可读性、逻辑是否正确等。
  - 如果代码评审没有通过，或者测试没有通过，开发者根据反馈进行修改。
  - 修改后的代码会再次触发自动化测试，直到测试通过。
  - 代码评审通过并且测试通过后，PR 就可以合并到 master 分支。

- 部署

  合并后自动或手动部署到生产环境。

### 优点

以下是 GitHub Flow 的一些主要优势：

- 简单的分支管理

  GitHub Flow 强调从 master 分支创建功能分支，而不需要过多的分支策略（如 Git Flow）。开发完成后提交 Pull Request（PR），经过代码审查后合并到主分支即可。
  这种简化的流程使得开发人员可以专注于功能开发，而无需担心复杂的分支和版本管理。

- 提高代码质量

  - 代码审查：GitHub Flow 强调通过 PR 进行代码审查。团队成员可以在合并之前对代码进行全面检查，提出优化建议或发现潜在的 bug。这不仅能提高代码质量，还能促进团队成员之间的知识共享。
  - 自动化测试：通过 CI 流程，可以在每次提交时 PR 时自动运行单元测试和集成测试，确保每次合并到 master 分支的代码都是经过验证的。

- 适合持续部署

  - 快速发布：GitHub Flow 推崇**持续交付**，意味着 master 分支**始终保持在一个稳定**的状态，随时可以部署到生产环境。每次合并的功能都可以立即进行部署，从而实现快速的产品迭代和交付。
  - 频繁发布：开发人员通过 GitHub Flow 可以**频繁地提交小的**、**增量性的**功能，更容易控制代码的质量和稳定性。小范围的更改也减少了部署风险。

### 应用场景

- 持续集成和持续部署（CI/CD）

  当项目要求频繁部署新版本，GitHub Flow 是理想选择。通过每个功能或修复一个独立的分支，并在完成后进行 pull request（PR），可以确保每次提交都经过审查和测试。

- 快速迭代的项目

  对于需要频繁更新和快速开发的产品，GitHub Flow 提供了高效的流程。每个开发人员或团队可以独立地工作在不同的功能分支上，确保主分支始终处于可部署状态。

- 开源项目

  GitHub Flow 非常适合开源项目，开发者可以在自己的分支上提交功能或修复，然后通过 pull request 向主分支提交，经过审查后再合并。这种方式有助于管理社区贡献。

- 小型团队

  GitHub Flow 的规则简单，不需要复杂的分支管理策略，易于理解和实施，适合资源有限的小型团队。

## GitLab Flow

GitLab Flow 是 GitLab 提出的一种工作流程，其核心在于将 Git 分支管理与持续集成/持续交付（CI/CD）紧密结合，从而实现更高效、更可靠的代码开发、测试和部署。

![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/gitlab-workflow.webp)

### 核心观点

- CI/CD 集成

  GitLab Flow 强调与 GitLab 的 CI/CD 系统深度集成。在 GitLab Flow 中，开发人员在代码提交、合并请求（Merge Request）等操作时，自动触发构建、测试和部署等流水线。这种自动化集成确保了每次提交或合并的代码都经过验证，减少了手动操作和错误的可能。

- 灵活的分支策略

  GitLab Flow 提供了灵活的分支策略，可以适应不同规模的团队和项目。其并不强制采用固定的分支策略，而是支持不同的工作流，如：

  - 基于功能的工作流：类似 GitHub Flow，团队通过短期功能分支和主分支进行迭代开发。每个功能分支在完成后都被合并回主分支。
  - 支持 GitFlow 风格的复杂工作流：在大型团队中，GitLab Flow 允许使用更多的分支（如 develop、release 和 hotfix），适用于多版本并行开发和管理。

- Merge Requests（同 PR）进行代码审查

  GitLab Flow 强调通过 Merge Request 进行代码审查和合并。团队成员可以在合并代码之前对其进行讨论、评审和测试，从而确保代码质量和协作效率。每次提交到主分支时，都会自动触发测试，确保代码的稳定性。

- 支持多环境和多版本管理

  GitLab Flow 允许在多个环境（开发、测试、预生产、生产）中同时进行开发和部署管理。通过 CI/CD 流水线，团队可以确保在不同的环境中保持一致性，并且在不同版本间进行顺畅的切换和管理。

GitLab Flow 有几个不同的变体，以下是最常见的两种：

### 基于环境的 GitLab Flow

这种变体强调与不同的部署环境（例如开发、测试、生产等）紧密集成。每个环境通常都有自己的分支，并且分支与 GitLab CI/CD 管道的部署流程相对应。
GitLab Flow 的最大原则叫做 upstream first，中文译作“上游优先”：即只存在一个主分支 master，它是所有其他分支的 upstream，只有上游分支采纳的代码变化，才能应用到其他分支。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到 master，确认没有问题，再 cherry-pick 到 pre-production，这一步也没有问题，才进入 production。

![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/gitlab-flow-env.webp)

#### 工作流程

- 开发新功能：

  从 master 分支创建功能分支（如 feature/login）。在功能分支上开发代码。

- 合并功能分支：

  - 开发完成后，创建合并请求（Merge Request），将功能分支合并到 master。

  - 在 master 分支更新后，下一步是将这些更改推送到 pre-production 环境分支。这是一个接近生产环境的验证阶段，通常用于进行更大范围的集成测试和功能验证。

  - 从 master 分支合并或 cherry-pick 变更到 pre-production 分支，并在此环境中进行验证，确保代码在预发布环境中正常运行。

- 合并到 production（生产分支）
  - 当 pre-production 环境验证通过之后，代码就可以最终推送到生产环境。
  - 将 pre-production 中经过验证的代码合并到 production 分支，这个步骤通常会触发生产环境的部署。
  - 生产环境中的代码通常是最稳定的，经过了多次验证。

### 基于发布的 GitLab Flow

基于发布的 GitLab Flow 是一种专门为需要版本发布的项目设计的工作流。它在标准 GitLab Flow 的基础上，增加了对版本分支的支持，使得团队可以更好地管理长期支持版本（如 LTS）和短期版本（如功能更新）。这种工作流非常适合需要定期发布软件版本的项目，例如开源软件、企业级应用等。
对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从 master 分支拉出一个分支，比如 2-3-stable、2-4-stable 等等。
![](https://blog-bed.oss-cn-beijing.aliyuncs.com/109.Git%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/gitlab-flow-release.png)

这些稳定的分支创建后，只有严重的 bug 才修复它，修复时先合并到 master，再 cherry-pick 到对应的稳定分支。

## 总结

|              | **Trunk-Based Development**                       | **Git Flow**                                                            | **GitHub Flow**                            | **GitLab Flow**                              |
| ------------ | ------------------------------------------------- | ----------------------------------------------------------------------- | ------------------------------------------ | -------------------------------------------- |
| **分支策略** | 直接推送到 **`master`**，几乎不使用长期存在的分支 | **多分支**模型：`master`、`develop`<br>、`feature`、`release`、`hotfix` | 特性分支开发，合并到 `master` 后部署       | 特性分支开发，通过环境分支逐步推进           |
| **发布频率** | 持续发布（主干随时可部署）                        | 定期发布（通过 `release` 分支）                                         | 持续交付（合并即部署）                     | 按环境发布（分阶段推进）                     |
| **适用场景** | 高频迭代、强 CI/CD 团队（如互联网应用）           | 传统软件（需版本控制，如客户端应用）                                    | 开源项目、小型敏捷团队                     | 企业级项目（需多环境测试和部署）             |
| **复杂度**   | 低                                                | 高（分支多，流程严格）                                                  | 中                                         | 中（需管理环境分支）                         |
| **优点**     | - 快速集成<br>- 减少合并冲突                      | - 版本管理清晰<br>- 适合复杂项目                                        | - 简单灵活<br>- 适合协作开发               | - 环境隔离<br>- 支持复杂部署流程             |
| **缺点**     | - 依赖严格测试和 CI/CD<br>- 不适合长期特性开发    | - 分支管理繁琐<br>- 学习成本高                                          | - 不适合多环境管理<br>- 不适合版本并行管理 | - 环境分支可能冗余<br>- 配置和维护复杂度较高 |

- Trunk-Based：极简主义，适合追求速度和自动化的小型团队。

- Git Flow：适合需要严格版本管理的传统软件（如客户端应用）。

- GitHub Flow：轻量级，适合开源协作和快速交付的 Web 服务。

- GitLab Flow：平衡灵活性与流程，适合企业级多环境部署。

总的来说还是得根据团队规模、发布频率和项目复杂度选择合适的策略！但并不需要限制在某一种策略，可以结合不同流的优势综合处理。
