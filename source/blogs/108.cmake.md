# CMake

CMake 是一个**跨平台**的开源工具，用于管理软件项目的构建过程。它通过配置文件（通常是 CMakeLists.txt）**生成适合目标平台**的构建系统文件(CMake 本身不能直接构建项目，而是生成用于构建的文件)，例如：
• Makefile（用于 Unix/Linux 系统）
• Visual Studio 工程文件（用于 Windows 系统）
• Ninja 构建文件 等

它特别适合用在 C++ 和其他需要编译的语言项目中，能极大简化构建、依赖管理和配置过程。

## Make 的核心概念

1. CMakeLists.txt：
   • 项目的配置文件，通常位于项目根目录。
   • 定义构建目标（targets）、依赖项和编译规则。
2. 目标（Targets）：
   • Executable：可执行文件，例如 add_executable(myApp main.cpp)。
   • Library：库文件，例如静态库 add_library(myLib STATIC lib.cpp) 或动态库 add_library(myLib SHARED lib.cpp)。
3. 变量：
   • 定义变量使用 set，例如 set(VERSION 1.0)。
   • 使用变量时加 ${}，例如 set(MY_SRC main.cpp) 后，可以通过 ${MY_SRC} 引用。
4. 依赖管理：
   • 使用 find_package、find_library 等查找外部依赖。
   • 通过 target_link_libraries 将库文件链接到目标。
5. 生成构建文件：
   • 运行 cmake 命令生成目标平台的构建文件。例如：

   ```sh
   mkdir build
   cd build
   cmake ..
   ```

6. 构建项目：
   • 运行生成的构建系统，例如 make 或 ninja。

一个简单的例子

假设我们有以下项目结构：

```code
MyProject/
├── CMakeLists.txt
├── main.cpp
└── lib.cpp
```

CMakeLists.txt 内容如下：

```code
cmake_minimum_required(VERSION 3.10)
project(MyProject)

# 添加可执行目标
add_executable(myApp main.cpp lib.cpp)
```

运行以下命令即可生成并构建项目：

```sh
mkdir build
cd build
cmake ..
make
```

## make 或 ninja 与 camke 的关系

make 和 ninja 与 CMake 的关系可以总结为 工具链之间的协作，其中 CMake 扮演的是构建配置的生成器角色，而 make 和 ninja 是执行实际构建的工具（构建系统）。

以下是它们之间的具体关系和协作方式：

1. CMake 的角色

CMake 是一个 构建系统生成器，它的主要任务是生成具体构建工具所需的配置文件，例如：
• 为 make 生成 Makefile。
• 为 ninja 生成 build.ninja 文件。

CMake 并不负责实际编译代码，而是将你的构建需求（通过 CMakeLists.txt 定义）转换为特定构建工具的配置文件。

2. Make 和 Ninja 的角色

• Make：传统的构建工具，基于 Makefile 工作。它逐行读取 Makefile，根据定义的规则完成代码编译、链接等任务。
• Ninja：现代化的构建工具，专注于高效和快速构建，使用 build.ninja 文件完成构建任务。与 Make 相比，Ninja 更加轻量，执行速度更快，尤其在增量构建中表现突出。

## cmake 为什么不像 js 那样分析文件的引用依赖关系

CMake 不像 JavaScript 那样自动分析文件的引用和依赖关系，主要是因为 C++ 和 JavaScript 的语言特性、编译器的工作方式，以及构建工具的设计目标有根本性的不同。

1. 语言特性

JavaScript 的引用机制
• JavaScript 是动态语言(JS 的变量类型和属性在编译时无法确定，而是完全在运行时决定)，文件的引用关系通常通过 import 或 require 明确表示，并且这种引用可以在运行时动态解析。
• JavaScript 的构建工具（如 Webpack 或 Vite）通过静态分析代码中的 import 路径，可以清楚地了解文件间的依赖关系。

C++ 的依赖机制
• C++ 是静态语言，文件的依赖关系通常通过 #include 指令实现。
• #include 的工作方式是 直接将头文件的内容插入到当前文件，这是在预处理阶段完成的，并不会像 JavaScript 那样有明确的模块化机制。
• 由于 #include 只是文本插入，C++ 编译器无法明确知道整个项目中所有文件的依赖关系。

2. 编译和构建的阶段性差异

JavaScript 的构建
• JavaScript 的代码通常只需一次解析即可构建。
• 构建工具通过 AST（抽象语法树）可以轻松分析所有文件之间的引用关系。

C++ 的编译
• C++ 的构建过程分为多个阶段：预处理 -> 编译 -> 链接。
• 依赖关系（例如头文件的包含）在预处理阶段处理，编译器本身无法追踪跨文件的完整依赖链。

因此，构建工具（如 CMake）需要开发者手动声明文件的依赖关系。

3. 性能和效率考虑
   • 自动解析 C++ 的依赖关系会显著增加 CMake 的复杂性和运行时间，尤其在大规模项目中。
   • 一些 C++ 项目可能包含成千上万的源文件和头文件，自动分析依赖关系会带来不可忽视的性能成本。

4. 工具生态的分工
   • 在 JavaScript 中，构建工具（如 Webpack 或 Vite）既负责依赖分析，又负责打包和优化。
   • 在 C++ 中，CMake 专注于构建配置生成，而 编译器（如 GCC 或 Clang）负责代码的实际编译和优化。这是一种工具分工明确的设计。

量子电路低代码平台架构设计
