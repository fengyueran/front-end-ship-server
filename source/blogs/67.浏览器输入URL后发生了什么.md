---
title: 浏览器输入URL后发生了什么
date: 2020-5-06 18:10:20
---

## 总体概览

大体上，可以分为六步，当然每一步都可以详细都展开来说，这里先放一张总览图:
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/168.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/url.png)

### 合成 URL

当在浏览器地址栏输入内容回车后，浏览器首先会对这些输入进行判断是搜索还是网址：

- 搜索
  如果是搜索，则将默认搜索引擎+搜索内容合成新的 URL，比如在地址栏中输入 china，会合成类似`https://www.google.com.hk/search?q=china`的 URL。
- 网址
  如果是网址，则添加上协议合成合法的 URL，比如搜索`www.baidu.com`会生成`http://www.baidu.com/`。

### [DNS 域名解析](./60.DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.md./60.DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.md)

### 建立 TCP 连接

首先需要判断是不是 HTTPS，如果是则会有 SSL 握手的过程，服务端和客户端都为加密传输。

- [进行三次握手，建立 TCP 连接](./68.%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%90%86%E8%A7%A3.md)
- [SSL 握手过程](../questions/89.%E4%BB%8B%E7%BB%8D%20HTTPS%20%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.md)

完成了之后，客户端和服务器端就可以开始传送数据。

- 关闭 TCP 连接

### 浏览器渲染

当收到数据后就需要解析渲染数据。渲染的流水线可分为以下几个阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。
渲染进程将 HTML 内容转换为能够读懂 DOM 树结构。
渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
创建布局树，并计算元素的布局信息。
对布局树进行分层，并生成分层树。
为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

#### [构建 DOM 树](https://web.dev/critical-rendering-path-constructing-the-object-model/)

浏览器获得 HTMl 后，对于由 HTML 标签组成的字符内容自然是无法直接理解的，需要将其转换会后续方便处理的 DOM(Document Object Model) Tree。步骤如下：
`Bytes → characters → tokens → nodes → object model`.

#### 例子

HTML 如下：

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

处理流程如下图：
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/dom-tree.png)

- 转码

  读取通过网络或磁盘得到的 HTML 原始字节流并指定编码格式将其转换为 HTML 字符串。

- 令牌化

  通过分词器将 HTML 字符串转换为一个个具有特殊含义的 Token。 Token 分为 Tag Token 和文本 Token，而 Tag Token 又分为 StartTag 和 EndTag，分别表示 Tag 的开始和结束，比如`<div>`和`</div>`。

  HTML 解析器维护了一个 Token 栈结构，用以处理节点间的父子关系，生成的 Token 会按顺序压到这个栈中，处理规则如下如下：

  - StartTag Token

    当压入栈的是一个 StartTag Token，解析器则为该 Token 创建一个 DOM 节点，并将该节点添加到 DOM Tree 中，该节点的父节点则是栈中相邻元素生成的那个节点。

  - 文本 Token

    如果解析出来的是一个文本 Token，则创建一个文本节点并将其添加到 DOM Tree 中，文本 Token 不需要压入栈，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。

  - EndTag Token

    如果解析出的是 EndTag Token，则会查看 Token 栈顶的元素是否是一样的元素，如果是，就将 StartTag Token 弹出，表示该元素解析完成。

  为简单起见以下面的 html 为例：

  ```html
  <html>
    <body>
      <span>1</span>
      <div>2</div>
    </body>
  </html>
  ```

  HTML 解析器，最开始会创建一个空的 document 的节点，并将 StartTag document 的 Token 压入栈底。  
  接着解析出 StartTag html Token，然后压入 Token 栈并创建 DOM 节点，最后添加到 document 节点上：
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/document-html.png)

  接着解析到 StartTag body 和 StartTag span，其 Token 栈及 DOM 结构如下：
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/html-body-span.png)

  接下来会解析到 span 的文本 Token，会创建一个文本节点，其父节点就是当前 Token 栈顶元素对应的节点，也就是 span：
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/text-node.png)

  接下来解析到第一个 EndTag，EndTag span，解析器检测当前栈顶元素是否是 StartTag span，如果是则从栈顶弹出 StartTag span，该 span 元素的解析就完成了：
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/token-pop.png)

  最终的解析结果如下：
  ![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/token-parse.png)

  从上述的过程可以看到 dom 的创建过程，不过在实际的解析中会包含 CSS、Javascript、多媒体文件等会使解析过程变得更加复杂。
  此外，可以看到后边的**构建 Nodes** 以及**构建 DOM 树**是和令牌化这一步是同步进行的。

- 构建 Nodes

  将 Token 转换为 Node 对象，并添加特定的属性(或属性访问器)，通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope。

- 构建 DOM 树

  将 DOM 节点转换为具有清晰层级结构的 DOM 树。

#### [构建 CSSOM](https://web.dev/critical-rendering-path-constructing-the-object-model/)

前面已经通过构建 DOM Tree 知道了整个文档的结构，有哪些节点构成，他们的关系如何等等。但是，我们并不知道知道该如何渲染这些节点，这就需要将 CSS 转换为浏览器可识别的 CSSOM(CSS Object Model)。

CSS 的处理过程和 HTML 很相似：

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/cssom.png)

css 字节流转换为字符，然后令牌化，转换为节点，最后转换为 CSSOM。

CSS 如下：

```css
body {
  font-size: 16px;
}
p {
  font-weight: bold;
}
span {
  color: red;
}
p span {
  display: none;
}
img {
  float: right;
}
```

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/67.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/cssom-tree.png)

在转换为 CSSOM 的过程中会作一些转换，比如将 em、white、bold 这些不能被渲染引擎理解的值转换为符合规范的属性值。处理完成后再处理样式的继承和层叠，比如说 body 的字号设置为 16 时，其所有的子 span 的字号都将继承这 16 号的字体，当一个 span 是 p 的后代元素时(p span)则 display 设置为 none。

#### [Render Tree](https://web.dev/critical-rendering-path-render-tree-construction/)

页面布局
布局过程，即排除  script、meta  等功能化、非视觉节点，排除  display: none  的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：

其中，这个过程需要注意的是回流和重绘，关于回流和重绘，详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～
生成分层树
页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：

如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的"开发者工具"，选择"Layers"标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。
并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～
栅格化
合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
显示
最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。
参考资料

极客时间《趣谈网络协议》
极客时间《浏览器工作原理与实践》

最后

欢迎加我微信(winty230)，拉你进技术群，长期交流学习...
欢迎关注「前端 Q」,认真学前端，做个有专业的技术人...

作者：winty
链接：https://juejin.cn/post/6844904054074654728
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
