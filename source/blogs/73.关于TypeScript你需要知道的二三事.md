---
title: 关于TypeScript你需要知道的二三事
tags: [Http]
type: SHORT_ANSWER
date: 2019-1-15 18:10:20
---

### 禁用 ts 校验

- 禁用整个文件的 ts 校验

  `// @ts-nocheck`放到文件顶部:

  ```ts
  //test.js

  // @ts-nocheck
  import axios from 'axios';
  ```

- 禁用单行的 ts 校验

  `// @ts-ignore`放到要禁止校验的代码行上面:

  ```ts
  //test.js

  // @ts-ignore
  let a: number = 'a';
  ```

### TS 类型

#### 基础类型

常用:

```
boolean、number、string、array、enum、any、void
```

不常用:

```
tuple、null、undefined、never
```

#### Union Types

联合类型，表示取值可以为多种类型之一，用 `|`(或) 分割。

```ts
let num: string | number;

type Color = 'red' | 'green' | 'yellow';

interface Fish {
  swim: boolean;
}
interface Bird {
  fly: boolean;
}
type BirdOrFish = Fish | Bird;
```

#### Intersection Types

交叉类型，将多个类型合并为一个类型，用 `&`(且)连接。

```ts
interface Fish {
  swim: boolean;
}
interface Bird {
  fly: boolean;
}
type BirdOrFish = Fish & Bird;
const bf: BirdOrFish = {
  swim: true,
  fly: true,
};
```

#### keyof typeof

keyof 可以获取一个**类型**的 key:

```ts
const colorMap = {
  red: 'red',
  green: 'green',
};

type keys = keyof colorMap; //error

/**************分割线****************/
interface Point {
  x: number;
  y: number;
}

// type keys = "x" | "y"
type keys = keyof Point;
```

typeof 操作符可以用来获取一个变量或对象的类型:

```ts
enum LogLevel {
  Error,
  Warn,
  Info,
  Debug,
}
type LogType = typeof LogLevel;
```

keyof typeof

```ts
const colorMap = {
  red: '#f61a22',
  green: '#309449',
};
// type keys = "red" | "green"
type keys = keyof typeof colorMap;
```

#### 泛型

```ts
const join = <T, P>(first: T, second: P) => {
  return `${first}${second}`;
};
join<number, string>(1, '2');
```

#### 类

```ts
//abstract抽象类不能被实例化
abstract class Father {
  private weight; //private属性，类的外部不可用，继承也不行
  protected money = 10000000; //protected属性，类的外部不可用，继承可以
  public readonly familyName = 'meng'; //public公开属性，readonly只读属性不可修改

  //static 静态方法，不需要 new 就可以直接调用
  static breath() {
    console.log('breath');
  }

  abstract eat: () => void; //抽象方法，所有子类都必须实现抽象方法

  //在构造函数添加访问修饰符可省略顶部(weight)的定义，如private name
  constructor(private name: string, weight: number) {
    this.name = name;
    this.weight = weight;
  }
}

class Son extends Father {
  getMoney() {
    console.log('Money', this.money);
  }

  eat = () => {
    console.log('eat');
  };
}
const Father = new Father('snow', 120); //error，抽象类不能实例化
Father.breath(); //static
const snow = new Son('snow', 120);
console.log(snow.money); //error，protected
snow.familyName = 'zhang'; //error，readonly
```

#### Utility Types

- `Readonly<T>`

  将 T 类型的所有属性设置为只读。

  ```ts
  interface Bird {
    name?: string;
    fly: boolean;
  }

  type ReadonlyBird = Readonly<Bird>;

  const b: ReadonlyBird = { name: 'a', fly: true };
  b.fly = false; //error，Cannot assign to 'name' because it is a read-only property.
  ```

- `Partial<T>`

  将类型 T 中所有属性转换为可选属性，返回的类型可以是 T 的任意子集，也就是 Partial 所表达的意思。

  ```ts
  interface Bird {
    name?: string;
    weight: number;
    fly: boolean;
  }

  type Dog = Partial<Bird>;
  // =
  type Dog = {
    name?: string | undefined;
    weight?: number | undefined;
    fly?: boolean | undefined;
  };
  ```

  `Partial<T>`所表达的意思:

  ```
  type Partial<T> = { [P in keyof T]?: T[P]; };
  ```

- `Required<T>`

  和 Partial 相反，将 T 类型的所有属性设置为必选。

  ```ts
  interface Bird {
    name?: string;
    weight: number;
    fly: boolean;
  }

  type Duck = Required<Bird>;
  // =
  type Duck = {
    name: string;
    weight: number;
    fly: boolean;
  };
  ```

- `Record<K,T>`

  声明键为 K 类型，值为 T 类型的对象。

  ```ts
  interface Order {
    type: string;
    price: number;
  }

  type OrderMap = Record<string, Order>;
  //等同于
  interface OrderMap {
    [key: string]: Order;
  }
  ```

- `Pick<T,K>`

  在已声明的对象类型中挑选出部分属性组成新的声明对象。

  ```ts
  interface Order {
    type: string;
    price: number;
    deadline: string;
  }

  type NewOrder = Pick<Order, 'type' | 'price'>;
  //等同于
  type NewOrder = {
    type: string;
    price: number;
  };
  ```

- `Omit<T,K>`

  与 Pick 相反，在已声明的对象类型去除部分属性，剩余属性组成新的声明对象。

  ```ts
  interface Order {
    type: string;
    price: number;
    deadline: string;
  }

  type NewOrder = Omit<Order, 'deadline'>;
  //等同于
  type NewOrder = {
    type: string;
    price: number;
  };
  ```

- `Exclude<T,U>`

  同 Omit 类似，但 Exclude 是从**联合类型**中排除类型。

  ```ts
  //type Color = 'red'
  type Color = Exclude<'red' | 'green', 'green'>;

  interface Fish {
    swim: boolean;
  }

  interface Bird {
    fly: boolean;
  }

  type BirdOrFish = Fish | Bird;

  //type NewBird===Bird
  type NewBird = Exclude<BirdOrFish, Fish>;
  ```

- `Extract<T,U>`

  与 Exclude，同 Pick 类似，但 Extract 是从**联合类型**中挑选类型。

  ```ts
  //type Color==='green'
  type Color = Extract<'red' | 'green', 'green'>;

  interface Fish {
    swim: boolean;
  }

  interface Bird {
    fly: boolean;
  }

  type BirdOrFish = Fish | Bird;

  //type NewBird===Bird
  type NewBird = Extract<BirdOrFish, Bird>;
  ```

- `ReturnType<T>`

  返回类型为 T 的函数的返回类型，这个方法对于没有明确提供类型的方法来说太方便了。

  ```ts
  const getNumber = () => 7;
  //type T = number
  type T = ReturnType<typeof getNumber>;
  ```

- `Parameters<T>`

  返回类型为 T 的函数的参数类型所组成的数组。

  ```ts
  type T1 = Parameters<() => number>; // []

  type T2 = Parameters<(s: string, n: number) => void>; // [string, number]
  ```

- `NonNullable<T>`

  从联合类型 T 中去除 null 或者 undefined。

  ```ts
  //等同于type T = 'string' | 'number';
  type T = NonNullable<'string' | 'number' | undefined | null>;
  ```

- InstanceType

  返回构造函数类型 T 的实例类型。

  ```ts
  class C {
    x = 0;
    y = 0;
  }
  //等同于 T = C
  type T = InstanceType<typeof C>;
  ```

### 区别

#### interface vs type

- 函数语法的不同

  type 的函数语法更接近于函数本身的声明。

  ```ts
  // via type
  type Sum = (x: number, y: number) => number;

  // via interface
  interface Sum {
    (x: number, y: number): number;
  }
  ```

- Extend

  interface:

  ```ts
  interface Animal {
    name: string;
  }

  interface Dog extends Animal {
    honey: boolean;
  }
  ```

  type:

  ```ts
  type Animal = {
    name: string;
  };

  type Dog = Animal & {
    honey: Boolean;
  };
  ```

- 声明合并

  interface 可以向现有接口添加新字段，type 不行。

  interface:

  ```ts
  interface Point {
    x: number;
  }

  interface Point {
    y: number;
  }
  const pt: Point = { x: 8, y: 9 };
  ```

  type:

  ```ts
  // Error: Duplicate identifier 'Point'.
  type Point = {
    x: number;
  };

  type Point = {
    y: number;
  };
  ```

- 重命名基本类型

  interface 不能重命名基本类型，type 可以。
  interface:

  ```ts
  //error
  interface NewString = string;
  ```

  type:

  ```ts
  type NewString = string;
  ```

- Union types

  type 可用于定义联合类型。

  ```ts
  type Fruit = 'apple' | 'pear' | 'orange';
  type Vegetable = 'broccoli' | 'carrot' | 'lettuce';

  // 'apple' | 'pear' | 'orange' | 'broccoli' | 'carrot' | 'lettuce';
  type HealthyFoods = Fruit | Vegetable;
  ```

- [Mapped object types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)

  interface:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  // ERROR:
  interface FruitCount {
    [key in Fruit]: number;
  }
  ```

  type:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  type FruitCount = {
    [key in Fruit]: number;
  };

  const fruits: FruitCount = {
    apple: 2,
    orange: 3,
    banana: 4,
  };
  ```

- 函数重载

  interface:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  //error
  interface StrAndNumLogger extends NumLogger {
    log: (val: string) => void;
  }
  ```

  type:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  type StrAndNumLogger = NumLogger & {
    log: (val: string) => void;
  };

  const logger: StrAndNumLogger = {
    log: (val: string | number) => console.log(val),
  };

  logger.log(1);
  logger.log('hi');
  ```

- Tuple types

  元组类型，与数组类似，但是元组类型赋值的类型、位置、个数需要和定义的类型、位置、个数一致。

  ```ts
  type TupleArr = [string, boolean, number];
  const v: TupleArr = ['a', true, 1];
  ```

  因此使用 type 的场景如下:

- 需要重命名原始类型
- 需要定义函数类型
- 需要定义联合类型
- 需要利用 mapped types
- 需要函数重载
- 需要使用 tuple types

#### any vs unkown

### tsconfig

如果一个目录下存在一个 tsconfig.json 文件，这意味者这个目录是 TypeScript 项目的根目录。
TypeScript 可以用[tsc](https://www.typescriptlang.org/docs/handbook/compiler-options.html)(TypeScript 编译器)来编译，用 tsconfig.json 文件用来配置编译的相关选项。

安装完 typescript 后就能直接使用 tsc 了:

```
$ yarn add typescript -g
$ tsc hello.ts
```

tsc 如果不指定配置文件则从当前目录开始逐级向上查找 tsconfig.json 文件。当然 tsc 也可以指定配置文件:

```
$ tsc -p tsconfig.build.json
```

tsconfig.json 配置选项。

```json
//tsconfig.json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "types": ["node"]
  },
  "files": ["common.d.ts"],
  "include": ["src"]
}
```

#### files

指定一个包含相对或绝对文件路径的列表。

```json
//tsconfig.json
{
  "include": ["scripts/index.ts", "common.d.ts"]
}
```

#### include

配置哪些文件需要编译，指定一个文件[glob](https://juejin.cn/post/6844904077801816077)匹配模式列表。

```json
//tsconfig.json
{
  "include": ["src", "common.d.ts"]
}
.
├── scripts                ⨯
│   ├── lint.ts            ⨯
│   └── utils.ts           ⨯
├── src                    ✓
│      └── index.ts        ✓
├── common.d.ts            ✓
├── package.json
├── tsconfig.json
└── yarn.lock
```

支持的 glob 通配符有：

- `*`

  匹配 0 或多个字符（不包括目录分隔符）

- `?`

  匹配一个任意字符（不包括目录分隔符）

- `**/`

  递归匹配任意子目录

```json
//tsconfig.json
{
"include": ["src/**/*", "tests/**/*"]
}
.
├── scripts                ⨯
│   ├── lint.ts            ⨯
│   ├── update_deps.ts     ⨯
│   └── utils.ts           ⨯
├── src                    ✓
│   ├── client             ✓
│   │    ├── index.ts      ✓
│   │    └── utils.ts      ✓
│   ├── server             ✓
│   │    └── index.ts      ✓
├── tests                  ✓
│   ├── app.test.ts        ✓
│   ├── utils.ts           ✓
│   └── tests.d.ts         ✓
├── package.json
├── tsconfig.json
└── yarn.lock
```

如果 files 和 include 都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件。如果指定了 files 或 include，编译器会将它们结合一并包含进来，它们所引用的文件(排除在 exclude 里指定的文件)也会包含进来(即使不在 files 或 include 内)。

需要注意编译器不会去引入那些可能做为输出的文件。比如，假设我们包含了 index.ts，那么 index.d.ts 和 index.js 会被排除在外。

#### exclude

配置哪些文件不需要编译，使用 include 引入的文件可以使用 exclude 属性过滤。 而，通过 files 属性明确指定的文件却总是会被包含在内(忽略 exclude)。 如果不指定， exclude 默认情况下会排除 node_modules，bower_components，jspm_packages 和`<outDir>`目录。

```json
//tsconfig.json
{
  "exclude": ["scripts/lint.ts "],
  "include": ["src/**/*", "scripts/**/*"]
}
.
├── scripts                ✓
│   ├── lint.ts            ⨯
│   └── utils.ts           ✓
├── src                    ✓
│      └── index.ts        ✓
├── package.json
├── tsconfig.json
└── yarn.lock
```

#### extends

通过 extends 属性可以继承配置文件，新的配置项 files、include 以及 exclud 都会直接覆盖继承的配置文件对应项，compilerOptions 内部同名属性会被覆盖，不同名属性则会合并。

```json
//tsconfig.json
{
  "compilerOptions": {
    "allowJs": true,
    "esModuleInterop": true,
  },
  "files": ["common.d.ts"],
  "exclude": ["src/index.ts"],
  "include": ["src"]
}

//tsconfig.build.json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "lib"
  }
}
//等同于
{
  "compilerOptions": {
    "allowJs": true,
    "esModuleInterop": true,
    "outDir": "lib"
  },
  "files": ["common.d.ts"],
  "exclude": ["src/index.ts"],
  "include": ["src"]
}
```

#### compilerOptions

- target

  编译的 JS 目标版本，默认是 ES3，可以是 ES3、ES5、`ES6/ES2015`、ES2016-ES2022、ESNext。现代浏览器支持全部 ES6 的功能，所以 ES6 是一个不错的选择。

  特殊的 ESNEXT 值代表你的 TypeScript 所支持的最高版本。这个配置应当被谨慎使用，因为它在不同的 TypeScript 版本之间的含义不同，并且会导致升级更难预测。

  ```json
  //tsconfig.json
  {
    "compilerOptions": {
      "target": "ES6"
    }
  }
  ```

- noEmit

  是否**不生成**输出文件，默认为 false，即要生成文件，如果只想编译，不生成文件，则该值应该设置为 true:

  ```ts
  //tsconfig.json
  {
    "compilerOptions": {
      "noEmit": true
    }
  }
  ```

- baseUrl

  解析非相对模块名的基准目录，如下:
  设置 baseUrl 为`.`即当前目录为基准目录:

  ```json
  .
  ├── src
  │   ├── components
  │   │   └── button.tsx
  │   ├── features
  │   │   └── user.tsxcom'
  │   └── index.ts
  └── yarn.lock
  //tsconfig.json
  {
    "compilerOptions": {
      "baseUrl": "."
    }
  }
  ```

  在 user.tsx 引用就可以写成这样:

  ```tsx
  //user.tsx
  //src为'.'指定的基准目录下的目录
  import Button from 'src/components/button';
  //而不是
  import Button from '../components/button';
  ```

- outDir

  tsc 编译输出的目录，如果不指定则编译到 ts 文件所在目录。

  ```json
  //tsconfig.json
  {
    "compilerOptions": {
      "outDir": "lib"
    }
  }
  ```

- allowJs

  是否编译 js 文件，默认为 false。

  ```json
  //tsconfig.json
  {
    "compilerOptions": {
      "allowJs": true
    }
  }
  ```

  如果为 true，js 文件会被编译到 outDir 目录，不然会报错。

- [esModuleInterop](https://zhuanlan.zhihu.com/p/148081795)

  esModuleInterop 为 false 时不会处理 esm 模块默认导入的问题，如下:

  ```js
  //esm
  import React from 'react';
  console.log(React);
  //编译后
  ('use strict');
  exports.__esModule = true;
  var react_1 = require('react');
  //react为commonjs代码，没有导出defalut
  console.log(react_1['default']); //undefined
  ```

  esModuleInterop 为 true 时，如下:
  可以看到通过函数`__importDefault`可以正确处理。

  ```ts
  // esm
  import React from 'react';
  console.log(React);
  // 编译后

  var __importDefault = function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };

  var react = __importDefault(require('react'));
  console.log(react['default']);
  ```

- jsx

  在 `.tsx`文件里支持[JSX](https://www.tslang.cn/docs/handbook/jsx.html)语法，可以控制 JSX 在 JavaScript 文件中的输出方式。 这只影响 .tsx 文件的 JS 文件输出。有以下几种选项:

  - react

    将 JSX 改为等价的对 React.createElement 的调用并生成 .js 文件。

  - react-jsx

    改为 `_jsx` 调用并生成 .js 文件。

    ```ts
    import { jsx as _jsx } from 'react/jsx-runtime';

    import React from 'react';
    export const helloWorld = () => _jsx('h1', { children: 'Hello world' });
    ```

  - react-jsxdev

    改为 `_jsx` 调用并生成 .js 文件。

  - preserve

    不对 JSX 进行改变并生成 .jsx 文件。

  - react-native

    不对 JSX 进行改变并生成 .js 文件。

- lib

  编译时需要引入的库，默认注入的库为：
  target ES5：DOM，ES5，ScriptHost
  target ES6：DOM，ES6，DOM.Iterable，ScriptHost

  ```json
  {
    "compilerOptions": {
      "lib": ["dom", "dom.iterable", "esnext"]
    }
  }
  ```

- typeRoots 和 types

  默认情况下所有可见的@types 包会在编译过程中被包含进来。 `node_modules/@types` 文件夹下以及它们子文件夹下的所有包都是可见的。

  如果指定了 typeRoots，只有 typeRoots 下面的包才会被包含进来。需要注意的是如果指定了 typeRoots，且 include 不为空，typeRoots 指定的目录不在 include 里则需要将相应的目录放到 include 里:

  ```json
  .
  ├── src
  │      └── index.ts
  ├── typings
  │      └── index.d.ts
  ├── package.json
  ├── tsconfig.json
  └── yarn.lock
  {
    "compilerOptions": {
      "typeRoots": ["typings"],
      "include": ["src", "typings"]
    }
  }
  ```

  如果指定了 types，只有被列出来的包才会被包含进来:

  ```json
  {
    "compilerOptions": {
      "types": ["node", "lodash", "semver"]
    }
  }
  ```

  指定`"types": []`则不会引用@types 包。不过，使用 import "foo"语句，TypeScript 仍然会查找 node_modules 和`node_modules/@types`文件夹来获取 foo 包。

- skipLibCheck

是否跳过声明文件(d.ts)的检查 默认值为 false。
如果依赖包和项目本身的 TS 版本不一致，在编译时会出现错误，可以在 tsconfig.json 关闭依赖包的检查。

```json
{
  "compilerOptions": {
    "skipLibCheck": true
  }
}
```

- declaration

  是否生成声明文件(d.ts)，默认值为 false。

  ```json
  {
    "compilerOptions": {
      "declaration": true
    }
  }
  ```

  当 declaration 为 true 时，用编译器执行下面的 TypeScript 代码：

  ```ts
  export let helloWorld = 'hi';
  ```

  将会生成如下这样的 index.js 文件：

  ```ts
  export let helloWorld = 'hi';
  ```

  以及一个相应的 helloWorld.d.ts：

  ```ts
  export declare let helloWorld: string;
  ```

- emitDeclarationOnly

  是否**只生成**声明文件(d.ts)，默认值为 false。需要配合
  declaration 使用:

  ```json
  {
    "compilerOptions": {
      "declaration": true,
      "emitDeclarationOnly": true
    }
  }
  ```

- isolatedModules

  是否是独立的模块，默认值为 false，当为 true 时则所有的实现文件必须是模块，也就是它有某种形式的 `import/export`。

  ```json
  {
    "compilerOptions": {
      "isolatedModules": true
    }
  }
  ```

  以下文件没有 import 或 export，isolatedModules 为 true 时编译就会报错。

  ```ts
  //test.ts
  const a = 3;
  ```

- resolveJsonModule

  是否引入 JSON 文件，默认为 false，如果想引入 JSON 文件，该值应设为 true:

  ```json
  {
    "compilerOptions": {
      "resolveJsonModule": true
    }
  }
  ```

  引入 JSON:

  ```tsx
  //test.tsx
  import React from 'react';
  import packageInfo from '../package.json';

  export const Test = () => <div>{packageInfo.version}</div>;
  ```

- moduleResolution

  模块的查找方式，[详见](https://www.typescriptlang.org/docs/handbook/module-resolution.html)。

  ```json
  {
    "compilerOptions": {
      "moduleResolution": "node"
    }
  }
  ```

  主要有以下三种方式:

  - node

    CommonJS 的查找方式，基本都采用这种方式。

  - node16/nodenext

    TypeScript 4.7 后支持的方式。

  - classic

    TypeScript 1.6 以前的方式。

以上编译选项都是较为常用的，其他选项详见:
[tsconfig](https://www.typescriptlang.org/tsconfig)、[compiler-options](https://www.tslang.cn/docs/handbook/compiler-options.html)。
