---
layout: post
title: 每日一题
category: subject
tagline: "Supporting tagline"
tags: [subject]
description: 前端题集
date: 2017-1-04 21:36:05
---

**1、\*\* JavaScript`===`和`==`的区别**

**`===`**
即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换。规则如下:

- 如果类型不同则不相等
- 如果都是数值，并且为同一个值则相等(NaN 除外)

  NaN 不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0 等于(`==`或`===`)-0(对于 0 而言没有正负之分)。

- 如果是字符串，每个位置的字符都一样则相等
- 如果是布尔值，两个都是 true 或两个都是 false 则相等
- 如果两个值为对象(Object、Function 等)，并且引用地址相等则相等

  对于引用类型的变量，`==`和`===`都只会判断引用地址是否相等，而不会判断对象具体里的属性以及值是否相等。判断两个对象是否相等，一个简单的方法就是将他们转换为字符串再进行比较。

  ```
  var obj1Str = Json.stringify(obj1);
  var obj2Str = Json.stringify(obj2);
  console.log(obj1Str === obj2Str);
  ```

- 如果两个都是 null 或都是 undefined，则相等

  比较 null 和 undefined 时不能将其转换为其他类型，typeof(null): object, typeof(undefined): undefined。

  ```
  null === null  //true
  undefined === undefined  //true
  //不同类型
  undefined === null  //false
  undefined == null  //true
  //不能转换
  undefined == 0 //false
  null == 0 //false
  ```

**`==`**
即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如严格相等则相等。规则如下:

- 如果两个值类型相同则进行`===`比较
- 如果两个值类型不同则进行类型转换

  - 如果一个是 null，一个是 undefined 则相等
  - 如果一个是字符串，一个是数值，则把字符串转换为数值再进行比较
  - 如果任一个是布尔类型，则将其转换为数值类型(true: 1, false: 0)再进行比较
  - 如果一个是对象，一个是基本类型，则将对象转换为基本类型进行比较

    对象转换为基本类型会调用对象的 valueOf 或 toString 方法，通常 valueOf 先于 toString 调用，当 valueOf 返回类型还是对象时，则继续调用 toString 方法进行转换。

    ```
      Number([]); // 0, [].valueOf() => [], toString()=>"",  Number("")=>0
      Number({}); // NaN, ({}).toString() => "[object Object]", Number("[object Object]")=>NaN
      console.log(([])?true:false); //true
      console.log(([]==false?true:false)); //true
      console.log(({}==false)?true:false) //false
    ```

  - 任何其他组合都不相等

**2、 简述 domready、DOMContentLoaded、onload 的区别，图片的 onload 和页面 onload 的先后顺序，并简述原因。**

**DOM 文档的加载步骤如下:**

- 1. 解析 html 文档结构
- 2. 加载外部的脚本和样式表文件
- 3. 解析并执行脚本
- 4. dom 树构建完成(DOMContentLoaded)
- 5. 加载图片等外部文件
- 6. 页面加载完毕

**domready:**

也就是 dom 构建完成，它不是一个标准的事件，DOMContentLoaded 后表明 dom ready 了。

**DOMContentLoaded:**

第四步完成后触发，即在 dom 解析完成后执行，无需等待样式表、图像、子框架等的加载，需要注意的是 DOMContentLoaded 事件必须等待所有 script 加载解析完成后才会触发。

```
document.addEventListener("DOMContentLoaded", () => alert("DOMContentLoaded"));
```

**图片 onload**:

第五步图片加载完成后触发

**页面 onload**:

dom，外部图片、javascript 文件、CSS 文件等资源都加载完成后(包括脚本里通过创建 dom 动态添加的资源)触发，所以一定是在图片的 onload 事件后触发。

```
window.onload = () => {
    alert("window onload");
};
```

**3、** JS 中加减乘除的规则

**加法**

JS 中的加法要么是数值和数值相加，要么是字符串和字符串相加，所有其他类型都会转换为这两种类型。

- 如果有一个操作数为 NaN，则结果是 NaN;
- 如果 Infinity 加 Infinity，结果为 Infinity;
- 如果-Infinity 加-Infinity，结果为-Infinity;
- 如果 Infinity 加-Infinity，结果为 NaN;
- 如果+0 加+0，结果是+0;
- 如果-0 加-0，结果为-0;
- 如果+0 加-0，结果为+0;
- 如果两个操作数为字符串，则将两个数拼接起来;
- 如果只有一个操作数为字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来;
- 如果只有一个操作数为数值，另一个操作数为 null 或 undefined，则将 null 和 undefined 转换为数值，再将两个数值进行相加;
  ```
  '1' + null //"1null"
   1 + null // 1, Number(null) => 0
  '1' + undefined //"1undefined"
   1 + undefined //NaN, Number(undefined) => NaN
  ```
- 如果有一个操作数为对象，则调用对象的 toString()方法将其转换为字符串，再应用上面的规则进行计算
  ```
    var func = function(){};
   '1' + func //"1function(){}"
   '1' + null //"1null"
  ```

**减法**

- 如果两个操作数都是数字，执行常规减法；
- 如果一个操作数为 NaN，则结果为 NaN；
- 如果是 Infinity 减 Infinity，则结果是 NaN；
- 如果是-Infinity 减-Infinity，则结果为 NaN；
- 如果是+Infinity 减-Infinity，则结果为+Infinity;
- 如果是-Infinity 减+Infinity，则结果为-Infinity;
- 如果是+0 减+0，则结果是+0；
- 如果是-0 减-0，则结果是+0；
- 如果是-0 减+0，则结果是-0；
- 如果一个操作数是字符串、布尔值、null、undefined，则先调用 Number 函数将其转换为数值，再根据前面的规则进行计算；
- 如果一个操作数是对象，则调用对象的 valueof 方法得到其数值，如果没有 valueof 方法，则调用 toString 方法进行转换，然后再根据前面的规则进行计算；

**乘法**

- 如果操作数都是数值，则执行常规的乘法运算，正数乘以正数或负数乘以负数结果都为正数，如果只有一个操作数为负数，则结果为负数，如果乘积超过了 ECMAScript 数值的范围则返回 Infinity 或-Infinity；
- 如果一个操作数是 NaN，则结果为 NaN；
- 如果是 Infinity 与 0 相乘，则结果为 NaN；
- 如果是 Infinity 与非 0 相乘，则结果为 Infinity 或-Infinity，取决于有符号的操作数的符号；
- 如果是 Infinity 与 Infinity 相乘，则结果为 Infinity；
- 如果一个操作数不是数值，则调用 Number 方法将其转换为数值，再应用前面的规则进行计算；

**除法**

- 如果操作数都是数值，则执行常规的除法运算，正数除以正数或负数除以负数结果都为正数，如果只有一个操作数为负数，则结果为负数，如果商超过了 ECMAScript 数值的范围则返回 Infinity 或-Infinity；
- 如果一个操作数是 NaN，则结果为 NaN；
- 如果是 Infinity 除以 Infinity，则结果为 NaN；
- 如果 0 除以 0，则结果为 NaN；
- 如果是非 0 的有限数被 0 除，则结果是 Infinity 或-Infinity，取决于有符号的操作数的符号；
- 如果是 Infinity 除以任何非 0 值，则结果是 Infinity 或-Infinity，取决于有符号的操作数的符号；
- 如果一个操作数不是数值，则调用 Number 方法将其转换为数值，再应用前面的规则进行计算；

**4、常用的跨域解决方案**

由于浏览器的同源策略，会对不同域的网页间的交互作出限制。所谓同源必须是协议、域名、端口都相同，即使不同域名指向同一个 ip 地址，也不是同源。可以通过以下方法来实现跨域请求。

**1) jsonp**

通常，为了减轻服务器的负载，我们将 css、img 等静态资源放到另一台独立的域名，html 通过相应的标签可以下载不同域名下的静态资源，因此可以通过建立 script 脚本来实现跨域。

- 客户端

  ```
    <script>
      // 后端返回时执行这个在前端定义的回调函数
      function handleCallback(res) {
        alert(JSON.stringify(res));
      }
      const script = document.createElement("script");
      script.src = "http://localhost:8000/test?callback=handleCallback";
      document.head.append(script);
    </script>
  ```

- 服务端

  ```
  app.get("/test", (req, res) => {
    const { callback } = req.query;
    const data = { name: "xhm" };
    const cbStr = `${callback}(${JSON.stringify(data)})`;
    res.send(cbStr);
  });
  ```

**2) domain + iframe**

此方案仅限于主域相同，子域不同的情景。如下，A 页面的 document.domain 为 a.domain.com、B 页面的 document.domain 为 b.domain.com，我们可以通过将 A、B 页面的 domain 设置为相同(一级域名必须一致才能设置)来实现跨域。

- A 窗口(`http://a.domain.com/a.html`)

  ```
  <iframe src="http://b.domain.com/b.html"></iframe>
  <script>
      document.domain = 'domain.com';
      var name = 'xhm';
  </script>
  ```

- B 窗口(`http://b.domain.com/b.html`)

  ```
  <script>
      document.domain = 'domain.com';
      // 获取父窗口中变量
      alert('parent name' + window.parent.name); //xhm
  </script>
  ```

**3) postMessage**

- a.html(`http://domain1.com/a.html`)

  ```
  <iframe id="iframe" src="http://domain1.com/a.html"></iframe>
  <script>
      var iframe = document.getElementById('iframe');
      iframe.onload = function() {
          var data = { name: 'xhm' };
          // 向domain2传送跨域数据
          iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com/b.html');
      };

      // 接受domain2返回数据
      window.addEventListener('message', function(e) {
          alert('I am domain1, I get data from domain2:' + e.data);
      }, false);
  </script>
  ```

- b.html(`http://www.domain2.com/b.html`)

  ```
  <script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('I am domain2, I get data from domain1:' + e.data);
        var data = 'hello';
        // 向domain1发送消息
        window.parent.postMessage(JSON.stringify(data), e.origin);
    }, false);
  </script>
  ```

**4) 跨域资源共享(CORS)**

对于普通的跨域请求，只需要在服务端设置 Access-Control-Allow-Origin 即可(如果设置了请求头也需要设置 Access-Control-Allow-Headers)，前端无须设置，若要带 cookie 请求，则前后端都需要设置。

- 客户端 Ajax 请求

  ```
  var xhr = new XMLHttpRequest();
  // 前端设置是否带cookie
  xhr.withCredentials = true;

  xhr.open('post', 'http://www.domain2.com:8000/test', true);
  xhr.setRequestHeader('Content-Type', 'application/json');
  const data = { name: 'xhm"}
  xhr.send(JSON.stringify(data));

  xhr.onreadystatechange = function() {
      if (xhr.readyState == 4 && xhr.status == 200) {
          alert(xhr.responseText);
      }
  };

  ```

- node express 后端设置

  ```
  const app = express();
  app.all("*", (req, res, next) => {
    res.header("Access-Control-Allow-Origin", "http://www.domain1.com:8000");
    res.header(
      "Access-Control-Allow-Headers",
      "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"
    );
    //允许前端带认证cookie，设置此项时Access-Control-Allow-Origin的值不能为*
    res.header("Access-Control-Allow-Credentials", "true");
    next();
  });
  ```

  此外，也可以直接通过 cors 中间件直接进行设置，原理同上面的头部设置一样。

  ```
  app.use(cors());
  ```

**5) WebSocket 协议**

WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

- 客户端

  ```
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.dev.js"></script>
  <script>
    var socket = io('http://www.domain2.com:8080');

    // 连接成功处理
    socket.on('connect', function() {
        // 监听服务端消息
        socket.on('message', function(msg) {
            console.log('data from server:' + msg);
        });

        // 监听服务端关闭
        socket.on('disconnect', function() {
            console.log('Server socket has closed.');
        });
    });
  </script>
  ```

- 服务端

  ```
  const http = require("http");
  const socket = require("socket.io");

  // 启http服务
  const server = http.createServer((req, res) => {
    res.writeHead(200, {
      "Content-type": "text/html"
    });
    res.end();
  });

  server.listen("8080");
  console.log("Server is running at port 8080...");

  // 监听socket连接
  socket.listen(server).on("connection", (client) => {
    // 接收信息
    client.on("message", (msg) => {
      client.send(`hello：${msg}`);
      console.log(`data from client: ${msg}`);
    });

    // 断开处理
    client.on("disconnect", () => {
      console.log("Client socket has closed.");
    });
  });

  ```

**5、什么是优雅降级和渐进增强？**

- 渐进增强(progressive enhancement)

  针对低版本的浏览器构建页面，保证最基本的功能，然后再对高级浏览器进行功能的扩充，包括效果、交互、新功能等，从而达到更好的用户体验。

- 优雅降级(graceful degradation)

  一开始就构建完整的功能，然后针对低版本进行兼容。

区别: 优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强是从一个非常基础的能够起作用的版本开始，并不断扩从，以适应未来环境的需要。降级(功能衰减)意味着往回看，而增强意味着朝前看，同时保证其根基处于安全地带。

**6、HTTP2 的新特性？**

HTTP/2 的主要设计思想都是源自 Google 的 SPDY 协议，是互联网工程任务组(IETF)对谷歌提出的 SPDY 协议进行标准化才有了现在的 HTTP/2。

- 单一长链接

  在 HTTP/2 中，客户端向某个域名的服务器请求页面的过程中，只会创建一条 TCP 连接，即使这个页面有可能包含上百个资源。而 HTTP/1.x 一般会创建 6-8 条 TCP 连接来请求这 100 多个资源。单一的长连接，避免了创建多个 TCP 连接的开销，提高了吞吐量。

- 多路复用

  HTTP/1.x 在一条 TCP 连接上，多个请求只能串行执行，而 HTTP/2 可以一次请求。此外 HTTP/2 还能指定优先级，可以优先下载重要的资源。

- 头部压缩和二进制格式

  HTTP/1.x 一直都是 plain text，HTTP/2 使用 HPACK 压缩来压缩头部。

- 服务端推送

  这个功能通常被称作缓存推送，服务端可以主动向客户端推送资源。当然这需要客户端显式地允许服务端提供该功能，即使如此，客户端也可以自主选择是否需要中断该推送。

**7、编写一个函数实现 form 表单的序列化(即将一个表单中的键值序列化为可提交的字符串)?**

表单结构大致如下:

```
  <form id="target">
    <select name="age">
      <option value="17" selected>17</option>
      <option value="25" selected>25</option>
    </select>
    <input name="name" value="xhm" />
    <input type="password" name="password" value="123456" />
    <input type="hidden" name="salery" value="28888" />
    <textarea name="description">I am a boy.</textarea>
    <input type="checkbox" name="hobby" value="football" checked />Football
    <input type="checkbox" name="hobby" value="basketball" />Basketball
    <input type="radio" name="sex" value="Male" checked />Male
    <input type="radio" name="sex" value="Female" />Female
  </form>
```

序列化函数如下:

```
var serialize = (form) => {
  const elements = form.elements;
  const parts = [];
  for (let i = 0; i < elements.length; i++) {
    const field = elements[i];
    const { type, name, value } = field;
    if (/select/.test(type)) {
      const options = field.options;
      for (let i = 0; i < options.length; i++) {
        const opt = options[i];
        if (opt.selected) {
          const optValue = opt.value || opt.text;
          const param = `${name}=${encodeURIComponent(optValue)}`;
          parts.push(param);
        }
      }
    } else if (/checkbox|radio/.test(type)) {
      if (field.checked) {
        const param = `${name}=${encodeURIComponent(value)}`;
        parts.push(param);
      }
    } else if (/text|password|textarea|hidden/.test(type)) {
      const param = `${name}=${encodeURIComponent(value)}`;
      parts.push(param);
    }
  }
  return parts.join("&");
};
```

**8、** html 代码中让链接在新窗口中打开的写法

通过设置 a 标签的 target 属性为\_blank 可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过 window.openner 访问原页面的窗口对象，并且可以通过 window.opener.location = newURL 将原页面导航至不同的网址。因此需要通过 ref="noopenner"来禁用 window.opener。

```
  <div>
    <div>
      <a href="http://www.xinghunm.com">Welcome -  old window</a>
    </div>
    <div>
        <a href="http://www.xinghunm.com" target="_blank" ref="noopenner">Welcome -  new window</a>
    </div>
  </div>
```

**9、** html5 有哪些新特性，移除的元素有哪些？

html5 现在已经不是标准通用标记语言 SGML 的子集了，主要是关于图像、位置、存储、多任务功能的增加。
新增:

- WebSocket
- Webworker
- SharedWorker
- 用于绘画的 canvas 元素
- 用于媒介回放的 vedio 和 audio 元素
- 新增 sessionStorage 和 localStorage 对离线缓存更好的支持
- 新的特殊内容元素，如 article、header、footer、nav、section
- 新的表单控件，如 calendar、date、time、email、url、search
  移除:
- basefont
- big
- center
- dir
- font
- frame
- frameset
- noframes
- strike
- tt

**10、** 谈谈对盒模型的理解

浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为 W3C 标准盒模型和 IE 盒模型，W3C 标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而 IE 盒模型的大小只由内容区域的大小(自定义的 width 和 height)决定。css 可以通过 box-sizing 来切换两种盒模型。
矩形盒子

- W3C 标准盒模型(box-sizing: content-box)
  size = content + border + padding
- IE 盒模型(box-sizing: border-box)
  size = content

我们在编写 html 时若不声明 DOCTYPE 类型，IE 浏览器会将盒子模型解释为 IE 盒模型，FireFox 等会将其解释为 W3C 盒子模型，从而渲染出不同的结果。

**11、** 主流的浏览器内核有哪些

- Trident
  Trident 为在早期的 IE 内核，没有使用 W3C 标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。
- Gecko
  Gecko(火狐内核)，代码开源，也是一个跨平台内核。
- Presto
  Presto(Opera 前内核)，渲染速度快兼容性差，现已废弃而采用 Google Chrome 的 Blink 内核。
- Webkit
  Webkit(Safari 内核)，主要由渲染引擎 WebCore 和 javascript 解释引擎 JSCore 组成，代码开源。
- Chromium/Blink
  2008 年谷歌发布了 chrome 浏览器，其内核被命名为 chromium，chromium 代码 fork 自开源引擎 webkit 并对其进行重新梳理。
  2013 年谷歌决定从 WebKit 衍生出自己的 Blink(WebKit 的分支)引擎，后由 Google 和 Opera Software 共同研发。

**12、** 前端页面分层

- 结构层
  由 HTML 或 XHTML 创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。
- 表示层
  由 CSS 创建，CSS 对如何显示这些标签内容进行了回答。
- 行为层
  行为层回答了内容应该如何对事件作出反应

**13、** 以下输出的内容

函数作用域内 var 声明是局部变量

```
var a = 1;
function func(){console.log(a);var a = "in";}
func();
=> undefined
```

**14、** 以下输出的内容

```
(
  function func() {
    var a = b ='res';
  }
)();

//b前面没有跟着var相当于全局变量，所有输出res
console.log(b);//res
//a前面没有跟着var所以a是局部变量，所有输出undefined
console.log(a);
```

**15、** 用 js 写一个继承实例

```
function Parent(name, age) {
  this.name = name;
  this.age = age;
  function getName() {
    console.log(this.name);
  }
}

function Child(name, age) {
  Parent.call(this, name, age)
  this.weight = 120;
}

const snow = new Child('snow', '20');
console.log(snow.name)
```

**16、** 匹配文档中的关键字

```
  const colorKeyWords = (node, targetValue) => {
    const HIGHLIGHT_COLOR = "orange";
    const highlightTag = "<span style='background-color: "+HIGHLIGHT_COLOR+";'>" + targetValue + "</span>";
    let htmlStr = node.innerHTML;

    const targetReg = new RegExp(targetValue, "ig");
    htmlStr = htmlStr.replace(targetReg, highlightTag);
    node.innerHTML = htmlStr;
  }
```

**17、** 单击以下 node 时获取 node 的属性 title 和内容`<div id="xhm" title="blog">my blog</div>`

```
const node = document.getElementById("xhm");
node.addEventListener('click', ()=> {
  console.log(node.innerText); // my blog
  console.log(node.getAttribute('title')); // blog
})
```

**18、** link 和@import 的区别

- 从属关系不同
  link 属于 XHTML 提供的标签，除了加载 CSS 外还可以做其他事情，比如定义 RSS、定义 rel 连接属性等，而@import 只能用于加载 CSS。

- 加载时机不同
  link 引用 CSS 时，在页面加载的同时加载，而@import 引用的 CSS 要在页面加载完后再加载。

- 兼容性不同
  link 属于 XHTML 标签，无兼容性问题。而@import 是在 CSS2.1 提出的，低版本浏览器不支持。

- DOM 可控性的不同
  link 支持使用 JavaScript 控制 DOM 去改变样式，而@import 不支持。

**19、** 修改 chrome 浏览器表单自动填充后的黄色背景

- 取消 chrome 的自动填充

  ```
   <input autoComplete="new-password" />
  ```

- 设置内阴影来覆盖黄色背景

  ```
    &: -webkit-autofill {
      -webkit-box-shadow: 0 0 0 1000px white inset;
      -webkit-text-fill-color: black;
    }
  ```

- 设置动画

  通过动画设置其背景永远为透明。

  ```
     &:-webkit-autofill {
        animation: autofill-fix 1s infinite;
      }

     @keyframes autofill-fix {
       from {
         background-color: transparent;
       }
       to {
          background-color: transparent;
       }
     }
  ```

**20、** JavaScript 数据类型

- 基本数据类型
  - undefined
  - Null
  - Boolean
  - String
  - Number
  - Symbol(new in ES6)
- 引用数据类型(Object 类型)

  - Object
  - Array
  - Date
  - RegRxp
  - Function

**21、** js 将一浮点数小数点左边的数字每三位加一个逗号

- 利用 parseInt 的 toLocaleString 方法

  ```
  const formatNum = (num) => num.toString().replace(/(\d+)(.*)/g,
  match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)

  formatNum(15234555.55)
  => "15,234,555.55"
  ```

- 完全用正则替换
  ```
    //当一个字符串中某个数字后跟着n对三个数字(\d{3})就匹配这个数字
    const formateNum = (num) => {
      const numStr = num.toString();
      //替换小数点左边的数字
      return numStr.replace(/\d+/, (match) => {
        //替换目标数字为`${matchNum},`
        return match.replace(/(\d)(?=(\d{3}+$))/, (s1) => `${s1},`);
      })
    }
    formatNum(435345.656)
    => "435,345.656"
  ```

**22、** HTML 常见的内联元素、块级元素以及空元素有哪些？

- 内联元素

  - a
  - img
  - input
  - label
  - span
  - br
  - select
  - strong
  - textarea

- 块级元素

  - div
  - h1-h6
  - form
  - hr
  - p
  - ul
  - table
  - option
  - li

- 空元素
  - `<br>`
  - `<hr>`
  - `<img>`
  - `<input>`
  - `<link>`
  - `<meta>`

**23、** 移动开发中使用 rem 的优缺点

rem 是 CSS3 新增的一个单位即 root em，它与 em 的区别在于 em 是相对父元素的 font-size，而 rem 相对的是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置`<html>`元素的字体大小，就可以适配不同的屏幕。rem 布局需要计算大小，相对麻烦，此外在引用第三方库时也适配也比较麻烦。

**24、** js 模块化分哪些阶段

- 无模块化

  js 最初的作用只是进行表单验证或添加一些简单的动画，js 文件通过`script`标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的 js 文件就把多个`script`标签放在一起。

  ```
    <script src="script1.js"></script>
    <script src="script2.js"></script>
    <script src="script3.js"></script>
  ```

  - 优点
    相对于把所有逻辑放入一个文件，这种引入多个 js 文件实现简单模块化的思想是进步的。
  - 缺点
    污染全局作用域，文件间依赖关系不明显。

- CommonJS 规范
  CommonJS 是一个 JavaScript 模块化规范，最初用于服务端的 node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS 通过 exports 或 module.exports 来导出需要对外提供的接口，通过 require 方法来同步加载所要依赖的模块。

  - 模块定义

    ```
    // util.js
    var x = 0;
    var add = function (value) {
      return value + x;
    };
    exports.x = x;
    module.exports.add = add;
    ```

  - 模块使用
    ```
     var util = require(./util.js);
     console.log(util.x); // 0
     console.log(util.add(1)); // 1
    ```
  - 优点
    解决了全局污染及模块间依赖的问题
  - 缺点
    CommonJS 为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS 就不再适用了。

- AMD 规范
  AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现 AMD 规范的加载器 JS 主要有两个 require.js(与 Node 中的 require 是不一样的内容) 和 curl.js，AMD 推崇依赖前置。
  AMD 标准中定义了两个 API，define 和 require:

  - 模块定义: define(id, [depends], callback)

    ```
    //math.js，定义了一个math模块
    define(function () {
      var add = function (x, y) {
        return x + y;
      }
      return {
        add: add,
      };
    });
    ```

  - 模块使用: require([module], callback)

    ```
      require(['math'], function (math){
        console.log(math.add(1,1));
      });
    ```

  - 优点
    适合在浏览器环境中异步加载模块，并可以并行加载多个模块。
  - 缺点
    提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。

* CMD 规范
  CMD(Common Module Definition)规范是 seajs 推崇的规范，与 requirejs 类似，其不同点在于其加载模式为按需加载，CMD 推崇依赖就近。

  ```
  define(function(require, exports, module) {
    var a = require('pdf.js');
    a.doSomething();
    // 依赖就近书写，什么时候用到什么时候引入
    var b = require('./b');
    b.doSomething();
  });
  ```

  - 优点
    实现了异步加载模块，并可以按需加载。
  - 缺点
    依赖 SPM 打包，模块的加载逻辑偏重。

* ES6 模块化
  前面的模块化方法都是社区自己实现的，而 ES6 的模块化方案是真正的规范。在 ES6 中通过 import 关键字引入模块，export 关键字导出模块，目前浏览器尚不支持 ES6 因此需要用 babel 将代码转换为广泛支持的 require。

  ```
    import React, { Component } from 'react';
    import Counter from '../counter';

    class Home extends Component {
      render() {
        return (
          <div>
            <Counter />
          </div>
        );
      }
    }

    export default Home;
  ```

**25、** 不用第三个变量，直接交换两个变量的值

- 方法 1: 利用技巧

  ```
    var a = 5;
    var b = 6;
    a = a + b;
    b = a - b;
    a = a - b;

    console.log(a); // 6
    console.log(b); // 5
  ```

- 方法 2: 利用位运算
  位运算当且仅当只有一个表达式的某位上为 1 时，结果的该位才为 1。否则结果的该位为 0。

  ```
    var a = 5; // 二进制101
    var b = 6; // 二进制110
    a = a^b;
  =>
    a = 101
        110
        ━━━
        011

    b = a^b;

  =>
    b = 011
        110
        ━━━
        101

    a = a^b;
  =>
    a = 011
        101
        ━━━
        110

    console.log(a); // 6
    console.log(b); // 5
  ```

**26、** CSS 创建平移动画

```
  {
    width: 100px;
    height: 30px;
    position: absolute;
    background: blue;
    left: 0;
    top: 0;
    animation: move 3s ease infinite;

    @keyframes move {
      50% {
        left: 100px;
        top: 100px;
      }
    }
    // 或
    @keyframes move {
      50% {
        transform: translate(100px, 100px);
      }
    }
  }
```

**27、** js 选择 select 下的 option

```
<select>
  <option value="option1">1</option>
  <option value="option2">2</option>
</select>

const selectNode = document.querySelector('select');
// 1.设置value的值等于option的value来选中option
selectNode.value = option2;

// 2.设置selectedIndex来选中option
selectNode.selectedIndex = 1;

```

**28、** CSS 实现超出部分内容显示`...`

```
{
  //需限制其宽度
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

**29、** CSS postion 定位有哪几种情况

- static

  static 定位是默认的定位方式，元素出现在正常的文档流中，会忽略 left、top、right、bottom 以及 z-index。

- absolute

  absolute 定位即绝对定位，相对于除 static 定位元素的第一个父类元素进行定位，元素的位置通过 left、top、right 以及 bottom 属性进行设置。

- fixed

  fixed 定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过 left、top、right 以及 bottom 属性进行设置。

- relative

  relative 定位即相对定位，相对的参考位置为元素自身所在文档流的位置(不管这个元素是否脱离正常文档流)，通过 left、top、right 以及 bottom 属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。

- sticky

  sticky 定位即粘性定位，可以简单地认为是相对定位和固定定位的混合，元素在跨越特定阈值(top、left、right、bottom 所确定的值)前为相对定位(滚动时位置可变化, 直到达到阈值，margin 也无效)，之后为相对于最近的块级祖先的固定定位。
  粘性定位的效果如下:

    <center><img src="https://i.imgur.com/o9ibM8U.gif" width="500" /></center>

  上图中，导航栏设置为粘性定位:

  ```
    height: 50px;
    background: deepskyblue;
    position: sticky;
    top: 0;
  ```

  可以看到导航栏距离上边框为 0(阈值)时就不再继续向上滚动，即导航栏在距上边框的距离大于 0 时可以认为此时的 position 为 relative 且 top 的最小值为 0，当导航栏距上边框的达到 0 时，可以认为 position 的值为 fixed 且此时相对于父级元素的 top 为 0。
  利用 sticky 还能实现层次滚动:

  ```
  <style>
    #root {
      overflow: auto;
      max-height: 200px;
      border: 1px solid;
    }
    dt {
      position: sticky;
      top: -1px;
      padding: 2px 0 0 12px;
      background: deepskyblue;
    }

  dd {
  margin: 0;
  padding: 0 0 0 12px;
  }

  </style>
  <body>
    <div id="root">
      <dl>
        <dt>A</dt>
        <dd>A1</dd>
        <dd>A2</dd>
        <dd>A3</dd>
        <dd>A4</dd>
        <dd>A5</dd>
        <dd>A6</dd>
      </dl>
      <dl>
        <dt>B</dt>
        <dd>B1</dd>
        <dd>B2</dd>
        <dd>B3</dd>
        <dd>B4</dd>
        <dd>B5</dd>
        <dd>B6</dd>
      </dl>
      <dl>
        <dt>C</dt>
        <dd>C1</dd>
        <dd>C2</dd>
        <dd>C3</dd>
        <dd>C4</dd>
        <dd>C5</dd>
        <dd>C6</dd>
      </dl>
    </div>
  ```

  效果如下:

  <center><img src="https://i.imgur.com/ToJToYb.gif" width="500" /></center>

- initial
  设置默认值，可作用于任何 CSS 样式(IE 不支持该关键字)。
- inherit
  继承父类的 postion 值，不会继承其 left、top、right 及 bottom 值。
- unset
  initial 和 inherit 的结合，当该属性是默认继承属性时等同于 inherit；当该属性是非继承属性时等同于 initial。

**30、** 内联元素和块级元素的区别

**内联元素**

- 和相邻的内联元素在同一行
- 设置 width 和 height 无效
- margin 上下无效，padding 上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样

**块级元素**

- 块级元素总是各占一行，垂直排列
- 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置

内联元素可以通过该变 display 属性进行转换，

- `display:block`: 表现形式如块级元素
- `display:inline`: 表现形式如内联元素
- `display:inline-block`: 表现形式如内联元素和块级元素，具有 block 元素可以设置宽高的特性，同时又具有内联元素的不换行等特性

**31、** js 判断一个变量是否是数组

```
fuction isArray(obj) {
  Object.prototype.toString().call(obj) === "[object Array]";
}
现代浏览器
Array.isArray(obj)
```

**32、** JavaScript 由哪三部分构成

- 核心(ECMAScript)
  ECMAScript 仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准
- 文档对模型(DOM)
  它是 HTML 和 XML 的应用程序接口，DOM 将整个页面规划成由节点层级构成的文档，HTML 或 XML 页面的每个部分都是一个节点的衍生物
- 浏览器对象模型(BOM)
  它提供了一种特性，可以对浏览器窗口进行访问和操作，使用 BOM 开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。

**33、** sql 的注入原理及防范方法

通常服务器端都会根据客户端的请求来动态构建 sql 执行语句，sql 注入是通过将恶意的 sql 语句添加到应用的输入参数中，从而在 sql 服务器后台解析执行。
防范方法:

- sql 语句预编译和绑定变量
  sql 执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。
- 严格检查参数
  只执行规定格式的参数可以避免部分的 sql 注入
- 使用安全函数
  安全函数将参数的特殊字符进行编码，这样 sql 引擎就不会将参数当成 sql 语句进行解析了。

**34、** JavaScript 的垃圾回收机制

JavaScript 有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。
内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。

- 引用计数法
  在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象引用另一个对象。当对象被引用的次数为 0 时就被回收。
  ```
  var a = { v: 1 }; // 对象{ v: 1 }被变量a引用一次，引用计数为1
  var b = a; // 同样，对象{ v: 1 }被变量b引用一次，引用计数为2
  a = null; // 对象引用次数减1
  b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放
  ```
  引用计数有一个潜在的问题，就是无法解决循环引用的问题。
  如下，a、b 互相引用，引用计数一直为 1，导致不能自动回收。
  ```
    function f() {
      var a = {};
      var b = {};
      a.value = b;
      b.value = a;
    }
    f();
  ```
- 标记清除算法

  这个算法假定有一个叫跟(root)的对象(js 中为 window， node js 为 global)，垃圾回收器定期从根开始，寻找所有从根开始引用的对象，然后找这些引用对象引用的对象...将这些对象标记为 active，其他的不能被根引用或间接引用的将被标记为 garbage，最终将这些垃圾清除。
  循环引用将不再是问题，上例中函数 f 执行完后，对象 a 和 b 从全局对象出发就无法访问到了(执行栈弹出，与全局对象的链接断开)，因此对象 a、b 将会被回收。

 <center><img alt="标记清除意图" src="https://i.imgur.com/N9bb66Q.gif" width="500" /></center>

**35、** JavaScript 中 var 和 let 去区别

let 为 ES6 新增的命令，用来声明变量，用法与 var 类似，其区别如下:

- 有效范围
  在 ES6 之前，JS 函数只有函数作用域和全局作用域，没有块级作用域，所以`{}`不能限制 var 所声明的变量的访问范围，而 let 声明的变量只在 let 声明时的代码块内有效。

  ```
  {
    let a = 1;
    var b = 2;
  }

  a // ReferenceError: a is not defined.
  b // 2
  ```

- 变量提升
  let 不存在变量提升，var 存在变量提升

  ```
    console.log(a); // undefined
    var a = 1;

    console.log(b); // Uncaught ReferenceError
    let b = 2;
  ```

- 重复声明
  let 不能重复声明，var 可以重复声明

  ```
    var a = 1;
    var a = 2;

    let b = 1;
    let b = 2; //Identifier 'b' has already been declared
  ```

- 暂时性死区
  let 有暂时性死区约束，如下在全局声明了变量 a，又在块级作用域用 let 声明了 a，ES6 明确规定，如果块级作用域内存在 let 或 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。凡是在声明之前使用这些变量，就会报错，这在语法上称为暂时性死区。
  ```
  var a = 1;
  if (true) {
    a = 2;// ReferenceError
    let a;
  }
  ```

**36、** Doctype 作用？标准模式与兼容模式各有什么区别?

- 作用
  `<!DOCTYPE>`声明位于 HTML 文档的第一行，处于`<html>`标签之前。用于告诉浏览器以什么文档标准来解析这个文档，DOCTYPE 不存在或格式错误会导致浏览器用兼容模式来解析文档。
- 区别
  标准模式是以浏览器支持的最高标准来运行，兼容模式中页面以宽松的向后兼容的模式进行显示，以防止老式浏览器无法正常工作。

**37、** HTML5 为什么只需要写`<!DOCTYPE HTML>`？

HTML5 不是基于标准通用标记语言 SGML(Standard Generalized Markup Language)的，因此不需要对文档类型定义 DTD(Document Type Definition)进行引用，但是需要 Doctype 来规范浏览器的行为(让浏览器按照他们应该的方式来运行)。HTML4.01 是基于 SGML 的，因此需要对 DTD 进行引用，才能告知浏览器所使用的文档类型。

**38、** 介绍一下你对浏览器内核的理解。

主要分为两部分，渲染引擎和 JS 引擎。

- 渲染引擎
  主要负责获取网页内容(HTML、XML、图像等)、整理信息(CSS 等)以及计算网页的显示方式，然后输出至显示器或打印机。不同的浏览器内核对网页的解释不同，所渲染出的网页效果也就不一样。
- JS 引擎
  解析和执行 javascript 来实现网页的动态效果。
  最初渲染引擎和 JS 引擎并没有区分地很明确，后来 JS 引擎越来越独立，内核就倾向于指渲染引擎。

**39、** 简述一下你对 HTML 语义化的理解。

用正确的标签做正确的事情。

- html 语义化使页面结构更加清晰，便于对浏览器搜索引擎解析。
- 在没有 CSS 的情况下也以一种文档格式显示。
- 搜索引擎的爬虫也依赖于 HTML 的标签来确定上下文和各个关键字的权重，利于 SEO。
- 有利于阅读代码的人理解网站的分块。

**40、** iframe 有哪些优缺点？
优点:

- 用来实现长连接(轮询隐藏的 iframe 得到数据)，在 websocket 不可用的时候作为一种替代。
- 跨域通信。
- 无刷新上传文件，在 FormData 不可用时作为替代方案。
- 创建一个全新的独立的宿主环境。

缺点:

- 搜索引擎的爬虫还不能很好的处理 iframe 的内容，不利于 SEO。
- iframe 会阻塞页面的加载，onload 事件不能及时触发(动态的给 iframe 添加 src 值可
  解决) 。
- iframe 和主页面共享连接池，而浏览器对同域的连接有限制，所以会影响页面的并行
  加载(动态的给 iframe 添加 src 值可解决)。
- 样式和脚本需要额外链入，增加服务器的 http 请求。
- 多数小型的移动设备无法完全显示框架。
- 浏览器的后退按钮无效。

**41、** label 的作用是什么？是怎么用的？
label 标签用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转移到和该标签相关联的表单控件上。
如下: 通过将 label 标签的属性 for 的值设置为 input 的 id 就可以将 label 和 input 关联起来，点击 label 时就可以选中 radio 类型的表单了。

```
  <div>
    <label for="Name">Number:</label>
    <input type="radio" id="Name"/>
  </div>
```

**42、** 如何实现浏览器内多个标签页之间的通信? (阿里)

- WebSocket
- SharedWorker
- localstorage、cookies 等本地存储方式

**43、** webSocket 如何兼容低浏览器？(阿里)

- Adobe Flash Socket
- ActiveX HTMLFile(IE)
- 基于 mutipart 编码发送 XHR
- 基于长轮询的 XHR

**44、** 页面可见性 Page Visibility API 可以有哪些用途？

在 web 页面的开发中，如何判断用户是不是还在与页面交互是一个重要的问题，比如页面最小化了或隐藏在其他标签页后面，这时我们就可以做关闭页面正在播放的音乐或其他什么事情。
Page Visibility API 由三部分构造:

- document.hidden: 表示页面是否隐藏的布尔值
- document.visibilityState: 有 4 个可能的状态值
  - hidden: 页面在后台标签页或浏览器最小化，此时页面对用户不可见
  - visible: 页面在前台标签页，此时页面至少有部分是可见的
  - prerender: 页面正在进行预渲染处理，文档只能从这个状态开始，不可能由其它状态变为这个状态，此时
    document.hidden 为 true，
  - unloaded: 页面从内存中卸载清除
- visibilitychange 事件: document.visibilityState 状态发生变化时触发

```
  document.addEventListener('visibilitychange', () => {
    console.log(document.visibilityState);
  })
```

**45、** 网页验证码是干嘛的，是为了解决什么安全问题。

为了区分用户是机器还是人，验证码对于人而言很容易识别，对于计算机则难以识别，这可以防止恶意的破解密码、刷票、论坛灌水或者利用特定的程序暴力破解方式进行不断的登录尝试。

**46、** title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？

- title vs h1
  title 是关于元素的额外信息，当鼠标移动元素上时显示一段提示文本，而 h1 表示层次明确的标题，对页面信息的抓取也有很大影响。

- b vs strong
  b 表示粗体文本，并没有明确的语义，而 strong 表示强调，有语气加强的含义，使用阅读设备阅读时`<strong>`会重读。

- i vs em
  i 表示斜体，em 表示强调的内容。

以上主要是自然样式标签和语义样式标签的差别，应该多用语义样式标签，但不能滥用。

- 自然样式标签
  ```
  b, i, u, s, pre
  ```
- 语义样式标签
  ```
  strong, em, ins, del, code
  ```

**47、** CSS 选择符有哪些？哪些属性可以继承？哪些属性不可以继承？CSS3 新增伪类有哪些？

**CSS 选择符**

- id 选中器(# id)
- 类选择器(. class)
- 标签选择器(div、p)
- 相邻元素选择器(E + F)
- 子元素选择器(E > F)
- 后代元素选择器(E F)
- 属性选择器([attribute])
- 伪类选择器(E:)
- 通配符选择器(\*)

**可继承属性**

- color
- text-align、text-indent、text-transform
- font、font-family、font-size、font-style、font-weight
- line-height
- cursor
- visibility
- word-spacing
  ...

**不可继承属性**

- display
- margin
- padding
- border
- position
- z-index
- background-color
- height、min-height、max-height
- width、min-width、max-width
- left、top、right、bottom
  ...

**新增伪类**

- :enabled
- :disabled
- :checked
- :only-child
- :nth-child(n)
- :first-of-type
- :last-of-type
  ...

**48、** display 有哪些值？说明他们的作用。

- none: 元素不显示，并从文档流中移除
- inline: 显示为行内元素类型，同行显示，宽高不能设置
- block: 显示为块级元素类型，换行显示，可设置宽高，默认宽度为父元素宽度
- inline-block: 显示为行内块级元素类型，同行显示，可以设置宽高
- list-item: 像块级元素一样显示并添加列表标记
- table: 像 table 一样显示
- inherit: 从父元素继承 display 属性值

**49、** css 多列等高(高度不固定)如何实现？
**padding 补偿法**
如下: 父容器(container)的高度是由子元素 div 中高的那一列(叫做 higher)决定的，而子元素的高度由内容、边框、内边距、外边距的高度共同决定的，当设置子元素的底内边距 padding-bottom 和底外边距为相等的正负值后，高度相抵为 0，此时父容器的高度由 higher 的内容和边框决定，当 higher 的高度增加时父容器的高度也跟着增加，子元素中较矮的那列则会用 padding-bottom 来补偿这部分高度差(因为 padding 足够大)，再设置父容器 overflow: hidden 则可以正好截取 higher 的高度进行显示，表面看上去就是两列等高。

```
  <style>
    .container {
      overflow: hidden;
    }
    .div1 {
      float: left;
      width: 200px;
      background: blue;
      padding-bottom: 2000px;
      margin-bottom: -2000px;
    }
    .div2 {
      float: left;
      width: 200px;
      background: red;
      padding-bottom: 2000px;
      margin-bottom: -2000px;
    }
  </style>
  <div class="container">
    <div1 class="div1">
    Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.
    </div1>
    <div2 class="div2">
    Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues. Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.
    </div2>
  </Box>
```

 <center><img src="https://i.imgur.com/TjtJBLS.png" /></center>

**50、** li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？

由于浏览器默认会把行内元素间的空白字符(空格、换行、tab)渲染为一个空格，因此 li 之间就产生了空白间隔。
解决方法是书写 li 时写为一行或设置 font-size 为 0。

**51、** 为什么要初始化 CSS 样式。

因为浏览器兼容问题，不同的浏览器对有些标签的默认值是不一致的，如果没有初始化可能导致浏览器渲染的结果差异，但是初始化样式对 SEO 有一定影响，力求影响最小的情况下初始化。

**52、** CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？

对普通元素设置 visibility: collapse 后这个元素会完全隐藏，但会占据局部空间，与 visibility: hidden 的效果一样，相当于此元素透明，如果元素为 table，collapse 会让 table 会隐藏但不会占据局部空间。
不同浏览器不同版本的表现并不一致，不建议使用。

**53、** 请解释一下为什么需要清除浮动，清除浮动的方式？

清除浮动是为了清除使用浮动元素带来的影响，浮动的元素高度会塌陷，而高度的塌陷使我们后面的布局不能正常显示。
清除浮动的方式:

- 利用 clear 属性

  如下，设置 box 的 clear 的属性为 left 或 both 即可消除兄弟元素浮动的影响，clear 的本质是添加外边距。

  ```
    <style>
      .float-left {
        float: left;
        width: 200px;
        height: 100px;
        background: blue;
      }
      .box {
        width: 200px;
        height: 100px;
        background: gray;
        clear: both;
      }
    </style>

    <div>
      <div class="float-left" />
      <div class="box" />
    </div>
  ```

- 添加空块级元素
  如下，在浮动元素后添加空块级元素 div，并设置其 clear 属性为 both 或 left 即可以清除浮动。

  ```
    <style>
      .clear {
        clear: both;
      }
    </style>
    <div>
      <div class="float-left" />
      <div class="clear"/>
      <div class="box" />
    </div>
  ```

- 伪元素::after 和::before(作用于浮动元素的父类)

  ```
    <style>
      .float-father {
        &::after {
          content: "";
          display: block;
          clear: both;
        }
      }
    </style>
    <div>
      <div class="float-father">
        <div class="float-left" />
      </div>
      <div class="box" />
    </div>
  ```

- overflow 的方法(作用于浮动元素的父类)
  设置浮动元素父类的 overflow 为 auto 或 hidden 即可清除浮动，该方法是利用 BFC 的特性达到的效果，这与前述几种方法通过设置 clear 属性的本质是不一样的。
  ```
    <style>
      .float-father {
        overflow: auto;
      }
    </style>
    <div>
      <div class="float-father">
        <div class="float-left" />
      </div>
      <div class="box" />
    </div>
  ```

**53、** 浏览器是怎样解析 CSS 选择器的？

样式系统从关键选择器开始匹配，然后从右向左查找选择器的的祖先祖先元素，如果匹配，则继续左移查询父元素，不匹配则放弃查找，相比从左到右的正向查找效率大大提高。

**54、** 在网页中的应该使用奇数还是偶数的字体，为什么呢？
使用偶数字体更好，主要原因如下:

- 比例关系
  相对来说偶数字号容易和 web 页面的其他部分构成比例关系，如使用 14 号为正文字号，使用 14 _ 0.5 = 7px 作为 margin，14 _ 1.5 = 21px 作为标题。
- ie6 中会把 13px 的字号渲染为 14px
- 汉字更均衡
  比如 14 号的汉字，会去掉 1px 的间距，字体的实际宽度就是 13px，这样汉字的中竖线正好平分汉字，使汉字显得更加均衡。

**55、** 元素竖向的百分比设定是相对于容器的高度吗？

高度是相对于父容器高度，padding-top,padding-bottom,margin-top,margin-bottom 是相对于父容器宽度。

**56、** 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？

响应式设计就是根据设备环境(系统平台、屏幕尺寸)来进行相应的响应和调整。其主要原理就是通过媒体查询来适配不同环境下的 UI，对于低版本 IE 来说不能使用媒体查询，则可以通过监听 window resize 事件添加新的类来实现 PC 端的响应式布局，此外还可以通过 Respond.js 来实现媒体查询。

**57、** 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）

多数显示器的默认频率是 60Hz，即一秒钟刷新 60 次，因此理论上动画最小时间间隔是 1 / 60 \* 1000ms = 16.7ms。

**58、** overflow: scroll 时不能平滑滚动的问题怎么处理

开启硬件加速，-webkit-overflow-scrolling: touch

**59、** png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？

- png(Portable Network Graphics)
  直译就是便携式网络图片，简称 PNG，是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。PNG 的开发目标是改善并取代 GIF 作为适合网络传输的格式而不需要专利许可。
  特性

  - 支持 256 色调色板技术以产生小体积文件
  - 支持最高 24 位真彩色图像以及 8 位灰度图像
  - 支持 Alpha 通道的透明/与半透明特性
  - 支持无损压缩
  - 支持存储附加信息，以保留图像名称、作者等信息
  - 支持图像亮度的 Gamma 校准信息
  - 渐进显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌
    ...

- jpg(Joint Photographic Experts Group)

  jpg 即 jpeg，由于早期的 DOS、Windows95 只支持最长 3 字符的扩展名，为了兼容采用了.jpg，一直沿用到今天，JPEG 是一种针对照片视频而广泛使用的有损压缩标准方法。支持 24 位真彩色，颜色丰富并且适合那些允许轻微失真的像素色彩丰富的图片(相片)不支持动画，不支持透明色，不适合 logo 和线条。

- gif(Graphics Interchange Format)

  是一种位图图形文件格式，它采用无损压缩技术，无论是动画还是静止图像，你会发现 GIF 图的色彩明显不如拍的真实照片那么丰富。这是因为，真彩色至少需要 24 位（RGB 各 8 位）才能表示，而 GIF 图的每个像素一共只有 8 位，只能表示区区 256 种颜色。 这 256 种颜色可以从整个 RGB 颜色空间中任选，它们构成一个调色板。GIF 的每个像素便是这个调色板（即颜色表）的索引。GIF 允许为它里面的每一张图片指定不同的调色板，但每一帧的颜色数仍然受限于 256。 正是因为这个限制，GIF 只适合那些不需要那么多种颜色的场合。图标、数据图表、漫画、灰度图等，都属于 GIF 的适用范围。GIF 图片拥有透明度(透明或不透明，并没有 alpha 通道)。

- webp

  是一种同时提供了有损压缩和无损压缩(可逆压缩)的图片文件格式。它的优势在于拥有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，此外它还具备 Alpha 透明以及动画特性。

**60、** style 标签写在 body 后与 body 前有什么区别？

写在 body 前有利于浏览器逐步渲染(resources download=>CSSOM+DOM=>RenderTree=>Layout=>Paint)，写在 body 标签后由于浏览器逐行方式对 html 文档进行解析，当解析到写在尾部的样式表时会导致浏览器停止之前的渲染，等待加载且解析样式表完成后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象(即样式失效导致的页面闪烁问题)。

**61、** 什么是 CSS 预处理器 / 后处理器？

- 预处理器
  CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加一些编程的特性，并将 CSS 作为目标生成文件。比如 LESS、Sass、Stylus 等用来预编译 CSS，他们具有层级、mixin、变量、循环、函数等特性，极大的提高了 UI 开发效率。

- 后处理器
  对 CSS 进行处理，属于广义上的 CSS 预处理器，我们很久以前就在用预处理器了，最典型的例子就是 CSS 压缩工具 clean-css，目前最常用的后处理器就是 PostCSS，用来在完成的样式表中根据 CSS 规范处理 CSS，如给 CSS 属性添加浏览器私有前缀，实现各个浏览器的兼容。

**62、** 什么是 Cookie 隔离？

cookie 隔离就是在 http 请求的时候不带 cookie，如果静态文件都放在主域名下，那么在静态文件请求时都会把带有 cookie 的请求提交给 server，非常浪费资源，所以不如隔离开。
因为 cookie 有域的限制，因此不能跨域请求，因此使用非主域名的时候，请求头中就不会带有 cookie，这样就可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

**63、** 什么是严格模式？

严格模式是 ES5 中添加的一种运行模式，这种模式使 Javascript 在更严格的条件下运行。不支持严格模式与支持严格模式的浏览器在执行严格模式代码时会采用不同的行为。

严格模式对正常的 JS 语义作了一些修改。

- 严格模式通过抛出错误来消除一些原有的静默错误。
- 严格模式修复了一些导致 JS 引擎难以优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
- 严格模式禁用了 ECMAScript 的未来版本可能定义的一些语法。
  严格模式通过在语句前添加'use strict'来开启。

**64、** CSS3 有哪些新特性？

- 新增多种选择器
- 圆角(border-radius)
- 多列布局(multi-column layout)
- 文字特效(text-shadow)
- 线性渐变(gradient)
- 2D 转换(translate、rotate、scale、skew)
- 过渡(transition)
  ...

**65、** ["1", "2", "3"].map(parseInt) 答案是多少？
parseInt 函数解析一个字符串参数，并返回一个指定基数的十进制整数或 NaN。

```
/*
  string: 要被解析的字值，如果不是字符串则转换为字符串，字符串开头的空白符将会被忽略
  radix: 一个介于2-36的整数(或0)，表示一个参数string的基数。比如radix为2，表示第一个参数string为2进制数，当未指定基数或基
         数为0时，会根据string来判断数字的基数(0x开头基数为16，0开头基数为8或10，具体由浏览器决定，其他的默认值为10，因此最好显示给定基数)。
  返回值: 返回解析后的10进制整数值，解析错误则返回NaN。主要包含以下三种情况：
         1. 被解析参数的第一个字符无法被转化成数值类型
         2. 被解析的参数不是radix进制下的合法数字
         3. radix不在[2, 36]范围内，或者不等于0
*/
parseInt(string, radix);
```

["1", "2", "3"].map(parseInt)等价于["1", "2", "3"].map((v, index)=> parseInt(v, index))，即

```
  => parseInt("1", 0) //默认基数为10，因此返回1
  => parseInt("2", 1) //不在[2, 36]范围内，返回NaN
  => parseInt("3", 2) //基数为2，则任务"3"是2进制数，不合法，返回NaN
```

**65、** IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？
如下，inner 和 outer 都绑定单击事件，当点击 inner 时，事件应如何传递呢，是 inner 先触发单击事件，还是 outer 先触发？

```
<div id="outer">
  <span id="inner">
    Click
  </span>
</div>
```

**事件冒泡和事件捕获**

- 事件冒泡
  IE 的事件机制就是事件冒泡，事件冒泡，如同将石头丢入水底，泡泡会从水底，逐渐向上，直到水面，消失。也就是说事件会从最内层元素触发，并向上传播，直到 document 对象。
  因此，IE 事件机制处理上述的例子中 span 元素的单击事件顺序为: span=>div>body=>html=>document
- 事件捕获
  事件捕获是网景提出来的事件流，它和事件冒泡正好相反，事件会从最外层元素开始触发，直到具体的元素。
  因此，事件捕获机制处理上述的例子中 span 元素的单击事件顺序为: document=>html=>body=>div=>span
  火狐支持事件冒泡和事件捕获。

**addEventListener 函数**

W3C 折中了事件冒泡和事件捕获，制定了先捕获后冒泡的标准，addEventListener 的第三个参数决定了事件是在捕获阶段还是在冒泡阶段触发。

```
/*
  event: 事件名
  function: 触发事件时执行的函数
  useCapture: 默认值为false，指定事件是在捕获阶段还是在冒泡阶段触发
*/
element.addEventListener(event, function, useCapture)
```

**实例**

冒泡阶段触发:

```
  //点击span，输出innner，再输出outer
  <div id="outer">
    <span id="inner">
      Click
    </span>
  </div>
  <script>
    const outer = document.getElementById("outer");
    outer.addEventListener("click", (e) => console.log("outer"));
    const innner = document.getElementById("innner");
    innner.addEventListener("click", (e) => console.log("innner"));
  </script>
```

捕获阶段触发:

```
  //点击span，输出outer，再输出innner
  <div id="outer">
    <span id="inner">
      Click
    </span>
  </div>
  <script>
    const outer = document.getElementById("outer");
    outer.addEventListener("click", (e) => console.log("outer"), true);
    const innner = document.getElementById("innner");
    innner.addEventListener("click", (e) => console.log("innner")，true);
  </script>
```

如果元素同时绑定了捕获和冒泡阶段的事件，则先响应捕获阶段的事件，再响应冒泡阶段的事件。

阻止冒泡:
通过 e.stopPropagation 函数来阻止事件传播。

```
  //点击span，只输出outer，
  <div id="outer">
    <span id="inner">
      Click
    </span>
  </div>
  <script>
    const outer = document.getElementById("outer");
    outer.addEventListener("click", (e) => {
      e.stopPropagation();
      console.log("outer"), true);
    }
    const innner = document.getElementById("innner");
    innner.addEventListener("click", (e) => console.log("innner")，true);
  </script>
```

**66、** Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

hasOwnProperty，返回一个对象是否具有指定名称的属性。使用方法如下

```
/*
  proName: 属性名
  返回值: bool值
*/
object.hasOwnProperty(proName)
```

**67、** JSON 的了解？
JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，它是 JavaScript 的一个子集。数据格式简单，易于读写，占用宽带小。如{ "name": "xinghunm", "age": 18 }。

JSON 有两种表示结构对象和数组

- 对象
  对象以左大括号`{`开始，以右大括号`}`结束，括号间由 key-value 的键值对组成，键值对间由逗号','分割，最后一个键值对需要省略逗号，键值对的 key 为字符串，值可以是字符串、数值、对象、布尔值、数组以及 null。

  ```
    {
      "name": "xinghunm",
      "age": 18
    }
  ```

- 数组
  数组以左中括号`[`开始，以右中括号`]`结束，中间由逗号分割的多个键值对列表组成。
  ```
    [
      {
        "name": "xinghunm",
        "age": 18
      },
      {
        "name": "snow",
        "age": 18
      }
    ]
  ```

JSON 对象提供了字符串、对象相互转换的接口

- 字符串转 json 对象

```
  const obj = JSON.parse(str)
```

- 对象转 JSON 字符串

```
  const jsonStr = JSON.Stringify(obj)
```

**68、** js 延迟加载的方式有哪些？

- defer
  在`<script>`元素中设置 defer 属性，相当于告诉浏览器立即下载脚本，但延迟执行。脚本会在页面加载解析完成后，触发 DOMContentLoaded 事件前执行，defer 属性基本能保证脚本按着加载的顺序执行。对内联脚本不起作用。
  ```
    <script src="bundle.js" defer></script>
  ```
- async
  使脚本在下载完成后立即执行，async 属性使脚本以乱序执行为主，不一定是在 DOMContentLoaded 前执行。对内联脚本不起作用。
  ```
    <script src="bundle.js" defer></script>
  ```
- 动态创建 DOM

  ```
  function loadJS() {
      var el = document.createElement('script');
      el.src = 'http://localhost:8000/package.json';
      document.body.appendChild(el);
      //chrome,Firefox不支持onreadystatechange
      el.onload = el.onreadystatechange = () => {
          if (!this.readyState ||
          this.readyState == "loaded" ||
          this.readyState == "complete")) {
          console.log('load script success');
          el.onload = el.onreadystatechange = null;
          document.body.removeChild(s);
        }
      };
      el.onerror = () => {
        alert('error');
      };
    }
    window.addEventListener('load', loadJS);
  ```

**69、** requireJS 的核心原理是什么？

requireJS 是基于 AMD 模块加载规范，使用回调函数来解决模块加载的问题。

- 核心原理
  通过创建 script 标签，给标签设置 src 属性来实现模块加载的。
- 避免二次加载
  模块定义了一个 function，这个 function 实际是一个 factory(工厂模式)，这个 factory 在需要(require("xxx"))的时候才有可能被调用，如果检查到已经调用过，生成了模块实例，则直接返回实例而不再调用工厂方法。
- 缓存
  - 第一次加载模块时，会缓存该模块，以后再加载该模块，就直接从缓存中取出该模块的 module.exports 属性(不会再次执行该模块)。
  - 如果需要多次执行模块中的代码，一般可以让模块暴露函数
  - 模块的缓存可以通过 require.cache 拿到，同样也可以删除

**70、** document.write 和 innerHTML 的区别？

document.write 是直接写入到页面的内容流，如果在写之前没有调用 document.open，浏览器会自动调用 open。每次写完毕之后重新调用该函数，会导致页面被重写。
innerHTML 则是 DOM 页面元素的一个属性，代表该元素的 html 内容。可以对一个具体的元素进行修改，而不用刷新页面。

**71、** DOM 操作——怎样添加、移除、移动、复制、创建和查找节点?

- 创建节点
  - createDocumentFragment()
    创建文档片段节点，文档片段不是实际的 DOM 结构，它是一个虚拟的 dom 节点，存在于内存中，所以对片段的更改不会影响文档，也就不会重新渲染文档。
    DocumentFragment 一个常见的用途是将 dom 子树封装在里面，并通过 appendChild 等方法将该片段插入的 DOM 中，这样片段中的节点就会移动到 DOM 中，而留下空白的 DocumentFragment 文档片段。因为所有的节点被一次性插入 DOM 中，只会触发一次渲染，提高了性能。
    ```
      var frag = document.createDocumentFragment();
      for(let i = 0;i < 100;i++) {
        const el =document.createElement("div");
        //操作片段的修改不会触发渲染
        frag.appendChild(el);
      }
      document.body.appendChild(frag);
    ```
  - createElement(tagName)
    创建标签名为 tagName 的节点
    ```
      var el = document.createElement("div");
    ```
  - createTextNode(text)
    创建包含文本 text 的文本节点
    ```
      document.createTextNode("text node");
    ```
  - createAttribute(name)
    创建属性节点
    ```
      function setAttr() {
        var node = document.getElementById('root');
        var attr = document.createAttribute("属性名");
        attr.nodeValue = "属性值";
        node.setAttributeNode(attr);
      }
      等同于
      function setAttr() {
        var node = document.getElementById('root');
        node.setAttribute("属性名", "属性值");
      }
    ```
- 操纵节点

  - 添加节点

    1. Node.appendChild(element)
       该方法将一个节点添加到指定父节点的子节点列表末尾。

    ```
      document.body.appendChild(element);
    ```

    1. Node.insertBefore(newNode, referenceNode)
       该方法在参考节点之前插入一个拥有指定父节点的子节点。

    ```
      html:
      <div id="root">
        <div id="div1">
      <div>

      const newNode = document.createElement('div');
      const parentNode = document.getElementById('root');
      const referenceNode = document.getElementById('div1');
      parentNode.insertBefore(newNode, referenceNode);
    ```

  - 删除节点
    Node.removeChild(child)方法从 DOM 中删除一个子节点，并返回删除的节点。
    ```
    const node = document.getElementById("app");
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
    ```
  - 替换节点
    用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。
    ```
      const replacedNode = parentNode.replaceChild(newChild, oldChild);
    ```
  - 复制节点
    Node.cloneNode() 方法返回调用该方法的节点的一个副本。
    ```
      /*
        deep: 可选，是否采用深度克隆(如果为true该节点所有后代节点也会被克隆，如果为false只克隆该节点本身)
      */
      const dupNode = node.cloneNode(deep);
    ```

- 查找节点
  - getElementById(id)
    返回一个匹配特定 ID 的元素。
    ```
      /*
      1. 如果当前文档中拥有特定ID的元素不存在则返回null.
      2. id是大小写敏感的字符串，代表了所要查找的元素的唯一ID.
      */
      var element = document.getElementById(id);
    ```
  - getElementsByTagName(tagName)
    通过标签名查找，返回一个动态的包含所有指定标签名的元素的 HTML 集合 HTMLCollection。
    ```
      //搜索从element开始。请注意只有element的后代元素会被搜索，不包括元素自己。
      var elements = element.getElementsByTagName(tagName)
    ```
  - getElementsByName()
    根据给定的 name 返回一个在(X)HTML document 的节点列表集合。
    ```
      //name是元素的name属性的值。
      var elements = document.getElementsByName(name)
    ```

**72、** 移动端最小触控区域是多大?

苹果最初把 44x44 像素定为触控控件最小的尺寸，原因是在 iphone3 的分辨率下，44x44pixels 对应人类食指指尖的平均大小--7x7 毫米(拇指为 9 毫米)，但是随着分辨率的提高，44x44pixels 已经达不到 7 毫米了，当然可以通过换算得到目标设备的最小触控像素。

**73、** 移动端的点击事件的延迟，时间是多久，为什么会有？ 怎么解决这个延时？

点击延迟有 300ms，这个延迟是由历史原因造成的，最初在 iOS 自带的浏览器 safari 上有双击缩放的功能，为了判断用户是否是双击事件
(点击到链接，如果立即响应则会错误跳转)而设置了 Safari 等待 300ms。后来鉴于 iPhone 的成功，各家浏览器也实现了这个功能。
解决方案

- CSS touch-action
  这个属性指定了相应元素上能够触发的用户代理，也就是浏览器的默认行为。如果将该属性值设置为 none，则表示在该元素上的操作不会触发用户代理的任何默认行为，也就无需进行 300ms 的延迟判断。
- FastClick
  FastClick 是一个是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是在检测到 touchend 事件的时通过 DOM 自定义事件立即触发一个模拟的 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。

**74、** 什么是 Polyfill？

Polyfill 是英国 Web 开发者[Remy Sharp](https://remysharp.com/)想出来的名词，来源于英国的一个家装产品 Polyfilla(刮墙的,在中国称为腻子)，可以磨平墙上的裂缝。Remy Sharp 以此来表达用于实现一些浏览器不支持的原生 API 的代码。比如有些浏览器不支持 Array.isArray 函数，为了让这些浏览器可以支持这个 api，我们就可以实现如下 polyfill:

```
  if(!Array.isArray) {
    Array.isArray = function(obj) {
      return Object.prototype.toString().call(obj) === "[object Array]";
    }
  }
```

**75、** 实现一个模块加载器

```
var MyModules = (function Manager() {
	var modules = {};

	function define(name, deps, impl) {
		for (var i=0; i<deps.length; i++) {
			deps[i] = modules[deps[i]];
		}
		modules[name] = impl.apply( impl, deps );
	}

	function get(name) {
		return modules[name];
	}

	return {
		define: define,
		get: get
	};
})();
```

这段代码的关键是 `modules[name] = impl.apply(impl, deps)`。调用`impl.apply(impl, deps)`使得在 impl 函数内部能够访问到这些依赖 deps，因而 impl 函数内部返回的对象(通过`modules[name] = xxx`赋值给了特定的 module)同样能够访问到这些依赖，形成了闭包，最终对于特定的某块就可以访问到它们所有的依赖。

定义一个模块:

```
MyModules.define( "person", [], function(){
	function getName(name) {
		return "I am" + name;
	}

	return {
		getName
	};
} );

MyModules.define( "girl", ["person"], function(person){
	var name = "lily";

	function getMyName() {
		console.log(person.getName(name));
	}

	return {
		getMyName
	};
});

var p = MyModules.get( "person" );
var girl = MyModules.get( "girl" );

p.getName("lucy"); // I am lucy
girl.getMyName(); // I am lily
```

**76、 移动浏览器中，触摸一下屏幕会依次触发哪些事件？**

- touchstart
  手指触摸到屏幕时触发
- touchmove
  手指在屏幕上移动时触发
- touchend
  手指离开屏幕时触发
- touchcancel
  由系统触发，比如弹框

**77、cookie、session 分别用来做什么的，有什么关系**

由于 http 协议是无状态的，所以我们需要某种机制来存储状态，客户端和服务端可以分别采用 cookie 和 session 来保存状态。在服务端创建会话 session 时，服务端会在 http 协议中告诉客户端，需要在 cookie 里记录一个 Session ID，客户端在请求时每次都会通过 cookie 把这个 Session ID 传送给服务端，服务端通过该 ID 就能得到当前会话的信息了。
区别:

- cookie 用来在客户端储存信息，而 session 用来在服务端存储信息，都可用于跟踪用户状态。
- session 存储在服务端，相对更安全，用户验证等重要信息一般存放于 session，但 cookie 也也可以加密来提高安全性。
- cookie 在主动删除前会永久保存，最大一般为 4kb，session 在会话期间保存。
- session 的实现需要 cookie 的支持，session 依赖于 session ID 实现，而 session ID 存放于 cookie 中，因此，禁用 cookie 之后，session 也失效。但可以使用其他方法实现，比如在 URL 中传递 session ID。
- session 在服务端可能存储在内存、数据库、文件等。
- session 支持各种类型的对象，cookie 只保存字符串。

**78、TCP 中的三次握手和四次挥手**

**三次握手**
TCP 提供面向有连接的通信传输，面向有连接是指数据通信开始之前先做好两端的准备工作。所谓三次握手是指建立一个 TCP 连接时需要客户端和服务端总共发送三个包以确认连接的建立。在 socket 编程中，这一过程由客户端执行 connect 来触发。

流程图如下:

 <center><img src="https://i.imgur.com/xWQoYgX.jpg" /></center>

- 第一次握手

  客户端将标志位 SYN(Synchronize Sequence Numbers,同步序列编号)置为 1，随机产生一个序列号 seq=J，并将该数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务器确认。

- 第二次握手

  服务端收到数据包后，通过标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK(ACKnowledge Character 确认字符)都置为 1，ack=J+1，随机生成一个序列号 seq=K，并将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。

- 第三次握手

  客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务端，服务端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务端进入 ESTABLISHED 状态，完成三次握手，随后客户端和服务端之间就可以开始传输数据了。

**四次挥手**

四次挥手即终止 TCP 连接，断开一个 TCP 连接时需要客户端和服务端总共发送四个包以确认连接的断开。在 socket 编程中，这一过程通过任意一方执行 close 来触发。由于 TCP 连接是全双工的，因此，每个方向都必须单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN(finish,结束)来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上扔能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

中断连接端可以是客户端，也可以是服务端。

流程图如下:

 <center><img src="https://i.imgur.com/OFyEn8x.jpg" /></center>

- 第一次挥手

  客户端发送一个 FIN=M，用来关闭客户端到到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说“我客户端没有数据要发给你了”，但是如果你服务端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

- 第二次挥手

  服务端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务端的 FIN 报文。

- 第三次挥手

  当服务端确定数据发送完成后，则向客户端发送 FIN=N 的报文，告诉客户端，好了，我这边的数据发送完了，准备好关闭连接了，服务端进入 LAST_ACK 状态。

- 第四次挥手

  客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器不知道要关闭了，所以发送 ACK=1，ack=N+1 后进入 TIME_WAIT 状态，如果服务端没有收到 ACK 则可以重传。服务端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL(Maximum Segment Lifetime,报文最大生存时间，一般为 30s)后依然没有收到回复，则证明服务端已经正常关闭，那好，我客户端也可以关闭了。最终完成了四次挥手。

**79、给出一个上传文件时不用刷新页面的方案，写出关键部分的 js 代码。**

```
 <script>
  window.onload = () => {
    const btn = document.getElementById("upload");
    const input = document.getElementById("file");
    btn.onclick = () => {
      const file = input.files[0];
      const formData = new FormData();
      formData.append("file", file);
      fetch({
        url: "http://localhost:8000/",
        method: "POST",
        body: formData
      }).then(data => {
        console.log("result is", data);
        alert("upload sucess!");
      });
    };
  };
</script>
<body>
  <input id="file" type="file" />
  <button id="upload">upload</button>
</body>
```

**80、** 从浏览器地址栏输入 url 到显示页面的步骤

- 浏览器根据请求的 url，交给 DNS 解析域名找到真实的 Ip，向服务器请求数据。
- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image 等)
- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom 等)
- 载入解析到的资源文件，渲染页面、完成。

**81、**js 遍历 li 的内容

```
<ul>
  <li>1</li>
  <li>2</li>
</ul>
```

=>

```
  const u = document.querySelector('ul');
  const lis = u.children;
  for(let i = 0; i < lis.length; i++) {
    const li = lis[i];
    console.log(li.innerText);
  }
  或
  const realArr = [].slice.call(lis);
  realArr.forEach((li) => {
    console.log(li.innerText)
  })

```

**82、** `<img>`的 title 和 alt 有什么区别

- title 是鼠标移动到元素显示的值
- alt 是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。

**83、** JavaScript 中 null 和 undefined 的区别
由于历史原因 JavaScript 中有 null 和 undefined 两个表示无的值，其区别很小，主要在于：

- null 的类型为 Object，undefined 的类型为 undefined
- Number(null)为 0，Number(undefined)为 NaN
- null 表示没有对象，此处不该有值，undefined 表示此处应该有值暂时缺少这个值

**84、** 常见 http code 及其含义

- 信息响应(1xx)
  表示服务器收到请求，需要请求者继续执行操作
  - 100 Continue: 客户端应继续其请求。
- 成功(2xx)
  表示服务器成功接收请求并处理返回
  - 200 Ok: 请求正常处理完毕。一般用于 GET 与 POST 请求
  - 202 Accepted: 服务器已经接受到消息，但尚未处理
  - 204 No Content: 服务器成功处理了请求但未返回任何内容
  - 206 Partial Content: 服务器成功处理了部分 get 请求
- 重定向(3xx)
  表示需要客户端进一步操作才能完成请求
  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新 URI
  - 302 Found: 临时重定向，资源临时移动到新的位置
  - 304 Not Modified: 表示资源在由请求头中的 If-Modified-Since 或 If-None-Match 参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。
  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法
- 客户端错误(4xx)
  表示客户端可能发生了错误
  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解
  - 401 Unauthorized: 要求身份验证
  - 403 Forbidden: 服务器理解请求但拒绝执行
  - 404 Not Found: 服务器没有找到资源
- 服务器错误(5xx)
  表示服务器无法完成请求
  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求
  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求

**85、** Cookie, SessionStorage 与 LocalStorage 区别

[demo](https://github.com/fengyueran/web-cache-demo.git)

- 储存大小
  - Cookie: 4kb 左右
  - SessionStorage: 一般为 5M
  - LocalStorage: 一般为 5M
- 生命周期

  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间
  - SessionStorage: 仅在当前会话有效，关闭 tab 页即失效
  - LocalStorage: 持久缓存除非主动清除(通过浏览器或 JS)

- 与服务器通信

  - 每次请求都会携带在 http 请求头中，可能带来性能问题
  - SessionStorage: 只在客户端起作用
  - LocalStorage: 只在客户端起作用

同域名的 http 和 https 共享 cookie(设置了 Secure 的除外)，但不共享 LocalStorage。

**86、\_\_dirname, \_\_filename, process.cwd()**

- \_\_dirname

  当前执行文件所在目录的完整目录名。

- \_\_filename

  当前执行文件带有完整绝对路径的文件名。

- process.cwd()

  获取执行 node 命令时所在的目录名。

如下，目录结构为:

```
node-app/
    - src/
      - test.js
```

在 node-app 目录下执行`node src/test.js`，输出如下:

```
__dirname: /Users/xinghunmeng/MyHouse/test/node-app/src
__filename: /Users/xinghunmeng/MyHouse/test/node-app/src/test.js
process.cwd: /Users/xinghunmeng/MyHouse/test/node-app
```

**87、** clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop 的区别？

clientHeight 和 offsetHeight 属性和元素的滚动、位置没有关系它代表元素的高度。

- clientHeight

  包括 padding 但不包括 border、水平滚动条、margin 的元素的高度。对于 inline 的元素这个属性一直是 0，单位 px，只读。

   <center><img src="https://i.imgur.com/xtvrCA7.png" /></center>

- offsetHeight

  包括 padding、border、水平滚动条，但不包括 margin 的元素的高度。对于 inline 的元素这个属性一直是 0，单位 px，只读。

   <center><img src="https://i.imgur.com/yoGBzK3.png" /></center>

- scrollHeight

  当本元素的子元素比本元素高且 overflow=scroll 时，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，对于父元素而言，scrollHeight(包括子元素的 margin) 代表包括当前不可见部分的元素的高度和可见元素高度。而可见部分的高度其实就是 clientHeight，也就是 scrollHeight>=clientHeight 恒成立。在有滚动条时讨论 scrollHeight 才有意义，在没有滚动条时 scrollHeight==clientHeight 恒成立。单位 px，只读。

  <center><img src="https://i.imgur.com/TOFola6.png" /></center>

- scrollTop

  代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时 scrollTop==0 恒成立。单位 px，可读可设置。

   <center><img src="https://i.imgur.com/CASHgQv.png" /></center>

- offsetTop

  当前元素(border 外边缘算起)顶部距离最近父元素顶部(border 外边缘)的距离,和有没有滚动条没有关系。单位 px，只读元素。

   <center><img src="https://i.imgur.com/GGA4yJ0.png" /></center>

**88、** webpack 中 loader 和 plugin 的区别？

- loader

  loader 处理单独的文件并且作用于生成包(bundle)的过程中或之前。

- plugin

  plugin 处理包或块(chunk)并且通常作用于 bundle 生成的最后阶段。它可以解决 loader 无法解决的问题，因为 plugin 可以在任何阶段调用，能够跨 loader 进一步加工 loader 的输出，执行预先注册的回调，使用 compilation 对象做一些更底层的事情。
