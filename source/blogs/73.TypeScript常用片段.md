---
title: TypeScript常用片段
tags: [Http]
type: SHORT_ANSWER
date: 2019-1-15 18:10:20
---

- 禁用整个文件的 ts 校验

  `// @ts-nocheck`放到文件顶部:

  ```ts
  //test.js

  // @ts-nocheck
  import axios from 'axios';
  ```

- 禁用单行的 ts 校验

  `// @ts-ignore`放到要禁止校验的代码行上面:

  ```ts
  //test.js

  // @ts-ignore
  let a: number = 'a';
  ```

- keyof typeof

  keyof 可以获取一个类型的 key:

  ```ts
  const colorMap = {
    red: 'red',
    green: 'green',
  };

  type keys = keyof colorMap; //error

  /**************分割线****************/
  interface Point {
    x: number;
    y: number;
  }

  // type keys = "x" | "y"
  type keys = keyof Point;
  ```

  typeof 操作符可以用来获取一个变量或对象的类型:

  ```ts
  enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
  }
  type LogType = typeof LogLevel;
  ```

  keyof typeof

  ```ts
  const colorMap = {
    red: '#f61a22',
    green: '#309449',
  };
  // type keys = "red" | "green"
  type keys = keyof typeof colorMap;
  ```

- 泛型

  ```ts
  const join = <T, P>(first: T, second: P) => {
    return `${first}${second}`;
  };
  join<number, string>(1, '2');
  ```

### 类

```ts
//abstract抽象类不能被实例化
abstract class Father {
  private weight; //private属性，类的外部不可用，继承也不行
  protected money = 10000000; //protected属性，类的外部不可用，继承可以
  public readonly familyName = 'meng'; //public公开属性，readonly只读属性不可修改

  //static 静态方法，不需要 new 就可以直接调用
  static breath() {
    console.log('breath');
  }

  abstract eat: () => void; //抽象方法，所有子类都必须实现抽象方法

  //在构造函数添加访问修饰符可省略顶部(weight)的定义，如private name
  constructor(private name: string, weight: number) {
    this.name = name;
    this.weight = weight;
  }
}

class Son extends Father {
  getMoney() {
    console.log('Money', this.money);
  }

  eat = () => {
    console.log('eat');
  };
}
const Father = new Father('snow', 120); //error，抽象类不能实例化
Father.breath(); //static
const snow = new Son('snow', 120);
console.log(snow.money); //error，protected
snow.familyName = 'zhang'; //error，readonly
```

#### interface vs type

- 函数语法的不同

  type 的函数语法更接近于函数本身的声明。

  ```ts
  // via type
  type Sum = (x: number, y: number) => number;

  // via interface
  interface Sum {
    (x: number, y: number): number;
  }
  ```

- Extend

  interface:

  ```ts
  interface Animal {
    name: string;
  }

  interface Dog extends Animal {
    honey: boolean;
  }
  ```

  type:

  ```ts
  type Animal = {
    name: string;
  };

  type Dog = Animal & {
    honey: Boolean;
  };
  ```

- 声明合并

  interface 可以向现有接口添加新字段，type 不行。

  interface:

  ```ts
  interface Point {
    x: number;
  }

  interface Point {
    y: number;
  }
  const pt: Point = { x: 8, y: 9 };
  ```

  type:

  ```ts
  // Error: Duplicate identifier 'Point'.
  type Point = {
    x: number;
  };

  type Point = {
    y: number;
  };
  ```

- 重命名基本类型

  interface 不能重命名基本类型，type 可以。
  interface:

  ```ts
  //error
  interface NewString = string;
  ```

  type:

  ```ts
  type NewString = string;
  ```

- Union types

  type 可用于定义联合类型。

  ```ts
  type Fruit = 'apple' | 'pear' | 'orange';
  type Vegetable = 'broccoli' | 'carrot' | 'lettuce';

  // 'apple' | 'pear' | 'orange' | 'broccoli' | 'carrot' | 'lettuce';
  type HealthyFoods = Fruit | Vegetable;
  ```

- [Mapped object types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)

  interface:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  // ERROR:
  interface FruitCount {
    [key in Fruit]: number;
  }
  ```

  type:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  type FruitCount = {
    [key in Fruit]: number;
  };

  const fruits: FruitCount = {
    apple: 2,
    orange: 3,
    banana: 4,
  };
  ```

- 函数重载

  interface:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  //error
  interface StrAndNumLogger extends NumLogger {
    log: (val: string) => void;
  }
  ```

  type:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  type StrAndNumLogger = NumLogger & {
    log: (val: string) => void;
  };

  const logger: StrAndNumLogger = {
    log: (val: string | number) => console.log(val),
  };

  logger.log(1);
  logger.log('hi');
  ```

- Tuple types

  元组类型，与数组类似，但是元组类型赋值的类型、位置、个数需要和定义的类型、位置、个数一致。

  ```ts
  type TupleArr = [string, boolean, number];
  const v: TupleArr = ['a', true, 1];
  ```

  因此使用 type 的场景如下:

- 需要重命名原始类型
- 需要定义函数类型
- 需要定义联合类型
- 需要利用 mapped types
- 需要函数重载
- 需要使用 tuple types

#### interface vs type
