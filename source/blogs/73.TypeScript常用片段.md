---
title: TypeScript常用片段
tags: [Http]
type: SHORT_ANSWER
date: 2019-1-15 18:10:20
---

- 禁用整个文件的 ts 校验

  `// @ts-nocheck`放到文件顶部:

  ```ts
  //test.js

  // @ts-nocheck
  import axios from 'axios';
  ```

- 禁用单行的 ts 校验

  `// @ts-ignore`放到要禁止校验的代码行上面:

  ```ts
  //test.js

  // @ts-ignore
  let a: number = 'a';
  ```

- 基础类型

  常用:

  ```
  boolean、number、string、array、enum、any、void
  ```

  不常用:

  ```
  tuple、null、undefined、never
  ```

- Union Types

  联合类型，表示取值可以为多种类型之一，用 `|`(或) 分割。

  ```ts
  let num: string | number;

  type Color = 'red' | 'green' | 'yellow';

  interface Fish {
    swim: boolean;
  }
  interface Bird {
    fly: boolean;
  }
  type BirdOrFish = Fish | Bird;
  ```

- Intersection Types

  交叉类型，将多个类型合并为一个类型，用 `&`(且)连接。

  ```ts
  interface Fish {
    swim: boolean;
  }
  interface Bird {
    fly: boolean;
  }
  type BirdOrFish = Fish & Bird;
  const bf: BirdOrFish = {
    swim: true,
    fly: true,
  };
  ```

- keyof typeof

  keyof 可以获取一个**类型**的 key:

  ```ts
  const colorMap = {
    red: 'red',
    green: 'green',
  };

  type keys = keyof colorMap; //error

  /**************分割线****************/
  interface Point {
    x: number;
    y: number;
  }

  // type keys = "x" | "y"
  type keys = keyof Point;
  ```

  typeof 操作符可以用来获取一个变量或对象的类型:

  ```ts
  enum LogLevel {
    Error,
    Warn,
    Info,
    Debug,
  }
  type LogType = typeof LogLevel;
  ```

  keyof typeof

  ```ts
  const colorMap = {
    red: '#f61a22',
    green: '#309449',
  };
  // type keys = "red" | "green"
  type keys = keyof typeof colorMap;
  ```

- 泛型

  ```ts
  const join = <T, P>(first: T, second: P) => {
    return `${first}${second}`;
  };
  join<number, string>(1, '2');
  ```

### 类

```ts
//abstract抽象类不能被实例化
abstract class Father {
  private weight; //private属性，类的外部不可用，继承也不行
  protected money = 10000000; //protected属性，类的外部不可用，继承可以
  public readonly familyName = 'meng'; //public公开属性，readonly只读属性不可修改

  //static 静态方法，不需要 new 就可以直接调用
  static breath() {
    console.log('breath');
  }

  abstract eat: () => void; //抽象方法，所有子类都必须实现抽象方法

  //在构造函数添加访问修饰符可省略顶部(weight)的定义，如private name
  constructor(private name: string, weight: number) {
    this.name = name;
    this.weight = weight;
  }
}

class Son extends Father {
  getMoney() {
    console.log('Money', this.money);
  }

  eat = () => {
    console.log('eat');
  };
}
const Father = new Father('snow', 120); //error，抽象类不能实例化
Father.breath(); //static
const snow = new Son('snow', 120);
console.log(snow.money); //error，protected
snow.familyName = 'zhang'; //error，readonly
```

### Utility Types

- `Readonly<T>`

  将 T 类型的所有属性设置为只读。

  ```ts
  interface Bird {
    name?: string;
    fly: boolean;
  }

  type ReadonlyBird = Readonly<Bird>;

  const b: ReadonlyBird = { name: 'a', fly: true };
  b.fly = false; //error，Cannot assign to 'name' because it is a read-only property.
  ```

- `Partial<T>`

  将类型 T 中所有属性转换为可选属性，返回的类型可以是 T 的任意子集，也就是 Partial 所表达的意思。

  ```ts
  interface Bird {
    name?: string;
    weight: number;
    fly: boolean;
  }

  type Dog = Partial<Bird>;
  // =
  type Dog = {
    name?: string | undefined;
    weight?: number | undefined;
    fly?: boolean | undefined;
  };
  ```

  `Partial<T>`所表达的意思:

  ```
  type Partial<T> = { [P in keyof T]?: T[P]; };
  ```

- `Required<T>`

  和 Partial 相反，将 T 类型的所有属性设置为必选。

  ```ts
  interface Bird {
    name?: string;
    weight: number;
    fly: boolean;
  }

  type Duck = Required<Bird>;
  // =
  type Duck = {
    name: string;
    weight: number;
    fly: boolean;
  };
  ```

- `Record<K,T>`

  声明键为 K 类型，值为 T 类型的对象。

  ```ts
  interface Order {
    type: string;
    price: number;
  }

  type OrderMap = Record<string, Order>;
  //等同于
  interface OrderMap {
    [key: string]: Order;
  }
  ```

- `Pick<T,K>`

  在已声明的对象类型中挑选出部分属性组成新的声明对象。

  ```ts
  interface Order {
    type: string;
    price: number;
    deadline: string;
  }

  type NewOrder = Pick<Order, 'type' | 'price'>;
  //等同于
  type NewOrder = {
    type: string;
    price: number;
  };
  ```

- `Omit<T,K>`

  与 Pick 相反，在已声明的对象类型去除部分属性，剩余属性组成新的声明对象。

  ```ts
  interface Order {
    type: string;
    price: number;
    deadline: string;
  }

  type NewOrder = Omit<Order, 'deadline'>;
  //等同于
  type NewOrder = {
    type: string;
    price: number;
  };
  ```

- `Exclude<T,U>`

  同 Omit 类似，但 Exclude 是从**联合类型**中排除类型。

  ```ts
  //type Color = 'red'
  type Color = Exclude<'red' | 'green', 'green'>;

  interface Fish {
    swim: boolean;
  }

  interface Bird {
    fly: boolean;
  }

  type BirdOrFish = Fish | Bird;

  //type NewBird===Bird
  type NewBird = Exclude<BirdOrFish, Fish>;
  ```

- `Extract<T,U>`

  与 Exclude，同 Pick 类似，但 Extract 是从**联合类型**中挑选类型。

  ```ts
  //type Color==='green'
  type Color = Extract<'red' | 'green', 'green'>;

  interface Fish {
    swim: boolean;
  }

  interface Bird {
    fly: boolean;
  }

  type BirdOrFish = Fish | Bird;

  //type NewBird===Bird
  type NewBird = Extract<BirdOrFish, Bird>;
  ```

- `ReturnType<T>`

  返回类型为 T 的函数的返回类型，这个方法对于没有明确提供类型的方法来说太方便了。

  ```ts
  const getNumber = () => 7;
  //type T = number
  type T = ReturnType<typeof getNumber>;
  ```

- `Parameters<T>`

  返回类型为 T 的函数的参数类型所组成的数组。

  ```ts
  type T1 = Parameters<() => number>; // []

  type T2 = Parameters<(s: string, n: number) => void>; // [string, number]
  ```

- `NonNullable<T>`

  从联合类型 T 中去除 null 或者 undefined。

  ```ts
  //等同于type T = 'string' | 'number';
  type T = NonNullable<'string' | 'number' | undefined | null>;
  ```

- InstanceType

  返回构造函数类型 T 的实例类型。

  ```ts
  class C {
    x = 0;
    y = 0;
  }
  //等同于 T = C
  type T = InstanceType<typeof C>;
  ```

#### interface vs type

- 函数语法的不同

  type 的函数语法更接近于函数本身的声明。

  ```ts
  // via type
  type Sum = (x: number, y: number) => number;

  // via interface
  interface Sum {
    (x: number, y: number): number;
  }
  ```

- Extend

  interface:

  ```ts
  interface Animal {
    name: string;
  }

  interface Dog extends Animal {
    honey: boolean;
  }
  ```

  type:

  ```ts
  type Animal = {
    name: string;
  };

  type Dog = Animal & {
    honey: Boolean;
  };
  ```

- 声明合并

  interface 可以向现有接口添加新字段，type 不行。

  interface:

  ```ts
  interface Point {
    x: number;
  }

  interface Point {
    y: number;
  }
  const pt: Point = { x: 8, y: 9 };
  ```

  type:

  ```ts
  // Error: Duplicate identifier 'Point'.
  type Point = {
    x: number;
  };

  type Point = {
    y: number;
  };
  ```

- 重命名基本类型

  interface 不能重命名基本类型，type 可以。
  interface:

  ```ts
  //error
  interface NewString = string;
  ```

  type:

  ```ts
  type NewString = string;
  ```

- Union types

  type 可用于定义联合类型。

  ```ts
  type Fruit = 'apple' | 'pear' | 'orange';
  type Vegetable = 'broccoli' | 'carrot' | 'lettuce';

  // 'apple' | 'pear' | 'orange' | 'broccoli' | 'carrot' | 'lettuce';
  type HealthyFoods = Fruit | Vegetable;
  ```

- [Mapped object types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)

  interface:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  // ERROR:
  interface FruitCount {
    [key in Fruit]: number;
  }
  ```

  type:

  ```ts
  type Fruit = 'apple' | 'orange' | 'banana';

  type FruitCount = {
    [key in Fruit]: number;
  };

  const fruits: FruitCount = {
    apple: 2,
    orange: 3,
    banana: 4,
  };
  ```

- 函数重载

  interface:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  //error
  interface StrAndNumLogger extends NumLogger {
    log: (val: string) => void;
  }
  ```

  type:

  ```ts
  interface NumLogger {
    log: (val: number) => void;
  }
  type StrAndNumLogger = NumLogger & {
    log: (val: string) => void;
  };

  const logger: StrAndNumLogger = {
    log: (val: string | number) => console.log(val),
  };

  logger.log(1);
  logger.log('hi');
  ```

- Tuple types

  元组类型，与数组类似，但是元组类型赋值的类型、位置、个数需要和定义的类型、位置、个数一致。

  ```ts
  type TupleArr = [string, boolean, number];
  const v: TupleArr = ['a', true, 1];
  ```

  因此使用 type 的场景如下:

- 需要重命名原始类型
- 需要定义函数类型
- 需要定义联合类型
- 需要利用 mapped types
- 需要函数重载
- 需要使用 tuple types

#### any vs unkown

#### tsconfig
