# 命令模式

在讨论命令模式之前，先来实现一个只有一个按钮的遥控器的功能，这个遥控器的按钮要有能力控制电视和电灯:

```ts
enum Status {
  On,
  Off,
}

class TV {
  status = Status.Off;

  turnOn = () => {
    this.status = Status.On;
    console.log("电视已打开");
  };

  turnOff = () => {
    this.status = Status.Off;
    console.log("电视已关闭");
  };
}

enum Brightness {
  Low,
  High,
}

class Light {
  brightness: Brightness;

  open = () => {
    if (this.brightness === undefined) {
      this.setBrightness(Brightness.Low);
    } else if (this.brightness === Brightness.Low) {
      this.setBrightness(Brightness.High);
    } else if (this.brightness === Brightness.High) {
      this.setBrightness();
    }
  };

  setBrightness = (brightness?: Brightness) => {
    this.brightness = brightness;
    if (this.brightness === undefined) {
      console.log("电灯已关闭");
    } else if (this.brightness === Brightness.Low) {
      console.log("电灯已打开，亮度低");
    } else if (this.brightness === Brightness.High) {
      console.log("电灯已打开，亮度高");
    }
  };
}

class RemoteControl {
  private undoStack: (Status | Brightness)[] = [];
  private redoStack: (Status | Brightness)[] = [];
  constructor(private tigger: Light | TV) {}

  onButtonPressed = () => {
    if (this.tigger instanceof Light) {
      this.tigger.open();
      this.undoStack.push(this.tigger.brightness);
    } else if (this.tigger instanceof TV) {
      if (this.tigger.status === Status.On) {
        this.tigger.turnOff();
      } else {
        this.tigger.turnOn();
      }
      this.undoStack.push(this.tigger.status);
    }
    this.redoStack = []; // 清空重做栈，因为新命令改变了状态
  };

  private executeUndoCommand = (command: Status | Brightness) => {
    if (this.tigger instanceof Light) {
      if (command === Brightness.High) {
        this.tigger.setBrightness(Brightness.Low);
      } else if (command === Brightness.Low) {
        this.tigger.setBrightness();
      } else {
        this.tigger.setBrightness(Brightness.High);
      }
    } else if (this.tigger instanceof TV) {
      if (command === Status.Off) {
        this.tigger.turnOn();
      } else {
        this.tigger.turnOff();
      }
    }
  };

  private executeRedoCommand = (command: Status | Brightness) => {
    if (this.tigger instanceof Light) {
      if (command === Brightness.High) {
        this.tigger.setBrightness(Brightness.High);
      } else if (command === Brightness.Low) {
        this.tigger.setBrightness(Brightness.Low);
      } else {
        this.tigger.setBrightness();
      }
    } else if (this.tigger instanceof TV) {
      if (command === Status.Off) {
        this.tigger.turnOff();
      } else {
        this.tigger.turnOn();
      }
    }
  };

  undo = () => {
    if (this.undoStack.length > 0) {
      const command = this.undoStack.pop();
      this.executeUndoCommand(command);
      this.redoStack.push(command);
    }
  };

  redo = () => {
    if (this.redoStack.length > 0) {
      const command = this.redoStack.pop();
      this.executeRedoCommand(command);
      this.undoStack.push(command);
    }
  };
}

//客户端代码
const testOperateTV = () => {
  const tv = new TV();
  const remote = new RemoteControl(tv);

  remote.onButtonPressed(); // 输出：电视已打开
  remote.onButtonPressed(); // 输出：电视已关闭

  // 撤销最后一个命令（关闭电视）
  remote.undo(); // 输出：电视已打开

  // 重做撤销的命令
  remote.redo(); // 输出：电视已关闭
};

testOperateTV();

//客户端代码
const testOperateLight = () => {
  const light = new Light();
  const remote = new RemoteControl(light);

  remote.onButtonPressed(); // 输出：电灯已打开，亮度低
  remote.onButtonPressed(); // 输出：电灯已打开，亮度高
  remote.onButtonPressed(); // 输出：电灯已关闭

  // 撤销最后一个命令（关闭电灯）
  remote.undo(); // 输出：电灯已打开，亮度高

  // 撤销最后倒数第二个命令（电灯已打开，亮度高）
  remote.undo(); // 输出：电灯已打开，亮度低

  // 重做撤销的命令
  remote.redo(); // 输出：电灯已打开，亮度高
};
testOperateLight();
```

从上面的实现可以看到，当遥控器(RemoteControl)要能控制电视和电灯，就需要深入了解其细节，遥控器和被控制的对象紧紧耦合在一起。如果要接入其他被控制的电器，那么 RemoteControl 就会变得更加庞大与繁杂，耦合的对象越来越多，越来越难控制。而命令模式能很好的解决这一问题。

通过命令模式实现上述功能:

```ts
interface Command {
  execute: () => void;
  undo: () => void;
}

class RemoteControl {
  private undoStack: Command[] = [];
  private redoStack: Command[] = [];

  onButtonPressed = (command: Command) => {
    command.execute();
    this.undoStack.push(command);
    this.redoStack = [];
  };

  undo = () => {
    if (this.undoStack.length > 0) {
      const command = this.undoStack.pop();
      command.undo();
      this.redoStack.push(command);
    }
  };

  redo = () => {
    if (this.redoStack.length > 0) {
      const command = this.redoStack.pop();
      command.execute();
      this.undoStack.push(command);
    }
  };
}

enum Status {
  On,
  Off,
}

class TV {
  status = Status.Off;

  turnOn = () => {
    this.status = Status.On;
    console.log("电视已打开");
  };

  turnOff = () => {
    this.status = Status.Off;
    console.log("电视已关闭");
  };
}

enum Brightness {
  Low,
  High,
}

class Light {
  brightness: Brightness;

  open = () => {
    if (this.brightness === undefined) {
      this.setBrightness(Brightness.Low);
    } else if (this.brightness === Brightness.Low) {
      this.setBrightness(Brightness.High);
    } else if (this.brightness === Brightness.High) {
      this.setBrightness();
    }
  };

  setBrightness = (brightness?: Brightness) => {
    this.brightness = brightness;
    if (this.brightness === undefined) {
      console.log("电灯已关闭");
    } else if (this.brightness === Brightness.Low) {
      console.log("电灯已打开，亮度低");
    } else if (this.brightness === Brightness.High) {
      console.log("电灯已打开，亮度高");
    }
  };
}

class TurnOnTVCommand implements Command {
  constructor(private tv: TV) {}

  execute = () => {
    this.tv.turnOn();
  };

  undo = () => {
    this.tv.turnOff();
  };
}

class TurnOffTVCommand implements Command {
  constructor(private tv: TV) {}

  execute = () => {
    this.tv.turnOff();
  };

  undo = () => {
    this.tv.turnOn();
  };
}
//客户端代码
const testOperateTV = () => {
  const tv = new TV();
  const turnOnCommand = new TurnOnTVCommand(tv);
  const turnOffCommand = new TurnOffTVCommand(tv);
  const remote = new RemoteControl();

  // 执行命令
  remote.onButtonPressed(turnOnCommand); // 输出：电视已打开
  remote.onButtonPressed(turnOffCommand); // 输出：电视已关闭

  // 撤销最后一个命令（关闭电视）
  remote.undo(); // 输出：电视已打开

  // 重做撤销的命令
  remote.redo(); // 输出：电视已关闭
};

testOperateTV();

class LowBrightnessLightCommand implements Command {
  constructor(private light: Light) {}

  execute = () => {
    this.light.setBrightness(Brightness.Low);
  };

  undo = () => {
    this.light.setBrightness();
  };
}

class HighBrightnessLightCommand implements Command {
  constructor(private light: Light) {}

  execute = () => {
    this.light.setBrightness(Brightness.High);
  };

  undo = () => {
    this.light.setBrightness(Brightness.Low);
  };
}

class TurnOffLightCommand implements Command {
  constructor(private light: Light) {}

  execute = () => {
    this.light.setBrightness();
  };

  undo = () => {
    this.light.setBrightness(Brightness.High);
  };
}

//客户端代码
const testOperateLight = () => {
  const light = new Light();
  const lowBrightnessCommand = new LowBrightnessLightCommand(light);
  const highBrightnessCommand = new HighBrightnessLightCommand(light);
  const turnOffCommand = new TurnOffLightCommand(light);
  const remote = new RemoteControl();

  remote.onButtonPressed(lowBrightnessCommand); // 输出：电灯已打开，亮度低
  remote.onButtonPressed(highBrightnessCommand); // 输出：电灯已打开，亮度高
  remote.onButtonPressed(turnOffCommand); // 输出：电灯已关闭

  // 撤销最后一个命令（关闭电灯）
  remote.undo(); // 输出：电灯已打开，亮度高

  // 撤销最后倒数第二个命令（电灯已打开，亮度高）
  remote.undo(); // 输出：电灯已打开，亮度低

  // 重做撤销的命令
  remote.redo(); // 输出：电灯已打开，亮度高
};
testOperateLight();
```

可以看到，通过命令模式实现遥控器，让遥控器得到了彻底的解耦，遥控器完全不需要知道要控制的电器是什么，它只需要知道在按钮按下的时候执行命令对象的 execute 方法。当需要控制其他电器时，也很简单，只需要实现相应的命令并绑定命令就可以了。 此外，命令模式实现 redo、undo 也非常简单。那什么是命令模式？

### 命令模式

命令模式（Command Pattern）是一种设计模式，它允许将各种操作(如请求、队列管理操作、日志记录操作等)封装成对象。通过这种方式，这些封装的操作(即命令对象)可以用作其他对象的参数。这样做的好处有几个方面：

- 参数化对象

  你可以将命令对象作为参数传递给其他对象，这些对象可以在**适当的时候**(相比于过程式的操作，生命周期更长)执行命令对象的 execute()方法。这意味着执行的具体操作可以动态地改变，取决于传入的命令对象。

- 队列请求

  因为命令被封装成对象，所以它们可以像其他任何对象一样被存储和管理。这使得创建命令队列成为可能，你可以在以后的任何时间点按照需要执行这些命令。

- 日志请求

  命令模式还允许对命令的执行进行记录，即日志记录。这对于事务管理（如需要撤销操作）、故障恢复（系统崩溃后恢复操作）等情况特别有用。

- 支持撤销/重做

  由于命令的每个执行动作都被封装在对象中，通过实现命令对象的 undo 方法（撤销操作）和 redo 方法（重做操作），可以非常容易地支持撤销和重做功能。

想象一下我们去餐厅吃饭的过程，顾客点菜，服务员拿到菜单后将其放入后厨的订单栏排队，不久后厨师就能够完成炒菜，这个过程中，点单的顾客并清楚具体炒菜的的师傅是男是女，是胖是瘦，厨师和顾客间是互相无感知的。这就是命令模式，它通常涉及以下几个角色：

- 命令（Command）接口

  定义执行操作的接口，通常会有一个 execute()方法用于执行命令。

  ```ts
  interface Command {
    execute: () => void;
    undo: () => void;
  }
  ```

- 具体命令（ConcreteCommand）类

  实现命令接口(饭店里我们点的单-糖醋里脊，TurnOnTVCommand)，并定义接收操作的绑定操作。具体命令类会有一个接收者（Receiver）对象，并调用接收者的功能来执行命令的具体操作。

- 接收者（Receiver）类

  接收者(厨师-知道怎么炒菜，tv、light)知道怎么执行一个请求相关的操作。任何类都可能作为一个接收者。

- 调用者（Invoker）类

  调用者要求该命令执行这个请求。通常会持有命令对象，并在某个时间点调用命令对象的 execute()方法来提交请求。

- 客户（Client）类

  创建具体命令对象并设定它的接收者。

### 宏命令
