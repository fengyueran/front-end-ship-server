---
title: 前端性能优化指南
tags: [Http]
type: SHORT_ANSWER
date: 2022-12-15 18:10:20
---

关联仓库:git@github.com:fengyueran/performance-optimization.git

React 及其前端的一些流行框架，SPA 单页面启动方式都非常相似:
html 中提供一个 root 节点

```html
<div id="root"></div>
```

然后把应用挂载到这个节点上

```js
ReactDOM.render(<App />, document.getElementById('root'));
```

使用 webpack 打包之后，一般三个文件：

- 一个体积很小、除了提供个 root 节点以外的没什么卵用的 html（大概 1-4 KB）
- 一个体积很大的 js（50 - 1000 KB 不等）
- 一个 css 文件（当然如果你把 css 打进 js 里了，也可能没有）

这样造成的直接后果就是，用户在 50 - 1000 KB 的 js 文件加载、执行完毕之前，页面是 完！全！空！白！的！。

#### 提供 loading 或骨架屏

- 通过 html-webpack-plugin 插入 loading

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

const loading = {
  html: fs.readFileSync(path.join(__dirname, './loading.html')),
  css:
    '<style>' +
    fs.readFileSync(path.join(__dirname, './loading.css')) +
    '</style>',
};
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: 'template.html',
      loading,
    }),
  ],
};
```

- 通过 [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)插件生成 loading

#### 去掉 css

去掉 css 可以是不生成单独的 css 文件(去掉 extract-text-webpack-plugin 或者 mini-css-extract-plugin 来生成独立的 css 文件)，或者直接使用[styled-components](https://github.com/styled-components/styled-components)这样的 css in js 的方案。虽然去掉 css 会丧失单独缓存 css 的好处，但在成熟的前端应用中缓存组件可能是一个更好的选择。

#### 缓存基础框架

基础框架像 react、vue 等基本是保持不变的，因此将基础框架提取出来能够有效的利用浏览器缓存。

通过 webpack5 SplitChunksPlugin 插件就能够提取基础库:

```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        react: {
          name: 'react',
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
        },
      },
    },
  },
};
```

打包结果如下:
react 和 react-dom 被打包到 react.c787bfc3.js 里了。
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/bundle.png)

配置好相应的[缓存策略](https://www.jianshu.com/p/54cc04190252)就可以使浏览器尽量使用缓存而不重新请求了。

#### 利用[Tree Shaking](https://webpack.docschina.org/guides/tree-shaking/)减少代码体积

Tree Shaking 是去除未被引用代码的技术。

如下代码:
cube 未被引用:

```js
//src/math.js
// math.js
export function square(x: number) {
  return x * x;
}

export function cube(x: number) {
  return x * x * x;
}
*******************分割线********************
//src/index.js
import { square } from './math';
console.log('square', square(1));
```

webpack 配置文件:

```js
module.exports = {
  entry: './src/index.jsx',
  output: {
    path: path.resolve(__dirname, PATHS.dist),
    filename: 'bundle.js',
  },
  mode: 'production',
};
```

Tree Shaking 的执行需要[ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)插件，当 mode 为 production 时会自动开启。
最后编译结果为:
可以看到 cube 的内容已经被 tree shaking 掉了:

```js
//bundle.js
(() => {
  'use strict';
  console.log('square', 1 * 1);
})();
```

需要注意的是 Tree Shaking 依赖于 ES6 模块语法的静态结构特性，即使用 import 和 export 来引入导出模块，不过不是就不能 Shaking 掉代码，比如下边的例子:

```js
//src/index.js
import { find } from 'lodash';

const testValue = find([1, 2], (v) => v > 1);
console.log('testValue', testValue);
```

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/lodash.png)
可以看到 lodash 500 多 kb 的所有内容都打包进去了，尽管只使用了一个 find 方法。

使用 es6 版本的 lodash 再进行测试:

```js
//src/index.js
import { find } from 'lodash-es';

const testValue = find([1, 2], (v) => v > 1);
console.log('testValue', testValue);
```

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/lodash-tree-shaking.png)
可以看到 es6 版本后 Tree Shaking 生效了，只打包了 find.js 及其依赖项。
