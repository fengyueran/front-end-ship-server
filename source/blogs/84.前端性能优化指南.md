---
title: 前端性能优化指南
tags: [Http]
type: SHORT_ANSWER
date: 2022-12-15 18:10:20
---

关联仓库:git@github.com:fengyueran/performance-optimization.git

## 基础概念

### 关键资源

在浏览器的渲染时， HTML、CSS 和 JavaScript 会阻塞页面的首次渲染，这些能阻塞网页首次渲染的资源称为关键资源。
因此**减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数**就是优化的基本原则。

## 优化方式

React 及其前端的一些流行框架，SPA 单页面启动方式都非常相似:
html 中提供一个 root 节点

```html
<div id="root"></div>
```

然后把应用挂载到这个节点上

```js
ReactDOM.render(<App />, document.getElementById('root'));
```

使用 webpack 打包之后，一般三个文件：

- 一个体积很小、除了提供个 root 节点以外的没什么卵用的 html（大概 1-4 KB）
- 一个体积很大的 js（50 - 1000 KB 不等）
- 一个 css 文件（当然如果你把 css 打进 js 里了，也可能没有）

这样造成的直接后果就是，用户在 50 - 1000 KB 的 js 文件加载、执行完毕之前，页面是 完！全！空！白！的！。

#### 提供 loading 或骨架屏

- 通过 html-webpack-plugin 插入 loading

```js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

const loading = {
  html: fs.readFileSync(path.join(__dirname, './loading.html')),
  css:
    '<style>' +
    fs.readFileSync(path.join(__dirname, './loading.css')) +
    '</style>',
};
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: 'template.html',
      loading,
    }),
  ],
};
```

- 通过 [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)插件生成 loading

#### 去掉 css

去掉 css 可以是不生成单独的 css 文件(去掉 extract-text-webpack-plugin 或者 mini-css-extract-plugin 来生成独立的 css 文件)，或者直接使用[styled-components](https://github.com/styled-components/styled-components)这样的 css in js 的方案。虽然去掉 css 会丧失单独缓存 css 的好处，但在成熟的前端应用中缓存组件可能是一个更好的选择。

#### 缓存基础框架

基础框架像 react、vue 等基本是保持不变的，因此将基础框架提取出来能够有效的利用浏览器缓存。

通过 webpack5 SplitChunksPlugin 插件就能够提取基础库:

```js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        react: {
          name: 'react',
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
        },
      },
    },
  },
};
```

打包结果如下:
react 和 react-dom 被打包到 react.c787bfc3.js 里了。
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/bundle.png)

配置好相应的[缓存策略](https://www.jianshu.com/p/54cc04190252)就可以使浏览器尽量使用缓存而不重新请求了。

#### 利用[Tree Shaking](https://webpack.docschina.org/guides/tree-shaking/)减少代码体积

Tree Shaking 是去除未被引用代码的技术。

如下代码:
cube 未被引用:

```js
//src/math.js
// math.js
export function square(x: number) {
  return x * x;
}

export function cube(x: number) {
  return x * x * x;
}
*******************分割线********************
//src/index.js
import { square } from './math';
console.log('square', square(1));
```

webpack 配置文件:

```js
module.exports = {
  entry: './src/index.jsx',
  output: {
    path: path.resolve(__dirname, PATHS.dist),
    filename: 'bundle.js',
  },
  mode: 'production',
};
```

Tree Shaking 的执行需要[ModuleConcatenationPlugin](https://webpack.js.org/plugins/module-concatenation-plugin/)插件，当 mode 为 production 时会自动开启。
最后编译结果为:
可以看到 cube 的内容已经被 tree shaking 掉了:

```js
//bundle.js
(() => {
  'use strict';
  console.log('square', 1 * 1);
})();
```

需要注意的是 Tree Shaking 依赖于 ES6 模块语法的静态结构特性，即使用 import 和 export 来引入导出模块，不过不是就不能 Shaking 掉代码，比如下边的例子:

```js
//src/index.js
import { find } from 'lodash';

const testValue = find([1, 2], (v) => v > 1);
console.log('testValue', testValue);
```

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/lodash.png)
可以看到 lodash 500 多 kb 的所有内容都打包进去了，尽管只使用了一个 find 方法。

使用 es6 版本的 lodash 再进行测试:

```js
//src/index.js
import { find } from 'lodash-es';

const testValue = find([1, 2], (v) => v > 1);
console.log('testValue', testValue);
```

![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/lodash-tree-shaking.png)
可以看到 es6 版本后 Tree Shaking 生效了，只打包了 find.js 及其依赖项。

#### 压缩 HTML、CSS、JavaScript

压缩为删除文件中的空格、注释等内容。

- 压缩 html

  移除前:

  ```html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8" />
      <title><%= htmlWebpackPlugin.options.title %></title>
    </head>
    <!-- test -->
    <body>
      <div id="root"><%= htmlWebpackPlugin.options.loading.html %></div>
    </body>
  </html>
  ```

  通过 webpack 插件[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)移除空格和注释:

  ```js
  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  const PATHS = require('./paths');

  module.exports = {
    plugins: [
      new HtmlWebpackPlugin({
        title: 'webpack-excrise',
        template: path.resolve(PATHS.public, 'index.html'),
        filename: path.resolve(PATHS.dist, 'index.html'),
        hash: true,
        minify: {
          removeAttributeQuotes: true, // 去除多余引号
          collapseWhitespace: true, // 移除空格
          removeComments: true, // 移除注释
        },
        loading: {
          html: null,
        },
      }),
    ],
  };
  ```

  压缩后:

  ```
  <!DOCTYPE html><html><head><meta charset=UTF-8><title>webpack-excrise</title><script defer=defer src=main.49a8d77b.js?42872c9d2b68c271ddeb></script></head><body><div id=root></div></body></html>
  ```

- 压缩 js 代码

  移除前:

  ```
  /******/ (() => { // webpackBootstrap
  var __webpack_exports__ = {};
  //这是注释
  const test = async () => {
    console.log('test');
  };
  test();
  /******/ })()
  ;
  ```

  通过 webpack 设置[mode](https://webpack.docschina.org/configuration/mode/)为 production 开启插件[terser-webpack-plugin](https://github.com/webpack-contrib/terser-webpack-plugin)移除空格和注释:

  ```js
  module.exports = {
    mode: 'production',
  };
  ```

  压缩后:

  ```
  (async()=>{console.log("test")})();
  ```

- 压缩 css 代码

  压缩前:

  ```css
  //style.css
  html {
    width: 360px;
    position: fixed;
    text-align: left;
    display: none;
    z-index: 100;
    inset: 0px;
    height: 208px;
    margin: auto;
  }
  ```

  通过插件[css-minimizer-webpack-plugin](https://github.com/webpack-contrib/css-minimizer-webpack-plugin)压缩:

  ```js
  const MiniCssExtractPlugin = require('mini-css-extract-plugin');
  const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

  module.exports = {
    module: {
      rules: [
        {
          test: [/\.css$/],
          use: [
            { loader: MiniCssExtractPlugin.loader },
            { loader: 'css-loader' },
          ],
        },
      ],
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: 'style.css',
      }),
      new CssMinimizerPlugin(),
    ],
  };
  ```

  压缩后:

  ```
  html{display:none;height:208px;inset:0;margin:auto;position:fixed;text-align:left;width:360px;z-index:100}
  ```

#### Code Splitting

Code Splitting 即代码拆分，不用将所有代码打包到一个 bundle 文件中，而是拆分成多个 bundle，在需要的时候才加载对应的 bundle。

Webpack 的 SplitChunksPlugin 插件对异步模块默认单独打包，如下:

```js
//src/index.js
import('./math').then((math) => {
  console.log(math.square(16, 26));
});
```

打包结果如下:
可以看到 math.js 被单独打包为 760.6a3af2ba.js 了
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/split-async-import.png)

在 React 中通过 React.lazy 可以实现异步加载，同样异步加载的模块会被单独打包:

```js
//profile.js
import React from 'react';

const Profile = () => {
  return <div>Profile</div>;
};

export default Profile;


export default Setting;
*******************分割线********************
//setting.js
import React, { Suspense } from 'react';

const Profile = React.lazy(() => import('./profile'));

const Setting = () => {
  return (
    //Profile加载完成前显示fallback内容
    <Suspense fallback={<div>loading</div>}>
      <Profile />
    </Suspense>
  );
};

export default Setting;
```

可以看到异步加载的 profile 被单独打包了:
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/lazy.png)

#### [编译代码到 ES2015+](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/)

在当下 2023 年 ES2015+的语法对于大多数浏览器都是支持的，
像 async/await、Promise、Class、Arrow functions 等 ES2015+语法在全球 90%以上用户的浏览器都是支持的，因此并不完全需要将代码编译为老旧的 ES5 代码，不仅运行速度慢，体积还大。

编译如下代码:

```js
//src/index.js
const test = async () => {
  console.log('test');
};

test();
```

**编译 ES5 代码:**
babel 配置:

```js
//babel.config.js
module.exports = function (api) {
  api.cache(true);

  const presets = [
    [
      '@babel/preset-env',
      {
        //modules为false可以避免转换es模块
        modules: false,
        //按需引入polyfill
        useBuiltIns: 'usage',
        targets: {
          //,分割是并集，编译出来的代码兼容全球大于1%占有率的浏览器、或者浏览器最新的两个版本，或者Firefox ESR
          browsers: ['> 1%', 'last 2 versions', 'Firefox ESR'],
        },
      },
    ],
  ];
  const plugins = [];

  return {
    presets,
    plugins,
  };
};
```

targets 的覆盖面比较广编译出来的代码为 ES5 代码。
结果如下:
![](http://blog-bed.oss-cn-beijing.aliyuncs.com/84.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/es5.png)
可以看到仅仅编译一个 async 函数就编译出了 2000 多行(未 uglify)代码。

**编译 ES2015+代码:**

babel 配置:

````js
//babel.config.js
module.exports = function (api) {
  api.cache(true);

  const presets = [
    [
      '@babel/preset-env',
      {
        modules: false,
        useBuiltIns: 'usage',
        targets: {
          browsers: [
            'Chrome >= 90',
          ],
        },
      },
    ]
  ];
  const plugins = [];

  return {
    presets,
    plugins,
  };
};
编译结果如下:
可以看到，async并未被编译，因为Chrome 90以上版本支持async。
```js
(async () => {
  console.log('test');
})();
````

#### 虚拟列表
