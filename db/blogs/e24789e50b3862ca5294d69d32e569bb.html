<div class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-进制转-x-进制"><span class="toc-number">1.</span> <span class="toc-text">10 进制转 x 进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">2.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析对象"><span class="toc-number">3.</span> <span class="toc-text">解析对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取整函数"><span class="toc-number">4.</span> <span class="toc-text">取整函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成随机数"><span class="toc-number">5.</span> <span class="toc-text">生成随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用排序算法"><span class="toc-number">6.</span> <span class="toc-text">常用排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数组"><span class="toc-number">7.</span> <span class="toc-text">操作数组</span></a></li></ol></div><h3 id="10-进制转-x-进制"><strong>10 进制转 x 进制</strong></h3>
<pre><code>var convert10ToXBinary = (num, x) =&gt; {
  let xBinaryStr = &quot;&quot;;
  while (num !== 0) {
    const res = num % x;
    xBinaryStr = res + xBinaryStr;
    num = Math.floor(num / x);
    console.log(num)
  }
  const xBinaryNum = Number(xBinaryStr);
  return xBinaryStr;
};
</code></pre><h3 id="数组去重"><strong>数组去重</strong></h3>
<ul>
<li><p>利用 Set</p>
<pre><code>var unique = (arr) =&gt; [...new Set(arr)]</code></pre></li>
<li><p>利用 filter</p>
<pre><code>var unique = (arr) =&gt; arr.filter((item, index)=&gt; {
  const isCurrent = arr.indexOf(item) === index
  return isCurrent;
})
</code></pre></li>
</ul>
<h3 id="解析对象"><strong>解析对象</strong></h3>
<p>请实现方法 parse ，作用如下：</p>
<pre><code>var object = {
 b: { c: 4 }, d: [{ e: 5 }, { ef: 6 }]
};
console.log( parse(object, &#39;b.c&#39;) == 4 ) //true
console.log( parse(object, &#39;d[0].e&#39;) == 5 ) //true
console.log( parse(object, &#39;d.0.e&#39;) == 5 ) //true
console.log( parse(object, &#39;d[1].ef&#39;) == 6 ) //true
console.log( parse(object, &#39;d.1.ef&#39;) == 6 ) //true
console.log( parse(object, &#39;f&#39;) == undefined ) //true</code></pre><pre><code>var parse = (object, key) =&gt; {
  if (!object || !key) return;
  const els = key.split(&quot;.&quot;);
  let target = object;
  let i = 0;
  while (target &amp;&amp; i &lt; els.length) {
    const el = els[i];
    const res = el.match(/^(\w+)(\[(\d+)\])?$/);
    if (res) {
      const objKey = res[1];
      target = target[objKey];
      if (res[3]) {
        const arrIndex = res[3];
        target = target &amp;&amp; target[arrIndex];
      }
    } else {
      target = null;
    }
    i++;
  }
  return target;
};</code></pre><h3 id="取整函数"><strong>取整函数</strong></h3>
<ul>
<li>向上取整: Math.ceil():</li>
<li>向下取整: Math.floor():</li>
<li>四舍五入: Math.round():</li>
</ul>
<h3 id="生成随机数"><strong>生成随机数</strong></h3>
<ul>
<li><p>产生[m, n]的随机整数</p>
<pre><code>// Math.random产生[0, 1)的随机数
const random = (m, n) =&gt; Math.ceil(Math.random() * (n - m)) + m;</code></pre></li>
<li><p>产生(m, n]的随机整数</p>
<pre><code>const random = (m, n) =&gt; {
  const value = Math.random();
  return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;
}</code></pre></li>
<li><p>产生[m, n)的随机整数</p>
<pre><code>const random = (m, n) =&gt; Math.floor(Math.random() * (n - m)) + m;</code></pre></li>
<li><p>产生(m, n)的随机整数</p>
<pre><code>  const random = (m, n) =&gt; {
    const value = Math.floor(Math.random() * (n - m));
    return value === 0 ? m + 1 : value + m;
  }</code></pre></li>
</ul>
<h3 id="常用排序算法">常用排序算法</h3>
<ul>
<li><p>冒泡排序法</p>
<p>基本思想: 两个数比较，较小的数冒泡起来，较大的数下沉</p>
<p>过程:</p>
<ul>
<li>比较相邻的两个数，如果第二个数小，就交换位置</li>
<li>从后往前两两比较，直到最前面两个数，此时最小的数被排到了前面</li>
<li>重复上述过程，依次将第 2，3...n 个最小的数排好位置</li>
</ul>
<pre><code>var bubbleSort = arr =&gt; {
  let tmp;
  let flag = false;
  for (let i = 0; i &lt; arr.length - 1; i++) { //表示排序次数
    for (let j = arr.length - 1; j &gt; i; j--) {
      if (a[j] &lt; a[j - 1]) {
        tmp = a[j];
        a[j] = a[j - 1];
        a[j - 1] = tmp;
        flag = true;
      }
    }
    if (!flag) break; //flag为false表明没有位置交换，也就是说数组已经是有序的了
  }
};</code></pre><p><strong>时间复杂度计算:</strong></p>
<p>如下: 冒泡排序的时间复杂度为 O(n^2)</p>
<pre><code>假设数组长度为n，算法执行次数为T(n)，时间复杂度为O(T(n))
T(n) = (n - 1) + (n - 2) + (n - 3) + ... + n - (n - 1)
     = ((n - 1) + 1) * (n - 2) / 2
     = 0.5 * n^2 - n
O(T(n)) = O(n^2)</code></pre><p><strong>空间复杂度计算:</strong></p>
<p>可以看到，冒泡排序并没有循环分配空间，只有变量 tmp、flag、i、j 分配了空间且与数组长度无关，因此冒泡排序的空间复杂度为 O(1)。</p>
</li>
<li><p>快速排序法</p>
<p>基本思想:</p>
<ul>
<li>先从数列中选出一个数作为参照值</li>
<li>将比这个参照值小的放到左边，大于或等于这个值的放到右边</li>
<li>对左右两列数重复上一步，直至各个区间只有一个数</li>
</ul>
<pre><code>var quickSort = arr =&gt; {
  if (arr.length &lt;= 1) return arr;
  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr.splice(pivotIndex, 1)[0];
  const left = [];
  const right = [];
  for (let i = 0; i &lt; arr.length; i++) {
    const v = arr[i];
    if (v &lt; pivot) {
      left.push(v);
    } else {
      right.push(v);
    }
  }
  return quickSort(left).concat(pivot, quickSort(right));
};</code></pre><p><strong>时间复杂度计算:</strong></p>
<p>如下: 快速排序的时间复杂度为 O(nlogn)</p>
<pre><code>假设数组长度为n，算法执行次数为T(n), 每进行一次快速排序的时间为一个单独快速排序O(n)的工作和两个n/2大小数列的递归调用T(n/2)，时间复杂度为O(T(n))
T(1) = 1;
T(n) = O(n) + 2T(n/2);
     = O(n) + 2(O(n/2) + 2T(n/4));
     = O(n) + 2O(n/2) + 4T(n/4);
     = 2O(n) + 4T(n/4);
     = 2O(n) + 4(O(n/4) + 2T(n/8));
     = 3O(n) + 8T(n/8)
     = ...
     = kO(n) + 2^kT(n/2^k);
     = kO(n) + nT(1);//n==2^k =&gt; k = log2n，2为底数
     = log2n * n + n;

O(T(n)) = O(nlogn)</code></pre></li>
<li><p>归并排序法
归并排序是建立在归并操作上的一种有效的排序方法，该算法是采用分治法的一个非常典型的应用。
基本思想:</p>
<ul>
<li>将长度为 n 的数列分为两个长度为 n/2 的子列表</li>
<li>将子列表继续分为长度为 n/4 的子列表，如此继续，直到列表长度为 1 为止</li>
<li>对子列表进行两两比较，只比较它们的第一个数，哪个列表的数小就取出这个数，并从原数组中删除，如果一个数列为空，则依次取出另一个数组中的元素，这样得到的是有序数列。</li>
<li>将这些有序数列进行合并</li>
</ul>
<pre><code>var merge = (left, right) =&gt; {
  console.log(&quot;left&quot;, left);
  console.log(&quot;right&quot;, right);
  const result = [];
  while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
    if (left[0] &lt; right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  return result.concat(left, right);
};

var mergeSort = arr =&gt; {
  if (arr.length &lt;= 1) return arr;
  const pivotIndex = Math.floor(arr.length / 2);

  const left = arr.slice(0, pivotIndex);
  const right = arr.slice(pivotIndex);
  return merge(mergeSort(left), mergeSort(right));
};</code></pre><p><strong>时间复杂度计算:</strong></p>
<p>可以看到归并排序把一个规模为 n 的问题分解成了一个 merge 操作和两个规模为 n/2 的问题，merge 耗时为 O(n)，则</p>
<pre><code>T(n) = O(n) + 2T(n/2);</code></pre><p>因此，同快速排序一样归并排序的时间复杂度为 O(nlogn)。</p>
</li>
</ul>
<h3 id="操作数组"><strong>操作数组</strong></h3>
<ul>
<li><p>shift</p>
<p>该方法用于将数组的第一个元素从其中删除，并返回第一个元素的值。如果数组为空，则不进行任何操作，返回 undefined 值，该方法不会创建新数组而是从原数组直接进行修改。</p>
<pre><code>const arr = [1, 2];
const v = arr.shift();
console.log(v); // 1
console.log(arr); // [2]
</code></pre></li>
<li><p>unshift</p>
<p>该方法向数组中开头添加一个或多个元素，并返回数组的新长度。</p>
<pre><code>const arr = [1, 2];
const v = arr.unshift(0);
console.log(v); // 3
console.log(arr); // [0, 1, 2]

const v1 = arr.unshift(3, 4);
console.log(v1); // 5
console.log(arr); // [3, 4, 0, 1, 2]
</code></pre></li>
<li><p>pop</p>
<p>该方法用于删除并返回数组的最后一个元素，如果数组为空，则 pop 不改变数组，并返回 undefined 值，该方法不会创建新数组而是从原数组直接进行修改。</p>
<pre><code>const arr = [1, 2];
const v = arr.pop();
console.log(v); // 2
console.log(arr); // [1]</code></pre></li>
<li><p>slice</p>
<p>该方法返回一个新的数组对象，这个对象由一个 begin 和 end(不包括 end)决定的原数组的浅拷贝，原数组不会被改变。</p>
<p><strong>语法:</strong></p>
<pre><code>arr.slice(begin, end);</code></pre><p><strong>参数:</strong></p>
<pre><code>begin(可选): 拷贝元素的开始位置(包含开始位置)，默认为0，如果为负数，则表示从原数组的倒数第几个元素开始拷贝。
end(可选): 拷贝元素的结束位置(不包括结束位置)，如果省略或大于数组长度，则拷贝到最后一个元素(包含最后一个元素)。如果为负数，则表示从拷贝到原数组的倒数第几个元素。</code></pre><p><strong>实例:</strong></p>
<pre><code>var a = [1, 2, 3, 4];
var b = a.slice(1, 3);// [2, 3]
var c = a.slice(1);// [2, 3, 4]
var d = a.slice();// [1, 2, 3, 4]</code></pre></li>
<li><p>splice</p>
<p>该方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组的形式返回被修改的内容，此方法会改变原数组。</p>
<p><strong>语法:</strong></p>
<pre><code>array.splice(start, deleteCount, item1, item2, ...)</code></pre><p><strong>参数:</strong></p>
<pre><code>start:

指定修改的开始位置，从 0 开始，如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表
示从数组末位开始的第几位(从-1 计数，-n 表示倒数第 n 个元素);如果负数的绝对值大于数组长度，则表示开始位置为第 0 位。

deleteCount(可选):

表示要删除的元素个数，如果省略 deleteCount 或 deleteCount 的值大于 start 之后的元素的总数，则 start 后的元素都将被删除(含第 start 位);deleteCount 是 0 或负数，则不删除元素。

item1, item2,...(可选):

要添加进数组的元素，从 start 位置开始，如果不指定，则 splice()删除元素。
</code></pre><p><strong>实例:</strong></p>
<pre><code>var a=[1,2,3,4,5];
//1. a.splice(1, 3)从第二个元素开始删除三个元素 a 变为[1,5]
//2. 元素 5、2、1 添加到数组删除的位置，则 a 变为[1, 5, 2, 1, 5]
var b = a.splice(1,3,5,2,1); // b: [2, 3, 4]，为被删除的元素
console.log(a);[1, 5, 2, 1, 5]
</code></pre><ul>
<li>cancat</li>
</ul>
<p>该方法用于合并多个数组，此方法不会改变原数组，而是返回一个新数组。</p>
<p><strong>语法:</strong></p>
<pre><code>var newArray = arr1.cancat(arr2, arr3, ..., arrN)</code></pre><p><strong>参数:</strong></p>
<pre><code>arrN: 要合并的数组</code></pre><p><strong>实例:</strong></p>
<pre><code>var arr1 = [1];
var arr2 = [2];
var arr3 = [3, 4];
var newArr1 = arr1.concat(); // [1]
var newArr2 = arr1.concat(arr2, arr3);
console.log(newArr);//[1, 2, 3, 4]</code></pre></li>
<li><p>sort
该方法用于对数组的元素进行排序，并返回数组，此方法会改变原数组。</p>
<pre><code>  /*
  compareFunction: 用于指定按照某种顺序进行排序的函数，如果省略，元
                    素按照转换为字符串的各个字符的Unicode编码顺序进行升序排序。
  compareFunction(a, b): a和b分别表示第一个比较的元素和第二个比较的元素，函数返回值决定了如何排序
                        1. 小于0则a排在b前面
                        2. 等于0，可能保持相对位置不变(并不是所有浏览器都遵守)
                        3. 大于0，则a排在b后面
  */
  array.sort(compareFunction)

  var a=[&#39;b&#39;,&#39;a&#39;];
  //a的ASCII码比b的ASCII码小，所以a排在前面
  var b = a.sort(); //[&#39;a&#39;, &#39;b&#39;]
  console.log(a); // [&#39;a&#39;, &#39;b&#39;]

  var c =[10, 2];
  //10，2转换为字符串&#39;10&#39;, &#39;2&#39;进行比较，因为&#39;1&#39;比&#39;2&#39;的的ASCII码小，所以10排前面
  var d = c.sort(); //[10, 2]

  var e = c.sort((a, b) =&gt; a - b); //[10, 2]</code></pre></li>
<li><p>filter</p>
<p>该方法通过预先设定的函数来筛选目标元素，此方法不会改变原数组。</p>
<p><strong>语法:</strong></p>
<pre><code>var newArray = array.filter(callback(item, index, arr), thisArg)</code></pre><p><strong>参数:</strong></p>
<pre><code>  callback: 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参
            数：
            item: 当前正则处理的元素
            index(可选): 当前正则处理元素的索引
            arr(可选): 原始数组(调用了filter方法的数组)
  thisArg(可选): 执行 callback 时，用于 this 的值。</code></pre><p><strong>返回值:</strong>
一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>
<p><strong>实例:</strong></p>
<pre><code>const new arr = [1, 2].filter((e, index, arr)=&gt; e &gt; 1); //[2]</code></pre></li>
<li><p>reverse
该方法将数组中的元素位置颠倒，并返回颠倒后的数组，该方法会改变原数组。</p>
<pre><code>var a = [1, 2, 3];
var b = a.reverse(); //[3, 2, 1];
console.log(a); //[3, 2, 1];</code></pre></li>
</ul>
