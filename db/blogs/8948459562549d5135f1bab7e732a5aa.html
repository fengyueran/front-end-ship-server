<div class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#åŸºæœ¬æ¦‚å¿µ"><span class="toc-number">1.</span> <span class="toc-text">åŸºæœ¬æ¦‚å¿µ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#æ ‘ç›¸å…³çš„æœ¯è¯­"><span class="toc-number">2.</span> <span class="toc-text">æ ‘ç›¸å…³çš„æœ¯è¯­</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#æ“ä½œæ ‘"><span class="toc-number">3.</span> <span class="toc-text">æ“ä½œæ ‘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#èŠ‚ç‚¹"><span class="toc-number">3.1.</span> <span class="toc-text">èŠ‚ç‚¹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#æ ‘"><span class="toc-number">3.2.</span> <span class="toc-text">æ ‘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeçš„æ–¹æ³•"><span class="toc-number">3.3.</span> <span class="toc-text">Treeçš„æ–¹æ³•</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#æ ‘çš„å®Œæ•´å®ç°"><span class="toc-number">3.4.</span> <span class="toc-text">æ ‘çš„å®Œæ•´å®ç°</span></a></li></ol></div></li></ol></div><h3 id="åŸºæœ¬æ¦‚å¿µ"><strong>åŸºæœ¬æ¦‚å¿µ</strong></h3>
<p>æ ‘æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œä¹‹æ‰€ä»¥ç§°ä¹‹ä¸ºæ ‘æ˜¯å› ä¸ºå…¶ç»“æ„ç±»ä¼¼äºå€’ç½®çš„ğŸŒ²ï¼Œå®ƒçš„æ ¹åœ¨ä¸Šï¼Œæå¶åœ¨ä¸‹ã€‚æ ‘ä¸­ä¸€ä¸ªæœ€åŸºæœ¬çš„æ•°æ®ç§°ä¸ºèŠ‚ç‚¹(Node)ï¼Œå¯¹åº”äºğŸŒ²ä¸­çš„æ¯ä¸€ä¸ªåˆ†å‰ã€‚æ ‘å…·æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹(root)ï¼Œæ ¹èŠ‚ç‚¹ä¹‹ä¸‹å¯èƒ½å…·æœ‰å¤šä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹é—´é€šè¿‡è¾¹(edge)ç›¸è¿ï¼Œè¡¨ç¤ºå®ƒä»¬ä¹‹é—´çš„å…³ç³»ã€‚è¿™ç§ç»“æ„ç±»ä¼¼äºHtmlæ–‡æ¡£ï¼Œå…¬å¸çš„ç»„ç»‡ç»“æ„...</p>
<center>![æ ‘çš„ç»“æ„ç¤ºæ„å›¾](https://i.imgur.com/C9MVN2F.png)</center>
<center>å›¾1. æ ‘çš„ç»“æ„ç¤ºæ„å›¾ </center>

<h3 id="æ ‘ç›¸å…³çš„æœ¯è¯­"><strong>æ ‘ç›¸å…³çš„æœ¯è¯­</strong></h3>
<ul>
<li>æ ¹ç»“ç‚¹: æ ‘æœ€é¡¶å±‚ç»“ç‚¹ï¼Œä¹Ÿæ˜¯æ ‘ä¸­å”¯ä¸€ä¸€ä¸ªæ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œå¦‚å›¾1ä¸­çš„èŠ‚ç‚¹1ã€‚</li>
<li>è¾¹: ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„è¿æ¥ã€‚</li>
<li>çˆ¶ç»“ç‚¹: ä¸€ä¸ªèŠ‚ç‚¹æœ‰å­èŠ‚ç‚¹åˆ™ç§°è¿™ä¸ªèŠ‚ç‚¹æ˜¯å…¶å­ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚</li>
<li>å…„å¼Ÿç»“ç‚¹: å…·æœ‰ç›¸åŒçˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹äº’ä¸ºå…„å¼ŸèŠ‚ç‚¹ï¼Œå¦‚å›¾ä¸­çš„7ã€8ã€9ã€‚</li>
<li>å¶å­ç»“ç‚¹: æ ‘ä¸­æ²¡æœ‰å­ç»“ç‚¹çš„ç»“ç‚¹(æ ‘å¾—æœ«ç«¯)ï¼Œå¦‚å›¾1ä¸­çš„6ã€7ã€8ã€9ã€10ã€‚</li>
<li>å±‚æ¬¡: èŠ‚ç‚¹çš„å±‚æ¬¡ä»æ ¹å¼€å§‹å®šä¹‰ï¼Œæ ¹ä¸ºç¬¬ä¸€å±‚ï¼Œæ ¹çš„å­èŠ‚ç‚¹ä¸ºç¬¬äºŒå±‚ï¼Œä¾æ¬¡ç±»æ¨</li>
<li>æ·±åº¦: æ ‘ä¸­ç»“ç‚¹çš„æœ€å¤§å±‚æ¬¡ç§°ä¸ºæ ‘çš„æ·±åº¦</li>
</ul>
<h3 id="æ“ä½œæ ‘"><strong>æ“ä½œæ ‘</strong></h3>
<p>åœ¨è®¡ç®—æœºç§‘å­¦ä¸­æ ‘æ˜¯ä¸€ç§ç”¨æ¥æ¨¡æ‹Ÿåˆ†å±‚æ•°æ®çš„æ•°æ®ç»“æ„ï¼Œæ ‘ç”±å¤šä¸ªèŠ‚ç‚¹æ„æˆï¼Œè€Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰è‡ªèº«çš„æ•°æ®(data)åŠæŒ‡å‘å…¶ä»–èŠ‚ç‚¹(parentã€children)çš„æŒ‡é’ˆï¼Œå¦‚ä¸‹å®šä¹‰äº†èŠ‚ç‚¹å’Œæ ‘ã€‚</p>
<h4 id="èŠ‚ç‚¹">èŠ‚ç‚¹</h4>
<ul>
<li>data: èŠ‚ç‚¹çš„æ•°æ®</li>
<li>parent: èŠ‚ç‚¹çš„çˆ¶äº²</li>
<li>children: èŠ‚ç‚¹çš„å­èŠ‚ç‚¹</li>
</ul>
<pre><code>class Node {
  constructor(data) {
    this.data = data;
    this.parent = null;
    this.children = [];
  }
}</code></pre><h4 id="æ ‘">æ ‘</h4>
<p>æ ‘æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹root</p>
<pre><code>class Tree {
  constructor(data) {
    this._root = new Node(data);
  }
}</code></pre><p>æ„é€ å›¾1ä¸­çš„æ ‘</p>
<pre><code>  const tree = new Tree({ id: 1, value: 1 });
  const node2 = new Node({ id: 2, value: 2 });
  node2.parent = tree._root;
  tree._root.children.push(node2);

  const node3 = new Node({ id: 3, value: 3 });
  node3.parent = tree._root;
  tree._root.children.push(node3);

  const node4 = new Node({ id: 4, value: 4 })
  node4.parent = node2;
  node2.children.push(node4);

  const node5 = new Node({ id: 5, value: 5 })
  node5.parent = node3;
  node3.children.push(node5);

  const node6 = new Node({ id: 6, value: 6 })
  node6.parent = node3;
  node3.children.push(node6);

  const node7 = new Node({ id: 7, value: 7 })
  node7.parent = node4;
  node4.children.push(node7);
  const node8 = new Node({ id: 8, value: 8 })
  node8.parent = node4;
  node4.children.push(node8);
  const node9 = new Node({ id: 9, value: 9 })
  node9.parent = node4;
  node4.children.push(node9);

  const node10 = new Node({ id: 10, value: 10 })
  node10.parent = node5;
  node5.children.push(node10);</code></pre><h4 id="treeçš„æ–¹æ³•">Treeçš„æ–¹æ³•</h4>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬å°†è¦åˆ›å»ºä»¥ä¸‹äº”ç§æ–¹æ³•ã€‚</p>
<ul>
<li><p>traverseDF(callback)</p>
</li>
<li><p>traverseBF(callback)</p>
</li>
<li><p>contains(callback, traversalType)</p>
</li>
<li><p>add(data, toId, traversalType)</p>
</li>
<li><p>remove(node, parent)</p>
</li>
</ul>
<p><strong>æ–¹æ³•1/5: traverseDF(callback)</strong>
è¿™ç§æ–¹æ³•ä»¥æ·±åº¦ä¼˜å…ˆéå†æ ‘ï¼Œå³å°½å¯èƒ½æ·±çš„éå†æ ‘çš„åˆ†æ”¯ï¼Œå†è¿›è¡Œå›æº¯ã€‚åœ¨è¿™é‡Œé€šè¿‡é€’å½’å’Œéé€’å½’çš„æ–¹å¼æ¥å®ç°ã€‚</p>
<ul>
<li><p>é€’å½’æ–¹æ³•
æ ‘æœ¬æ¥å°±æ˜¯ä¸€ä¸ªé€’å½’ç»“æ„ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“æƒ³åˆ°ç”¨é€’å½’çš„æ–¹å¼æ¥éå†æ ‘ã€‚å¯¹äºå›¾1ä¸­çš„æ ‘æ¥è¯´é€šè¿‡å¦‚ä¸‹é€’å½’æ–¹æ³•æ·±åº¦ä¼˜å…ˆéå†çš„ç»“æœæ˜¯: 7ã€8ã€9ã€4ã€2ã€10ã€5ã€6ã€3ã€1ã€‚å½“ç„¶ï¼Œæ·±åº¦ä¼˜å…ˆå¹¶ä¸ä¸€å®šæ˜¯è¿™ä¸ªé¡ºåºï¼Œæ·±åº¦ä¼˜å…ˆï¼Œé‡åœ¨æ·±åº¦ï¼Œåœ¨è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†çš„æ—¶å€™ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹è¿˜æœ‰å­èŠ‚ç‚¹ï¼Œä¼šä¼˜å…ˆå‘æ›´æ·±çš„å­èŠ‚ç‚¹è¿›è¡Œæœç´¢ï¼Œè€Œä¸æ˜¯æœç´¢åŒå±‚çš„å…„å¼ŸèŠ‚ç‚¹ã€‚</p>
<pre><code>  traverseDF(callback) {
    const recuseNode = (node) =&gt; {
      for (let i = 0; i &lt; node.children.length; i++) {
        recuseNode(node.children[i]);
      }
      callback(node);
    };
    recuseNode(this._root);
  }

  tree.traverseDF((node) =&gt; {
    console.log(node.data.id); // 7 8 9 4 2 10 5 6 3 1
  });</code></pre></li>
</ul>
<ul>
<li><p>éé€’å½’æ–¹æ³•
éé€’å½’æ–¹æ³•ä¸»è¦æ˜¯åˆ©ç”¨æ ˆçš„ç‰¹æ€§æ¥å®ç°ã€‚å¯¹äºå›¾1ä¸­çš„æ ‘æ¥è¯´é€šè¿‡å¦‚ä¸‹æ–¹æ³•æ·±åº¦ä¼˜å…ˆéå†çš„ç»“æœæ˜¯: 1ã€2ã€4ã€7ã€8ã€9ã€3ã€5ã€10ã€6ã€‚</p>
<pre><code>  traverseDFWithOutRecuse(callback) {
    let currentTree = this._root;
    let stack = [currentTree];
    while (stack.length) {
      currentTree = stack.pop();
      callback(currentTree);
      for (let i = currentTree.children.length - 1; i &gt;= 0; i--) {
        stack.push(currentTree.children[i]);
      }
    }
  }

  tree.traverseDFWithOutRecuse((node) =&gt; {
    console.log(node.data.id); // 1 2 4 7 8 9 3 5 10 6
  });</code></pre></li>
</ul>
<p><strong>æ–¹æ³•2/5: traverseBF(callback)</strong></p>
<p>è¿™ç§æ–¹æ³•ä»¥å¹¿åº¦ä¼˜å…ˆéå†æ ‘: ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œå¯¹æ¯ä¸€å±‚èŠ‚ç‚¹ä¾æ¬¡è®¿é—®ï¼Œè®¿é—®ä¸€å±‚è¿›å…¥ä¸‹ä¸€å±‚ï¼Œè€Œä¸”æ¯ä¸ªèŠ‚ç‚¹åªèƒ½è®¿é—®ä¸€æ¬¡ã€‚å¯¹äºå›¾1ä¸­çš„æ ‘æ¥è¯´é€šè¿‡å¹¿åº¦ä¼˜å…ˆéå†çš„ç»“æœæ˜¯: 1ã€2ã€3ã€4ã€5ã€6ã€7ã€8ã€9ã€10ã€‚</p>
<pre><code>  class Queue {
    constructor() {
        this.dataStore = [];
    }

    add(element) {
        this.dataStore.push(element);
    }

    pop() {
        return this.dataStore.shift();
    }
  }

  traverseBF(callback) {
    let currentTree = this._root;
    const queue = new Queue();
    while (currentTree) {
      for (let i = 0; i &lt; currentTree.children.length; i++) {
        queue.add(currentTree.children[i]);
      }
      callback(currentTree);
      currentTree = queue.pop();
    }
  }</code></pre><p><strong>æ–¹æ³•3/5: contains(callback, traversalType)</strong>
containsæ–¹æ³•ç”¨äºåœ¨æ ‘ä¸­æœç´¢ç‰¹å®šçš„å€¼ï¼Œå®ƒæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªä¸ºå›è°ƒå‡½æ•°ï¼Œæ¯éå†åˆ°ä¸€ä¸ªèŠ‚ç‚¹å°±ä¼šä»¥è¯¥èŠ‚ç‚¹ä¸ºå›è°ƒå‚æ•°å›è°ƒï¼Œç¬¬äºŒä¸ªä¸ºéå†çš„ç±»å‹(æ·±åº¦éå†æˆ–å¹¿åº¦éå†)</p>
<pre><code> contains(callback, traversalType) {
    const traverse = this[traversalType];
    traverse.call(this, callback);
  }
</code></pre><p>æœç´¢ç‰¹å®šidçš„èŠ‚ç‚¹å°±å¯ä»¥è¿™æ ·å†™ï¼š</p>
<pre><code>tree.contains((node) =&gt; {
  if (node.id === &#39;5&#39;) {
    console.log(node);
  }
}, &#39;traverseDF&#39;);</code></pre><p><strong>æ–¹æ³•4/5: add(data, toId, traversalType)</strong></p>
<p>è¯¥æ–¹æ³•ç”¨äºåœ¨æŒ‡å®šèŠ‚ç‚¹æ·»åŠ èŠ‚ç‚¹ã€‚</p>
<pre><code>  add(data, toId, traversalType) {
    let parent = null;
    //éå†æ˜¯å¦æœ‰ç›®æ ‡èŠ‚ç‚¹
    this.contains((node) =&gt; {
      if (node.data === toId) {
        parent = node.parent;
      }
    }, traversalType);
    //æœ‰ç›®æ ‡èŠ‚ç‚¹åˆ™æ·»åŠ èŠ‚ç‚¹
    if (parent) {
      const newNode = new Node(data);
      newNode.parent = parent;
      parent.children.push(newNode);
    } else {
      throw new Error(`can&#39;t find the target node`);
    }
  }</code></pre><p><strong>æ–¹æ³•5/5: remove(fromId, traversalType)</strong></p>
<p>è¯¥æ–¹æ³•ç”¨äºåœ¨æŒ‡å®šèŠ‚ç‚¹ä¸‹çš„èŠ‚ç‚¹ã€‚</p>
<pre><code>  remove(fromId, traversalType) {
    let parent = null;
    let deleteNode = null;
    //éå†æ˜¯å¦æœ‰ç›®æ ‡èŠ‚ç‚¹
    this.contains((node) =&gt; {
      if (node.id === fromId) {
        parent = node.parent;
        deleteNode = node;
      }
    }, traversalType);

    //æœ‰ç›®æ ‡èŠ‚ç‚¹åˆ™éå†ç›®æ ‡èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯å¦æœ‰è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œæœ‰åˆ™åˆ é™¤
    if (parent) {
      const findIndex = parent.children.findIndex(node =&gt; deleteNode.id === node.id);
      if (findIndex &gt;= 0) {
        parent.children.splice(findIndex, 1);
      }
    } else {
      throw new Error(`can&#39;t find the target node`);
    }
  }</code></pre><h4 id="æ ‘çš„å®Œæ•´å®ç°">æ ‘çš„å®Œæ•´å®ç°</h4>
<pre><code>class Queue {
  constructor() {
    this.dataStore = [];
  }

  add(element) {
    this.dataStore.push(element);
  }

  pop() {
    return this.dataStore.shift();
  }
}


class Node {
  constructor(data) {
    this.data = data;
    this.parent = null;
    this.children = [];
  }
}

class Tree {
  constructor(data) {
    this._root = new Node(data);
  }

  traverseDF(callback) {
    const recuseNode = (node) =&gt; {
      for (let i = 0; i &lt; node.children.length; i++) {
        recuseNode(node.children[i]);
      }
      callback(node);
    };
    recuseNode(this._root);
  }

  traverseDFWithOutRecuse(callback) {
    let currentTree = this._root;
    let stack = [currentTree];
    while (stack.length) {
      currentTree = stack.pop();
      callback(currentTree);
      for (let i = currentTree.children.length - 1; i &gt;= 0; i--) {
        stack.push(currentTree.children[i]);
      }
    }
  }

  traverseBF(callback) {
    let currentTree = this._root;
    const queue = new Queue();
    while (currentTree) {
      for (let i = 0; i &lt; currentTree.children.length; i++) {
        queue.add(currentTree.children[i]);
      }
      callback(currentTree);
      currentTree = queue.pop();
    }
  }

  contains(callback, traversalType) {
    const traverse = this[traversalType];
    traverse.call(this, callback);
  }

  add(data, toId, traversalType) {
    let parent = null;
    this.contains((node) =&gt; {
      if (node.data === toId) {
        parent = node.parent;
      }
    }, traversalType);
    if (parent) {
      const newNode = new Node(data);
      newNode.parent = parent;
      parent.children.push(newNode);
    } else {
      throw new Error(`can&#39;t find the target node`);
    }
  }

  remove(fromId, traversalType) {
    let parent = null;
    let deleteNode = null;
    this.contains((node) =&gt; {
      if (node.id === fromId) {
        parent = node.parent;
        deleteNode = node;
      }
    }, traversalType);

    if (parent) {
      const findIndex = parent.children.findIndex(node =&gt; deleteNode.data === node.data);
      if (findIndex &gt;= 0) {
        parent.children.splice(findIndex, 1);
      }
    } else {
      throw new Error(`can&#39;t find the target node`);
    }
  }
}</code></pre>