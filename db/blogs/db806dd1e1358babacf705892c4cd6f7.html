<h1>JavaScript的执行机制</h1><div class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#event-loop事件循环"><span class="toc-number">2.</span> <span class="toc-text">event loop(事件循环)</span></a></li></ol></div><p>记得曾经看到过这样一道面试题：</p>
<p>console 的输出顺序是什么？</p>
<pre><code class="language-code">setTimeout(() =&gt; {
  console.log(&quot;1111&quot;);
}, 0);

console.log(&quot;2222&quot;);

new Promise((resolve, reject) =&gt; {
  console.log(&quot;3333&quot;);
  resolve()
}).then(() =&gt; {
  console.log(&quot;4444&quot;);
});</code></pre>
<p>想要判断 console 的输出顺序，必须了解 JavaScript 的执行机制，不然只能靠感觉去猜，陷入深深的迷茫中 😇😇😇...</p>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><p>执行栈(Call Stack)</p>
<p>栈是一种数据结构，按照先进后出的原则存储数据，先进入的数据被压入栈底，后进入的数据在栈顶，就像我们叠盘子一样。执行栈就是用栈的特性来管理函数的调用。当函数调用时就压入栈底，执行完后弹出。</p>
</li>
<li><p>事件表(Event Table)</p>
<p>异步操作的事件像 setTimeout、Promise 等都会先加入到 Event Table，它是一个特殊的数据结构，可以知道在特定的事件完成后触发特定的函数，比如 timeout、click 事件，就将回调函数加入到 Event Queue。</p>
</li>
<li><p>事件队列(Event Queue)</p>
<p>队列也是一种数据结构，按照先进先出的原则存储数据，先进入的数据进入对首，后进入的数据进入对尾，就像超市排队结账一样。事件队列就是用队列的特性来管理函数的调用。它接收来自 Event Table 的回调函数，但是并不执行，需要通过某种机制将函数加入到调用栈，这个机制就是事件循环(Event Loop)。</p>
</li>
<li><p>同步任务</p>
<p>前一个任务执行完后才能去执行下一个任务，程序的执行顺序和任务的排列顺序是一致的，比如煮面的同步做法，我们要先烧水，等 5 分钟后水开了，备菜，再煮面。在 js 中，同步任务(如渲染元素)在主线程中执行，且立即执行。</p>
</li>
<li><p>异步任务</p>
<p>一个任务比较耗时，其他任务不用等到这个耗时任务完成后再执行，这个耗时任务就是异步任务。煮面的异步做法就是不等水开就去备菜，再煮面。js 中的异步任务(如加载图片)不进入主线程，而是先加入 Event Table，特定事件触发后将回调函数加入 Event Queue，最后加入到调用栈执行。</p>
</li>
<li><p>macrotask(宏任务)和 microtask(微任务)</p>
<p>除了广义的同步任务和异步任务，js 对任务还有更精细的划分，即 macrotask(宏任务，在 WHATWG 中叫做 task)和 microtask(微任务)，在件循环中代表了不同的执行时机。js 中宏任务和微任务的划分大致如下：
<strong>宏任务</strong>：整体代码 script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI 渲染
<strong>微任务</strong>：Promise、process.nextTick、Object.observe(已废弃)、MutationObserver(h5 新特性)
它们的优先级如下：
process.nextTick &gt; promise.then &gt; setImmediate &gt; setTimeout = setInterval</p>
</li>
</ul>
<h3 id="event-loop事件循环">event loop(事件循环)</h3>
<p>众所周知 JavaScript 是一门<strong>单线程语言</strong>，也就意味着同一时间只能完成一个任务。为了防止一些耗时的任务(如加载图片、ajax 请求)影响我们的体验，就需要一种机制去调度任务，这个机制就是 event loop(事件循环)。</p>
<p>我们先来看看 js 引擎执行任务的大致流程：</p>
 <center><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/37.JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/js%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" /></center>
 <center>js 任务执行流程</center>

<p>上述的往复执行的机制，就是事件循环，更确切地说，一个事件循环是从宏任务开始，执行完所有微任务(如果有的话)后结束，如下图所示：</p>
 <center><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/37.JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/event%20loop%E7%A4%BA%E6%84%8F%E5%9B%BE.png" /></center>
 <center>event loop的一个循环</center>
