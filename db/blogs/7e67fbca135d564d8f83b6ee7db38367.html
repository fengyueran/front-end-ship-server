<p><strong>func.call 和 func.apply</strong>
func.call 和 func.apply 的作用一样都是改变执行上下文，只是接收参数的形式不同。</p>
<ul>
<li><p>func.apply(context, param)
func.apply 方法传入两个参数，第一个参数是上下文对象，为空则指向全局对象，第二个参数是函数参数组成的数组。
如下，给出了 apply 函数的源码大义，可以看到传入的数组参数会拼接成参数列表组成的一个字符串，并将需要执行的函数绑定到目标对象上。</p>
<pre><code>Function.prototype.apply = function(target, arr){
  target = target || window
  target.fn = this;
   if(arr == []) {
      return target.fn;
      delete target.fn;
   } else {
      var args = [];
      for(var i = 0; i &lt; arr.length; i ++){
        args.push(&#39;arr[&#39;+ i + &#39;]&#39;);
      }
      //eval()函数会将传入的字符串当做JavaScript代码进行执行
      var result = eval(&#39;target.fn(&#39;+ args.join(&#39;,&#39;) +&#39;)&#39;);
      delete target.fn;
      return result;
   }
}</code></pre><ul>
<li>应用 1-apply 方法数组参数特性的应用
实例 1：求数组 a = [2, 4, 1, 6]的最大值，不要遍历数组</li>
</ul>
<pre><code>/*
 target = window，this = Math.max，target.fn = window.Math.max
 result = eval(target.fn(2,4,1,6))
*/
Math.max.apply(null, a);
=&gt; 6</code></pre><p>实例 2：实现一个 log 方法来代理 console.log 方法</p>
<pre><code>  //arguments为一个对应于传递给函数参数的类数组对象Arguments，它是所有非箭头函数中可用的局部变量
  function log() {
    console.log.apply(null, arguments)
  }
  //
  log(1, 2);
  =&gt; 1
  =&gt; 2</code></pre><ul>
<li>应用 2-apply 方法改变 this 指向的应用:
如下 boy 并没有 getName 方法，但是通过 apply 改变 this 的指向达到了在 boy 中调用 girl 的 getName 方法。</li>
</ul>
<pre><code>  function getName(firstName, lastName) {
    console.log(`${firstName}.${this.name}.${lastName}`)
  };
  const girl = {
    name: &#39;lucy&#39;,
    getName,
  };
  const boy = {
    name: &#39;Jeffrey&#39;
  };
  //相当于boy.getName([&#39;Michael&#39;, &#39;Jordan&#39;])
  girl.getName.apply(boy, [&#39;Michael&#39;, &#39;Jordan&#39;]);
  =&gt; Michael.Jeffrey.Jordan</code></pre></li>
<li><p>func.call(context, param)
func.call 方法传入两个参数，第一个参数是上下文对象，第二个参数是传入的是一个参数列表，而不是单个数组。</p>
<p>如下，给出了 call 函数源码大义:</p>
<pre><code>Function.prototype.call = function(){
  var target = arguments[0] || window
  target.fn = this;
  var args = [];
  for(var i = 1; i &lt; arguments.length; i ++){
      args.push(&#39;arguments[&#39;+ i +&#39;]&#39;);
  }

  var result = eval(&#39;target.fn(&#39; + args.join(&#39;,&#39;)+&#39;)&#39;);

  delete target.fn;
  return result;
}</code></pre><ul>
<li>应用 1-call 方法改变 this 指向的应用
获取<code>&lt;div&gt;&lt;ul&gt;1&lt;/ul&gt;&lt;ul&gt;2&lt;/ul&gt;&lt;/div&gt;</code>的 ul 的内容</li>
</ul>
<pre><code> const nodes = document.querySelectorAll(&#39;ul&#39;);
 // nodes为伪数组，没有数组的遍历方法，通过[].slice.call返回真数组
 const realArr = [].slice.call(nodes);
 realArr.forEach((node)=&gt; console.log(node.innerText))
 =&gt; 1
 =&gt; 2</code></pre></li>
</ul>
<p><strong>bind 函数</strong>
bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。</p>
<pre><code>const newGetName = girl.getName.bind(boy);
newGetName(&#39;Michael&#39;, &#39;Jordan&#39;)
=&gt; Michael.Jeffrey.Jordan</code></pre><p>综上，this 的指向由其具体的执行环境决定，同时也可以通过函数的原型方法 apply、call 以及 bind 来显式地改变 this 指向。</p>
