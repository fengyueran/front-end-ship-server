<p><strong>三次握手</strong>
TCP 提供面向有连接的通信传输，面向有连接是指数据通信开始之前先做好两端的准备工作。所谓三次握手是指建立一个 TCP 连接时需要客户端和服务端总共发送三个包以确认连接的建立。在 socket 编程中，这一过程由客户端执行 connect 来触发。</p>
<p>流程图如下:</p>
 <center><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/%E9%A2%98%E5%BA%93/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" /></center>

<ul>
<li><p>第一次握手</p>
<p>客户端将标志位 SYN(Synchronize Sequence Numbers,同步序列编号)置为 1，随机产生一个序列号 seq=J，并将该数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务器确认。</p>
</li>
<li><p>第二次握手</p>
<p>服务端收到数据包后，通过标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK(ACKnowledge Character 确认字符)都置为 1，ack=J+1，随机生成一个序列号 seq=K，并将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。</p>
</li>
<li><p>第三次握手</p>
<p>客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给服务端，服务端检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务端进入 ESTABLISHED 状态，完成三次握手，随后客户端和服务端之间就可以开始传输数据了。</p>
</li>
</ul>
<p><strong>四次挥手</strong></p>
<p>四次挥手即终止 TCP 连接，断开一个 TCP 连接时需要客户端和服务端总共发送四个包以确认连接的断开。在 socket 编程中，这一过程通过任意一方执行 close 来触发。由于 TCP 连接是全双工的，因此，每个方向都必须单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN(finish,结束)来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上扔能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>中断连接端可以是客户端，也可以是服务端。</p>
<p>流程图如下:</p>
 <center><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/%E9%A2%98%E5%BA%93/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" /></center>

<ul>
<li><p>第一次挥手</p>
<p>客户端发送一个 FIN=M，用来关闭客户端到到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说“我客户端没有数据要发给你了”，但是如果你服务端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
</li>
<li><p>第二次挥手</p>
<p>服务端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务端的 FIN 报文。</p>
</li>
<li><p>第三次挥手</p>
<p>当服务端确定数据发送完成后，则向客户端发送 FIN=N 的报文，告诉客户端，好了，我这边的数据发送完了，准备好关闭连接了，服务端进入 LAST_ACK 状态。</p>
</li>
<li><p>第四次挥手</p>
<p>客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器不知道要关闭了，所以发送 ACK=1，ack=N+1 后进入 TIME_WAIT 状态，如果服务端没有收到 ACK 则可以重传。服务端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL(Maximum Segment Lifetime,报文最大生存时间，一般为 30s)后依然没有收到回复，则证明服务端已经正常关闭，那好，我客户端也可以关闭了。最终完成了四次挥手。</p>
</li>
</ul>
