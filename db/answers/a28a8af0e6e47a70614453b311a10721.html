<p>以下代码的运行结果？</p>
<pre><code class="language-js">var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x); //undefined
console.log(b.x); //{n:2}</code></pre>
<ul>
<li><p>a
计算单值表达式 a，得到 a 的引用, 这里的 a 是初始 a。</p>
</li>
<li><p>a.x
a.x 将 x 这个标识符作为<code>·</code> 运算符的右操作数，计算表达式 a.x，得到结果值（Result），它是一个 a.x 的“引用” 这个“引用”当作一个<a href="https://www.cnblogs.com/fayin/p/11044368.html">数据结构</a>，通常有 base、name、strict 三个成员。无论 x 属性是否存在（这里暂时不存在），a.x 都会被表达为 {&quot;base&quot;: a, &quot;name&quot;: &quot;x&quot;, ...}。而这里的 a 仍然指向旧对象。</p>
</li>
<li><p>a 计算单值表达式 a
得到 a 的引用 这里的 a 是初始 a</p>
</li>
<li><p>a = {n:2}
a = {n:2}赋值操作使得左操作数 a 作为一个引用被覆盖，同时操作完成后返回右操作数 {n:2} 这里的这个 a 的的确确被覆盖了，这意味着往后通过 a 访问到的只能是新对象。但是，有一个 a 是不会变的，那就是被 a.x 的 Result 保存下来的引用 a，它作为一个当时既存的、不会再改变的结果，仍然指向旧对象。
a.x = {n:2} 指向旧对象的 a 新建了 x 属性，这个属性关联对象 {n:2} 注意，这里对 a.x 进行了写操作（赋值），直到这次赋值发生的那一刻，才有了为旧对象动态创建 x 属性这个过程。
所以，旧对象（丧失了引用的最初对象）和新对象（往后通过 a 可以访问到的那个对象）分别变成：</p>
<pre><code>// 旧对象
a:{
  n:1,
  x:{n:2}
}
// 新对象
a:{
  n:2
}</code></pre></li>
</ul>
<p>现在，执行 console.log(a.x)，这里 a.x 被作为 rhs（右手端） 读取，引擎会开始检索是否真的有 a[&quot;x&quot;] 这个东西，因为此时通过 a 能访问到的只能是新对象，它自然是没有 x 属性的，所以打印 undefined。而且 —— 直到这次读取发生的那一刻，才有了为新对象动态创建 x 属性这个过程。</p>
<p>Note：也就是说，在引擎从左到右计算表达式的过程中，尽管可能遇见类似 a.x 这样本不存在的属性，但无论如何，都会存在 {&quot;base&quot;: a, &quot;name&quot;: &quot;x&quot;, ...} 这样的数据结构，而在后续真正对 x 进行 读写 的时候，这个 x 才会得到创建。</p>
<p>这个代码块所做的事情，实际上是向旧有对象添加一个指向新对象的属性，并且如果我们想要在后续仍然持有对旧对象的访问，可以在赋值覆盖之前新建一个指向旧对象的变量。</p>
