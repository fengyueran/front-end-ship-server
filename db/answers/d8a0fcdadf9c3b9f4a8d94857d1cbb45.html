<p>回流和重绘可以说是每一个 web 开发者都经常听到的两个词语，我也不例外，可是我之前一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合一些例子，写了这篇文章，希望可以帮助到大家。</p>
<h3 id="浏览器的渲染过程">浏览器的渲染过程</h3>
<p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn">MDN</a>）</p>
<p><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/76.%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/render.png" alt="webkit渲染过程"></p>
<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>
<ol>
<li>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</li>
<li>将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给 GPU，展示在页面上。（这一步其实还有很多内容，比如会在 GPU 将多个合成层合并为同一个层，并展示在页面中。而 css3 硬件加速的原理则是新建合成层）</li>
</ol>
<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>
<h3 id="生成渲染树">生成渲染树</h3>
<p><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/76.%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/render-tree.png" alt="生成渲染树"></p>
<p>为了构建渲染树，浏览器主要完成了以下工作：</p>
<ol>
<li>从 DOM 树的根节点开始遍历每个可见节点。</li>
<li>对于每个可见的节点，找到 CSSOM 树中对应的规则，并应用它们。</li>
<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>
</ol>
<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>
<ul>
<li>一些不会渲染输出的节点，比如 script、meta、link 等。</li>
<li>一些通过 css 进行隐藏的节点。比如 display:none。注意，利用 visibility 和 opacity 隐藏的节点，还是会显示在渲染树上的。只有 display:none 的节点才不会显示在渲染树上。</li>
</ul>
<p><strong>注意：渲染树只包含可见的节点</strong></p>
<h3 id="回流">回流</h3>
<p>前面我们通过构造渲染树，我们将可见 DOM 节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>
<p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;
    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div style=&quot;width: 50%&quot;&gt;
      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>我们可以看到，第一个 div 将节点的显示尺寸设置为视口宽度的 50%，第二个 div 将其尺寸设置为父节点的 50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）</p>
<p><img src="http://blog-bed.oss-cn-beijing.aliyuncs.com/76.%E4%BB%8B%E7%BB%8D%E4%B8%8B%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/layout.png" alt=""></p>
<h3 id="重绘">重绘</h3>
<p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p>
<p>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>
<h2 id="何时发生回流重绘">何时发生回流重绘</h2>
<p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>
<ul>
<li>添加或删除可见的 DOM 元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>
<li>页面一开始渲染的时候（这肯定避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
</ul>
<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p>
<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>
<h2 id="浏览器的优化机制">浏览器的优化机制</h2>
<p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect</li>
<li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 100; i++) {
  //每次循环都更改了style，因此每次访问clientWidth都需要立即清空队列，重流以获取更改后的布局信息
  const width = box1.clientWidth + 1;
  box1.style.width = width + &quot;px&quot;;
}</code></pre>
<p>我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>。如果要使用它们，最好将值缓存起来。需要注意的是<strong>并不是只要访问了上述的属性就一定会重流</strong>，只有当浏览器的队列不为空时，为了返回当前修改样式后的布局信息时才会清空触发，如下，在没有其他样式修改的情况下，只有第一次访问 clientWidth 会回流，剩余的 99 次都不会触发。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 100; i++) {
  console.log(&quot;node.clientWidth&quot;, node.clientWidth);
}</code></pre>
<h2 id="减少回流和重绘">减少回流和重绘</h2>
<p>好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>
<h3 id="最小化重绘和重排">最小化重绘和重排</h3>
<p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对 DOM 和样式的修改，然后一次处理掉。考虑这个例子</p>
<pre><code class="language-javascript">const el = document.getElementById(&quot;test&quot;);
el.style.padding = &quot;5px&quot;;
el.style.borderLeft = &quot;1px&quot;;
el.style.borderRight = &quot;2px&quot;;</code></pre>
<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>
<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>
<ul>
<li><p>使用 cssText</p>
<pre><code class="language-javascript">const el = document.getElementById(&quot;test&quot;);
el.style.cssText += &quot;border-left: 1px; border-right: 2px; padding: 5px;&quot;;</code></pre>
</li>
<li><p>修改 CSS 的 class</p>
<pre><code class="language-javascript">const el = document.getElementById(&quot;test&quot;);
el.className += &quot; active&quot;;</code></pre>
</li>
</ul>
<h3 id="批量修改-dom">批量修改 DOM</h3>
<p>当我们需要对 DOM 对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>
<ol>
<li>使元素脱离文档流</li>
<li>对其进行多次修改</li>
<li>将元素带回到文档中。</li>
</ol>
<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对 DOM 的所有修改都不会引起回流，因为它已经不在渲染树了。</p>
<p>有三种方式可以让 DOM 脱离文档流：</p>
<ul>
<li>隐藏元素，应用修改，重新显示</li>
<li>使用文档片段(document fragment)在当前 DOM 之外构建一个子树，再把它拷贝回文档。</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>
</ul>
<p>考虑我们要执行一段批量插入节点的代码：</p>
<pre><code class="language-javascript">function appendDataToElement(appendToElement, data) {
  let li;
  for (let i = 0; i &lt; data.length; i++) {
    li = document.createElement(&quot;li&quot;);
    li.textContent = &quot;text&quot;;
    appendToElement.appendChild(li);
  }
}

const ul = document.getElementById(&quot;list&quot;);
appendDataToElement(ul, data);</code></pre>
<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>
<p>我们可以使用这三种方式进行优化:</p>
<p><strong>隐藏元素，应用修改，重新显示</strong></p>
<p>这个会在展示和隐藏节点的时候，产生两次重绘</p>
<pre><code class="language-javascript">function appendDataToElement(appendToElement, data) {
  let li;
  for (let i = 0; i &lt; data.length; i++) {
    li = document.createElement(&quot;li&quot;);
    li.textContent = &quot;text&quot;;
    appendToElement.appendChild(li);
  }
}
const ul = document.getElementById(&quot;list&quot;);
ul.style.display = &quot;none&quot;;
appendDataToElement(ul, data);
ul.style.display = &quot;block&quot;;</code></pre>
<p><strong>使用文档片段(document fragment)在当前 DOM 之外构建一个子树，再把它拷贝回文档</strong></p>
<pre><code class="language-javascript">const ul = document.getElementById(&quot;list&quot;);
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);</code></pre>
<p><strong>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</strong></p>
<pre><code class="language-javascript">const ul = document.getElementById(&quot;list&quot;);
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);</code></pre>
<p>对于上述那种情况，我写了一个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9DOM.html">demo</a>来测试修改前和修改后的性能。然而实验结果不是很理想。</p>
<p><strong>原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</strong></p>
<h3 id="避免触发同步布局事件">避免触发同步布局事件</h3>
<p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个 p 标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>
<pre><code class="language-javascript">function initP() {
  for (let i = 0; i &lt; paragraphs.length; i++) {
    paragraphs[i].style.width = box.offsetWidth + &quot;px&quot;;
  }
}</code></pre>
<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了 box 的一个 offsetWidth 属性值，然后利用它来更新 p 标签的 width 属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p>
<pre><code class="language-javascript">const width = box.offsetWidth;
function initP() {
  for (let i = 0; i &lt; paragraphs.length; i++) {
    paragraphs[i].style.width = width + &quot;px&quot;;
  }
}</code></pre>
<p>同样，我也写了个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E9%81%BF%E5%85%8D%E5%BF%AB%E9%80%9F%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%B8%83%E5%B1%80.html">demo</a>来比较两者的性能差异。你可以自己点开这个 demo 体验下。这个对比差距就比较明显。</p>
<h3 id="对于复杂动画效果使用绝对定位让其脱离文档流">对于复杂动画效果,使用绝对定位让其脱离文档流</h3>
<p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个<a href="https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html">例子</a>。</p>
<p>打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。</p>
<p><img src="https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231048609-619022494.png" alt="image-20181210223750055"></p>
<p>从上图中，我们可以看到，帧数一直都没到 60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定 60。</p>
<h3 id="css3-硬件加速（gpu-加速）">css3 硬件加速（GPU 加速）</h3>
<p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3 硬件加速就闪亮登场啦！！</p>
<p><strong>划重点：使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</strong></p>
<p>本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。</p>
<h4 id="如何使用">如何使用</h4>
<p>常见的触发硬件加速的 css 属性：</p>
<ul>
<li>transform</li>
<li>opacity</li>
<li>filters</li>
<li>Will-change</li>
</ul>
<h4 id="效果">效果</h4>
<p>我们可以先看个<a href="https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html">例子</a>。我通过使用 chrome 的 Performance 捕获了一段时间的回流重绘情况，实际结果如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/993343/201812/993343-20181210230959987-1419348644.png" alt="image-20181210225609533"></p>
<p>从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。</p>
<h4 id="重点">重点</h4>
<ul>
<li>使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘</li>
<li>对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>
</ul>
<h4 id="css3-硬件加速的坑">css3 硬件加速的坑</h4>
<ul>
<li><p>如果你为太多元素使用 css3 硬件加速，会导致内存占用较大，会有性能问题。</p>
</li>
<li><p>在 GPU 渲染字体会导致抗锯齿无效。这是因为 GPU 和 CPU 的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn">渲染树构建、布局及绘制</a></li>
</ul>
<p><a href="https://github.com/chenjigeng/blog/edit/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E5%90%97.md">引自</a></p>
