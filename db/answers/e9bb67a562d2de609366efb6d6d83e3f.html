<h3 id="原型链继承">原型链继承</h3>
<p>原型链继承也就是通过<a href="https://juejin.im/post/5cab34def265da034c7002a6">原型链</a>的特性来实现继承:</p>
<pre><code>function Father() {
  this.name = &quot;father&quot;;
}

Father.prototype.eat = () =&gt; {
  console.log(&quot;eat&quot;);
};

Father.prototype.sleep = () =&gt; {
  console.log(&quot;sleep&quot;);
};

function Son() {
  this.name = &quot;son&quot;;
}

const father = new Father();
Son.prototype = father;

const son = new Son();
son.eat();//eat
son.sleep();//sleep</code></pre><p>new Father()得到实例 father， father 的<code>__proto__</code>指向 Father 原型 prototype，Son.prototype = father;也就意味着 Son 的实例通过原型链可以查找到 Father 原型 prototype，也就达到了继承的目的。</p>
<p><strong>缺点</strong></p>
<ul>
<li><p>在创建子类的实例时，不能向父类传参</p>
</li>
<li><p>所有实例共享父类引用类型的数据</p>
<pre><code class="language-js">function Father() {
  this.food = [];
}

function Son() {}

const father = new Father();
Son.prototype = father;

const son1 = new Son();
son1.food.push(&quot;meat&quot;);
console.log(&quot;son1.food&quot;, son1.food); // [&quot;meat&quot;]
const son2 = new Son();
son2.food.push(&quot;fish&quot;);
console.log(&quot;son2.food&quot;, son2.food); // [&quot;meat&quot;, &quot;fish&quot;]</code></pre>
</li>
</ul>
<h3 id="借用构造函数经典继承">借用构造函数(经典继承)</h3>
<p>借用构造函数就是通过其他对象的构造函数进行初始化。</p>
<pre><code>function Father(name) {
  this.name = name;
  this.eat = () =&gt; {
    console.log(&quot;eat&quot;);
  };
}

Father.prototype.sleep = () =&gt; {
  console.log(&quot;sleep&quot;);
};

function Son(name) {
  Father.call(this, name);
}

const son1 = new Son(&quot;son1&quot;);
son1.eat(); // eat
son1.sleep(); // Uncaught TypeError: son1.sleep is not a function
console.log(&quot;son1.name&quot;, son1.name); // son1
const son2 = new Son(&quot;son2&quot;);
son2.eat();// eat
console.log(&quot;son2.name&quot;, son2.name); // son2
</code></pre><p>通过调用 Father.call(this, name)使得子类可以调用父类的构造函数。</p>
<p><strong>优点</strong></p>
<ul>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以向父类传递参数</li>
<li>未改变原型链，可以通过 instanceof 来判断类型</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>只能继承父类实例的属性方法，无法继承原型的属性和方法</li>
<li>创建子类实例时会调用父类构造函数，这样每个实例都会将父类中的属性复制一份，影响性能</li>
</ul>
<h3 id="组合继承">组合继承</h3>
<p>组合继承就是组合上面的两种继承方式来实现继承。</p>
<pre><code>function Father(name) {
  this.name = name;
  this.foods = [&quot;fish&quot;, &quot;meat&quot;];
}

Father.prototype.eat = () =&gt; {
  console.log(&quot;eat&quot;);
};

Father.prototype.sleep = () =&gt; {
  console.log(&quot;sleep&quot;);
};

function Son(name) {
  Father.call(this, name);
}

Son.prototype = new Father();
//constructor设置为子类的构造函数，否则子类会通过原型链继承父类的constructor
Son.prototype.constructor = Son;

const son1 = new Son(&quot;son1&quot;);
console.log(son1.name); // son1
son1.eat(); // eat
son1.sleep(); // sleep</code></pre><p><strong>优点</strong></p>
<ul>
<li>结合了原型链继承和借用构造继承的优点，能够继承父类原型链上的属性方法，继承父类实例的属性方法，可以向父类传递参数</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>调用两次构造函数使得组合继承构造的实例在其自身和原型上拥有相同的属性和方法
第一次调用构造函数时会将父类实例的属性方法拷贝到子类的原型上。<pre><code>Son.prototype = new Father();</code></pre>第二次调用构造函数时调用时，又会将父类的属性拷贝到 son1 这个实例上。<pre><code>const son1 = new Son(&quot;son1&quot;);</code></pre>如下：son1 上有属性 foods，同样其原型上同样有 foods。<pre><code>// son1
Son {name: &quot;son1&quot;, foods: Array(2)}
name: &quot;son1&quot;
foods: (2) [&quot;fish&quot;, &quot;meat&quot;]
__proto__: Father
name: undefined
foods: (2) [&quot;fish&quot;, &quot;meat&quot;]
__proto__: Object</code></pre></li>
<li>可以通过 instanceof 来判断类型<pre><code>$ son1 instanceof Father
&gt; true
$ son1 instanceof Son
&gt; true</code></pre></li>
</ul>
<h3 id="原型式继承">原型式继承</h3>
<p>原型式继承实际就是 ES5 Object.create 的模拟实现，通过传入对象作为创建的对象的原型。</p>
<pre><code>function createObj(object) {
  function F() {}
  F.prototype = object;
  return new F();
}

const object = {
  name: &quot;xh&quot;,
  eat: () =&gt; {
    console.log(&quot;eat&quot;);
  },
  foods: [&quot;fish&quot;, &quot;meat&quot;]
};

const obj1 = createObj(object);
obj1.age = 10;
console.log(obj1.name); // xh
obj1.foods.push(&quot;rice&quot;);
console.log(obj1.foods); // [&quot;fish&quot;, &quot;meat&quot;, &quot;rice&quot;]
obj1.eat(); // eat

const obj2 = createObj(object);
obj2.age = 20;
console.log(obj2.name); // xh
console.log(obj2.foods); // [&quot;fish&quot;, &quot;meat&quot;, &quot;rice&quot;]
</code></pre><p><strong>缺点</strong></p>
<ul>
<li>同原型链继承一样，所有实例都会共享构造参数 object 上引用类型的值。</li>
<li>无法传递参数</li>
</ul>
<h3 id="寄生式继承">寄生式继承</h3>
<p>寄生式继承就是在原型式继承的基础上，增强对象，返回增强后的对象。</p>
<pre><code>function createObj(o) {
  const obj = Object.create(o);
  obj.eat = () =&gt; {
    console.log(&quot;eat&quot;);
  };
  return obj;
}

const object = {
  name: &quot;xh&quot;,
};

const obj1 = createObj(object);
console.log(obj1.name); // xh
obj1.eat(); // eat</code></pre><p><strong>缺点</strong></p>
<ul>
<li>跟原型式继承一样，会共享 object 的属性和方法</li>
<li>跟借用构造函数模式一样，每次创建对象都会创建一遍方法</li>
</ul>
<h3 id="寄生组合式继承">寄生组合式继承</h3>
<p>寄生组合式继承就是寄生式继承和组合继承的组合，前述我们已经知道组合式继承的缺点是调用了两次父类的构造函数，如果在设置子类原型时不调用父类的构造函数呢？
如下：通过构造一个空函数来让子类间接引用到父类的 prototype，调用 new F()时也就不会去构造父类的属性和方法。</p>
<pre><code>const F = function(){};
F.prototype = Father.prototype;
Son.prototype = new F();</code></pre><p>结合寄生式继承，上面的代码转换为：</p>
<pre><code>function createObject(o) {
  function F() {}
  F.prototype = o;
  return new F();
}</code></pre><p>完整的例子：</p>
<pre><code>function Father(name) {
  this.name = name;
  this.foods = [&quot;fish&quot;, &quot;meat&quot;];
}

Father.prototype.eat = () =&gt; {
  console.log(&quot;eat&quot;);
};

Father.prototype.sleep = () =&gt; {
  console.log(&quot;sleep&quot;);
};

function Son(name, age) {
  Father.call(this, name);
  this.age = age;
}

Son.prototype.play = () =&gt; {
  console.log(&quot;play&quot;);
};

function createObject(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

function inheritPrototypeFromParent(Child, Parent) {
  const prototype = createObject(Parent.prototype);
  prototype.constructor = Child;
  //保留Child原有的prototype
  Child.prototype = Object.assign(prototype, Child.prototype);;
}

inheritPrototypeFromParent(Son, Father);

const son1 = new Son(&quot;son1&quot;, 18);
son1.foods.push(&quot;rice&quot;);
console.log(son1.name); // son1
console.log(son1.foods); // [&quot;fish&quot;, &quot;meat&quot;, &quot;rice&quot;]
son1.eat(); // eat
son1.sleep(); // sleep
son1.play(); // play

const son2 = new Son(&quot;son2&quot;, 17);
console.log(son2.foods); // [&quot;fish&quot;, &quot;meat&quot;]
</code></pre><p>通过 inheritPrototypeFromParent 子类就能继承父类的 prototype 了。</p>
<pre><code>Son.prototype.play = () =&gt; {
  console.log(&quot;play&quot;);
};</code></pre><p><strong>优点</strong></p>
<ul>
<li>只调用了一次父类的构造函数</li>
<li>避免了在父类的 prototype 上面创建不必要的、多余的属性</li>
<li>实例间不共享父类的属性</li>
<li>原型链保持不变，因此，能够正常使用 instanceof 和 isPrototypeOf</li>
</ul>
<p>由于上述的优点，开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式，大多数库也是采用的这种继承方法。</p>
<h3 id="混合方式继承多个对象">混合方式继承多个对象</h3>
<pre><code>function MyClass() {
  SuperClass.call(this);
  OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
     // do something
};</code></pre><p>Object.assign 会把 OtherSuperClass 原型上的函数拷贝到 MyClass 原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h3 id="es6-类继承-extends">ES6 类继承 extends</h3>
<p>extends 关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中 constructor 表示构造函数，一个类中只能有一个构造函数，有多个会报出 SyntaxError 错误，如果没有显式指定构造方法，则会添加默认的 constructor 方法。</p>
<pre><code>class Father {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }

  eat() {
    console.log(&quot;eat&quot;);
  }
}

class Son extends Father {
  constructor(name, age) {
    super(name);
    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用super()
    this.age = age;
  }

  sleep() {
    console.log(&quot;sleep&quot;);
  }
}

const son1 = new Son(&#39;son1&#39;, 17);
console.log(son1.getName());// son1
son1.eat();// eat
son1.sleep();// sleep</code></pre><p>通过 super 调用父类的构造函数来继承父类属性。
extends 继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<pre><code>function _inherits(subType, superType) {
    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {
        constructor: {
            value: subType,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    if (superType) {
        Object.setPrototypeOf
            ? Object.setPrototypeOf(subType, superType)
            : subType.__proto__ = superType;
    }
}
</code></pre><p>extend 继承与 ES5 的继承的区别在于 ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上(Parent.call(this))，而 ES6 的继承不同，实质上是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法，否则新建实例会报错。</p>
