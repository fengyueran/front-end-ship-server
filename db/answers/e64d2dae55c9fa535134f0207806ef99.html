<ul>
<li><p>冒泡排序法</p>
<p>基本思想: 两个数比较，较小的数冒泡起来，较大的数下沉</p>
<p>过程:</p>
<ul>
<li>比较相邻的两个数，如果第二个数小，就交换位置</li>
<li>从后往前两两比较，直到最前面两个数，此时最小的数被排到了前面</li>
<li>重复上述过程，依次将第 2，3...n 个最小的数排好位置</li>
</ul>
<pre><code class="language-js">var bubbleSort = (arr) =&gt; {
  let tmp;
  let flag = false;
  for (let i = 0; i &lt; arr.length - 1; i++) {
    //表示排序次数
    flag = false;
    for (let j = arr.length - 1; j &gt; i; j--) {
      if (a[j] &lt; a[j - 1]) {
        tmp = a[j];
        a[j] = a[j - 1];
        a[j - 1] = tmp;
        flag = true;
      }
    }
    if (!flag) break; //flag为false表明没有位置交换，也就是说数组已经是有序的了
  }
};</code></pre>
<p><strong>时间复杂度计算:</strong></p>
<p>如下: 冒泡排序的时间复杂度为 O(n^2)</p>
<pre><code>假设数组长度为n，算法执行次数为T(n)，时间复杂度为O(T(n))
T(n) = (n - 1) + (n - 2) + (n - 3) + ... + n - (n - 1)
     = ((n - 1) + 1) * (n - 2) / 2
     = 0.5 * n^2 - n
O(T(n)) = O(n^2)</code></pre><p><strong>空间复杂度计算:</strong></p>
<p>可以看到，冒泡排序并没有循环分配空间，只有变量 tmp、flag、i、j 分配了空间且与数组长度无关，因此冒泡排序的空间复杂度为 O(1)。</p>
<p>冒泡排序法为稳定算法。</p>
</li>
</ul>
