<ul>
<li><p>创建节点</p>
<ul>
<li><p>createDocumentFragment()</p>
<p>创建文档片段节点，文档片段不是实际的 DOM 结构，它是一个虚拟的 dom 节点，存在于内存中，所以对片段的更改不会影响文档，也就不会重新渲染文档。
DocumentFragment 一个常见的用途是将 dom 子树封装在里面，并通过 appendChild 等方法将该片段插入的 DOM 中，这样片段中的节点就会移动到 DOM 中，而留下空白的 DocumentFragment 文档片段。因为所有的节点被一次性插入 DOM 中，只会触发一次渲染，提高了性能。</p>
<pre><code>var frag = document.createDocumentFragment();
for(let i = 0;i &lt; 100;i++) {
  const el =document.createElement(&quot;div&quot;);
  //操作片段的修改不会触发渲染
  frag.appendChild(el);
}
document.body.appendChild(frag);</code></pre></li>
<li><p>createElement(tagName)</p>
<p>创建标签名为 tagName 的节点</p>
<pre><code>var el = document.createElement(&quot;div&quot;);</code></pre></li>
<li><p>createTextNode(text)</p>
<p>创建包含文本 text 的文本节点</p>
<pre><code>document.createTextNode(&quot;text node&quot;);</code></pre></li>
<li><p>createAttribute(name)</p>
<p>创建属性节点</p>
<pre><code class="language-js">function setAttr() {
  var node = document.getElementById(&quot;root&quot;);
  var attr = document.createAttribute(&quot;属性名&quot;);
  attr.nodeValue = &quot;属性值&quot;;
  node.setAttributeNode(attr);
}
//等同于
function setAttr() {
  var node = document.getElementById(&quot;root&quot;);
  node.setAttribute(&quot;属性名&quot;, &quot;属性值&quot;);
}</code></pre>
</li>
</ul>
</li>
<li><p>操纵节点</p>
<ul>
<li><p>添加节点</p>
<p>a) Node.appendChild(element)</p>
<p>该方法将一个节点添加到指定父节点的子节点列表末尾。</p>
<pre><code>document.body.appendChild(element);</code></pre><p>b) Node.insertBefore(newNode, referenceNode)</p>
<p>该方法在参考节点之前插入一个拥有指定父节点的子节点。</p>
<pre><code>html:
&lt;div id=&quot;root&quot;&gt;
  &lt;div id=&quot;div1&quot;&gt;
&lt;div&gt;

const newNode = document.createElement(&#39;div&#39;);
const parentNode = document.getElementById(&#39;root&#39;);
const referenceNode = document.getElementById(&#39;div1&#39;);
parentNode.insertBefore(newNode, referenceNode);</code></pre></li>
<li><p>删除节点</p>
<p>Node.removeChild(child)方法从 DOM 中删除一个子节点，并返回删除的节点。</p>
<pre><code class="language-js">const node = document.getElementById(&quot;app&quot;);
if (node.parentNode) {
  node.parentNode.removeChild(node);
}</code></pre>
</li>
<li><p>替换节点</p>
<p>用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</p>
<pre><code>const replacedNode = parentNode.replaceChild(newChild, oldChild);</code></pre></li>
<li><p>复制节点</p>
<p>Node.cloneNode() 方法返回调用该方法的节点的一个副本。</p>
<pre><code>/*
  deep: 可选，是否采用深度克隆(如果为true该节点所有后代节点也会被克隆，如果为false只克隆该节点本身)
*/
const dupNode = node.cloneNode(deep);</code></pre></li>
</ul>
</li>
<li><p>查找节点</p>
<ul>
<li><p>getElementById(id)</p>
<p>返回一个匹配特定 ID 的元素。</p>
<pre><code>/*
1. 如果当前文档中拥有特定ID的元素不存在则返回null.
2. id是大小写敏感的字符串，代表了所要查找的元素的唯一ID.
*/
var element = document.getElementById(id);</code></pre></li>
<li><p>getElementsByTagName(tagName)</p>
<p>通过标签名查找，返回一个动态的包含所有指定标签名的元素的 HTML 集合 HTMLCollection。</p>
<pre><code class="language-js">//搜索从element开始。请注意只有element的后代元素会被搜索，不包括元素自己。
var elements = element.getElementsByTagName(tagName);</code></pre>
</li>
<li><p>getElementsByName()</p>
<p>根据给定的 name 返回一个在(X)HTML document 的节点列表集合。</p>
<pre><code class="language-js">//name是元素的name属性的值。
var elements = document.getElementsByName(name);</code></pre>
</li>
</ul>
</li>
</ul>
